{"/home/travis/build/npmtest/node-npmtest-docpad/test.js":"/* istanbul instrument in package npmtest_docpad */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-docpad/lib.npmtest_docpad.js":"/* istanbul instrument in package npmtest_docpad */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_docpad = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_docpad = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-docpad/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-docpad && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_docpad */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_docpad\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_docpad.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_docpad.rollup.js'] =\n            local.assetsDict['/assets.npmtest_docpad.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_docpad.__dirname + '/lib.npmtest_docpad.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/lib/docpad.js":"// Generated by CoffeeScript 1.12.4\nvar BasePlugin, CSON, Collection, DocPad, DocumentModel, ElementsCollection, EventEmitterGrouped, Events, FileModel, FilesCollection, MetaCollection, Model, PluginLoader, QueryCollection, ScriptsCollection, StylesCollection, TaskGroup, ambi, balUtil, corePath, docpadUtil, eachr, extendr, extractOptsAndCallback, ignorefs, isUser, lazyRequire, pathUtil, pick, queryEngine, ref, ref1, rimraf, safefs, safeps, scandir, setImmediate, superAgent, typeChecker, union, uniq, util,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,\n  slice = [].slice;\n\npathUtil = require('path');\n\nlazyRequire = require('lazy-require');\n\ncorePath = pathUtil.resolve(__dirname, '..', '..');\n\nif ((indexOf.call(process.argv, '--profile') >= 0)) {\n  debugger;\n  if (process.env.DOCPAD_PROFILER.indexOf('nodetime') !== -1) {\n    if (!process.env.NODETIME_KEY) {\n      throw new Error('NODETIME_KEY environment variable is undefined');\n    }\n    console.log('Loading profiling tool: nodetime');\n    require('lazy-require').sync('nodetime', {\n      cwd: corePath\n    }, function(err, nodetime) {\n      if (err) {\n        console.log('Failed to load profiling tool: nodetime');\n        return console.log(err.stack || err);\n      } else {\n        nodetime.profile({\n          accountKey: process.env.NODETIME_KEY,\n          appName: 'DocPad'\n        });\n        return console.log('Profiling with nodetime with account key:', process.env.NODETIME_KEY);\n      }\n    });\n  }\n  if (process.env.DOCPAD_PROFILER.indexOf('webkit-devtools-agent') !== -1) {\n    console.log('Loading profiling tool: webkit-devtools-agent');\n    require('lazy-require').sync('webkit-devtools-agent', {\n      cwd: corePath\n    }, function(err, agent) {\n      if (err) {\n        console.log('Failed to load profiling tool: webkit-devtools-agent');\n        return console.log(err.stack || err);\n      } else {\n        agent.start();\n        return console.log(\"Profiling with webkit-devtools-agent on pid \" + process.pid + \" at http://127.0.0.1:9999/\");\n      }\n    });\n  }\n  if (process.env.DOCPAD_PROFILER.indexOf('v8-profiler') !== -1) {\n    console.log('Loading profiling tool: v8-profiler');\n    require('lazy-require').sync('v8-profiler-helper', {\n      cwd: corePath\n    }, function(err, profiler) {\n      if (err) {\n        console.log('Failed to load profiling tool: v8-profiler');\n        console.log(err.stack || err);\n      } else {\n        profiler.startProfile('docpad-profile');\n        console.log(\"Profiling with v8-profiler\");\n      }\n      return process.on('exit', function() {\n        return profiler.stopProfile('docpad-profile');\n      });\n    });\n  }\n}\n\nutil = require('util');\n\nqueryEngine = require('query-engine');\n\nref = require('underscore'), uniq = ref.uniq, union = ref.union, pick = ref.pick;\n\nCSON = require('cson');\n\nbalUtil = require('bal-util');\n\nscandir = require('scandirectory');\n\nextendr = require('extendr');\n\neachr = require('eachr');\n\ntypeChecker = require('typechecker');\n\nambi = require('ambi');\n\nTaskGroup = require('taskgroup').TaskGroup;\n\nsafefs = require('safefs');\n\nsafeps = require('safeps');\n\nignorefs = require('ignorefs');\n\nrimraf = require('rimraf');\n\nsuperAgent = require('superagent');\n\nextractOptsAndCallback = require('extract-opts');\n\nEventEmitterGrouped = require('event-emitter-grouped').EventEmitterGrouped;\n\nref1 = require('./base'), Events = ref1.Events, Model = ref1.Model, Collection = ref1.Collection, QueryCollection = ref1.QueryCollection;\n\ndocpadUtil = require('./util');\n\nFileModel = require('./models/file');\n\nDocumentModel = require('./models/document');\n\nFilesCollection = require('./collections/files');\n\nElementsCollection = require('./collections/elements');\n\nMetaCollection = require('./collections/meta');\n\nScriptsCollection = require('./collections/scripts');\n\nStylesCollection = require('./collections/styles');\n\nPluginLoader = require('./plugin-loader');\n\nBasePlugin = require('./plugin');\n\nsetImmediate = (typeof global !== \"undefined\" && global !== null ? global.setImmediate : void 0) || process.nextTick;\n\nisUser = docpadUtil.isUser();\n\n\n/**\n * Contains methods for managing the DocPad application.\n * This includes managing a DocPad projects files and\n * documents, watching directories, emitting events and\n * managing the node.js/express.js web server.\n * Extends https://github.com/bevry/event-emitter-grouped\n *\n * The class is instantiated in the docpad-server.js file\n * which is the entry point for a DocPad application.\n *\n * \tnew DocPad(docpadConfig, function(err, docpad) {\n * \t\tif (err) {\n * \t\t\treturn docpadUtil.writeError(err);\n * \t\t}\n * \t\treturn docpad.action(action, function(err) {\n * \t\t\tif (err) {\n * \t\t\t\treturn docpadUtil.writeError(err);\n * \t\t\t}\n * \t\t\treturn console.log('OK');\n * \t\t});\n * \t});\n *\n * @class Docpad\n * @constructor\n * @extends EventEmitterGrouped\n */\n\nDocPad = (function(superClass) {\n  extend(DocPad, superClass);\n\n  DocPad.create = function() {\n    var args;\n    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return (function(func, args, ctor) {\n      ctor.prototype = func.prototype;\n      var child = new ctor, result = func.apply(child, args);\n      return Object(result) === result ? result : child;\n    })(this, args, function(){});\n  };\n\n  DocPad.createInstance = function() {\n    var args;\n    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return (function(func, args, ctor) {\n      ctor.prototype = func.prototype;\n      var child = new ctor, result = func.apply(child, args);\n      return Object(result) === result ? result : child;\n    })(this, args, function(){});\n  };\n\n  DocPad.require = function(relativePath) {\n    var absolutePath;\n    absolutePath = pathUtil.normalize(pathUtil.join(__dirname, relativePath));\n    if (absolutePath.replace(__dirname, '') === absolutePath) {\n      throw new Error(\"docpad.require is limited to local docpad files only: \" + relativePath);\n    }\n    return require(absolutePath);\n  };\n\n\n  /**\n  \t * Events class\n  \t * https://github.com/docpad/docpad/blob/master/src/lib/base.coffee\n  \t * @property {Object} Events\n   */\n\n  DocPad.prototype.Events = Events;\n\n\n  /**\n  \t * Model class\n  \t * Extension of the Backbone Model class\n  \t * http://backbonejs.org/#Model\n  \t * https://github.com/docpad/docpad/blob/master/src/lib/base.coffee\n  \t * @property {Object} Model\n   */\n\n  DocPad.prototype.Model = Model;\n\n\n  /**\n  \t * Collection class\n  \t * Extension of the Backbone Collection class\n  \t * https://github.com/docpad/docpad/blob/master/src/lib/base.coffee\n  \t * http://backbonejs.org/#Collection\n  \t * @property {Object} Collection\n   */\n\n  DocPad.prototype.Collection = Collection;\n\n\n  /**\n  \t * QueryCollection class\n  \t * Extension of the Query Engine QueryCollection class\n  \t * https://github.com/docpad/docpad/blob/master/src/lib/base.coffee\n  \t * https://github.com/bevry/query-engine/blob/master/src/documents/lib/query-engine.js.coffee\n  \t * @property {Object} QueryCollection\n   */\n\n  DocPad.prototype.QueryCollection = QueryCollection;\n\n\n  /**\n  \t * File Model class\n  \t * Extension of the Model class\n  \t * https://github.com/docpad/docpad/blob/master/src/lib/models/file.coffee\n  \t * @property {Object} FileModel\n   */\n\n  DocPad.prototype.FileModel = FileModel;\n\n\n  /**\n  \t * Document Model class\n  \t * Extension of the File Model class\n  \t * https://github.com/docpad/docpad/blob/master/src/lib/models/document.coffee\n  \t * @property {Object} DocumentModel\n   */\n\n  DocPad.prototype.DocumentModel = DocumentModel;\n\n\n  /**\n  \t * Collection of files in a DocPad project\n  \t * Extension of the QueryCollection class\n  \t * https://github.com/docpad/docpad/blob/master/src/lib/collections/files.coffee\n  \t * @property {Object} FilesCollection\n   */\n\n  DocPad.prototype.FilesCollection = FilesCollection;\n\n\n  /**\n  \t * Collection of elements in a DocPad project\n  \t * Extension of the Collection class\n  \t * https://github.com/docpad/docpad/blob/master/src/lib/collections/elements.coffee\n  \t * @property {Object} ElementsCollection\n   */\n\n  DocPad.prototype.ElementsCollection = ElementsCollection;\n\n\n  /**\n  \t * Collection of metadata in a DocPad project\n  \t * Extension of the ElementsCollection class\n  \t * https://github.com/docpad/docpad/blob/master/src/lib/collections/meta.coffee\n  \t * @property {Object} MetaCollection\n   */\n\n  DocPad.prototype.MetaCollection = MetaCollection;\n\n\n  /**\n  \t * Collection of JS script files in a DocPad project\n  \t * Extension of the ElementsCollection class\n  \t * https://github.com/docpad/docpad/blob/master/src/lib/collections/scripts.coffee\n  \t * @property {Object} ScriptsCollection\n   */\n\n  DocPad.prototype.ScriptsCollection = ScriptsCollection;\n\n\n  /**\n  \t * Collection of CSS style files in a DocPad project\n  \t * Extension of the ElementsCollection class\n  \t * https://github.com/docpad/docpad/blob/master/src/lib/collections/styles.coffee\n  \t * @property {Object} StylesCollection\n   */\n\n  DocPad.prototype.StylesCollection = StylesCollection;\n\n\n  /**\n  \t * Plugin Loader class\n  \t * https://github.com/docpad/docpad/blob/master/src/lib/plugin-loader.coffee\n  \t * Loads the DocPad plugins from the file system into\n  \t * a DocPad project\n  \t * @property {Object} PluginLoader\n   */\n\n  DocPad.prototype.PluginLoader = PluginLoader;\n\n\n  /**\n  \t * Base class for all DocPad plugins\n  \t * https://github.com/docpad/docpad/blob/master/src/lib/plugin.coffee\n  \t * @property {Object} BasePlugin\n   */\n\n  DocPad.prototype.BasePlugin = BasePlugin;\n\n\n  /**\n  \t * DocPad's version number\n  \t * @private\n  \t * @property {Number} version\n   */\n\n  DocPad.prototype.version = null;\n\n\n  /**\n  \t * Get the DocPad version number\n  \t * @method getVersion\n  \t * @return {Number}\n   */\n\n  DocPad.prototype.getVersion = function() {\n    if (this.version == null) {\n      this.version = require(this.packagePath).version;\n    }\n    return this.version;\n  };\n\n\n  /**\n  \t * Get the DocPad version string\n  \t * @method getVersionString\n  \t * @return {String}\n   */\n\n  DocPad.prototype.getVersionString = function() {\n    if (docpadUtil.isLocalDocPadExecutable()) {\n      return util.format(this.getLocale().versionLocal, this.getVersion(), this.corePath);\n    } else {\n      return util.format(this.getLocale().versionGlobal, this.getVersion(), this.corePath);\n    }\n  };\n\n\n  /**\n  \t * The plugin version requirements\n  \t * @property {String} pluginVersion\n   */\n\n  DocPad.prototype.pluginVersion = '2';\n\n\n  /**\n  \t * Get the process platform\n  \t * @method getProcessPlatform\n  \t * @return {Object}\n   */\n\n  DocPad.prototype.getProcessPlatform = function() {\n    return process.platform;\n  };\n\n\n  /**\n  \t * Get the process version string\n  \t * @method getProcessVersion\n  \t * @return {String}\n   */\n\n  DocPad.prototype.getProcessVersion = function() {\n    return process.version.replace(/^v/, '');\n  };\n\n\n  /**\n  \t * The express.js server instance bound to DocPad.\n  \t * http://expressjs.com\n  \t * @private\n  \t * @property {Object} serverExpress\n   */\n\n  DocPad.prototype.serverExpress = null;\n\n\n  /**\n  \t * The Node.js http server instance bound to DocPad\n  \t * https://nodejs.org/api/http.html\n  \t * @private\n  \t * @property {Object} serverHttp\n   */\n\n  DocPad.prototype.serverHttp = null;\n\n\n  /**\n  \t * Get the DocPad express.js server instance and, optionally,\n  \t * the node.js https server instance\n  \t * @method getServer\n  \t * @param {Boolean} [both=false]\n  \t * @return {Object}\n   */\n\n  DocPad.prototype.getServer = function(both) {\n    var ref2, serverExpress, serverHttp;\n    if (both == null) {\n      both = false;\n    }\n    ref2 = this, serverExpress = ref2.serverExpress, serverHttp = ref2.serverHttp;\n    if (both) {\n      return {\n        serverExpress: serverExpress,\n        serverHttp: serverHttp\n      };\n    } else {\n      return serverExpress;\n    }\n  };\n\n\n  /**\n  \t * Set the express.js server and node.js http server\n  \t * to bind to DocPad\n  \t * @method setServer\n  \t * @param {Object} servers\n   */\n\n  DocPad.prototype.setServer = function(servers) {\n    if (servers.serverExpress && servers.serverHttp) {\n      this.serverExpress = servers.serverExpress;\n      this.serverHttp = servers.serverHttp;\n    }\n    delete this.config.serverHttp;\n    delete this.config.serverExpress;\n    return delete this.config.server;\n  };\n\n\n  /**\n  \t * Destructor. Close and destroy the node.js http server\n  \t * @private\n  \t * @method destroyServer\n   */\n\n  DocPad.prototype.destroyServer = function() {\n    var ref2;\n    if ((ref2 = this.serverHttp) != null) {\n      ref2.close();\n    }\n    return this.serverHttp = null;\n  };\n\n\n  /**\n  \t * Internal property. The caterpillar logger instances bound to DocPad\n  \t * @private\n  \t * @property {Object} loggerInstances\n   */\n\n  DocPad.prototype.loggerInstances = null;\n\n\n  /**\n  \t * Get the caterpillar logger instance bound to DocPad\n  \t * @method getLogger\n  \t * @return {Object} caterpillar logger\n   */\n\n  DocPad.prototype.getLogger = function() {\n    var ref2;\n    return (ref2 = this.loggerInstances) != null ? ref2.logger : void 0;\n  };\n\n\n  /**\n  \t * Get all the caterpillar logger instances bound to DocPad\n  \t * @method getLoggers\n  \t * @return {Object} collection of caterpillar loggers\n   */\n\n  DocPad.prototype.getLoggers = function() {\n    return this.loggerInstances;\n  };\n\n\n  /**\n  \t * Sets the caterpillar logger instances bound to DocPad\n  \t * @method setLoggers\n  \t * @param {Object} loggers\n  \t * @return {Object} logger instances bound to DocPad\n   */\n\n  DocPad.prototype.setLoggers = function(loggers) {\n    if (this.loggerInstances) {\n      this.warn(this.getLocale().loggersAlreadyDefined);\n    } else {\n      this.loggerInstances = loggers;\n      this.loggerInstances.logger.setConfig({\n        dry: true\n      });\n      this.loggerInstances.console.setConfig({\n        dry: false\n      }).pipe(process.stdout);\n    }\n    return loggers;\n  };\n\n\n  /**\n  \t * Destructor. Destroy the caterpillar logger instances bound to DocPad\n  \t * @private\n  \t * @method {Object} destroyLoggers\n   */\n\n  DocPad.prototype.destroyLoggers = function() {\n    var key, ref2, value;\n    if (this.loggerInstances) {\n      ref2 = this.loggerInstances;\n      for (key in ref2) {\n        if (!hasProp.call(ref2, key)) continue;\n        value = ref2[key];\n        value.end();\n      }\n    }\n    return this;\n  };\n\n\n  /**\n  \t * The action runner instance bound to docpad\n  \t * @private\n  \t * @property {Object} actionRunnerInstance\n   */\n\n  DocPad.prototype.actionRunnerInstance = null;\n\n\n  /**\n  \t * Get the action runner instance bound to docpad\n  \t * @method getActionRunner\n  \t * @return {Object} the action runner instance\n   */\n\n  DocPad.prototype.getActionRunner = function() {\n    return this.actionRunnerInstance;\n  };\n\n\n  /**\n  \t * Apply the passed DocPad action arguments\n  \t * @method {Object} action\n  \t * @param {Object} args\n  \t * @return {Object}\n   */\n\n  DocPad.prototype.action = function() {\n    var args;\n    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return docpadUtil.action.apply(this, args);\n  };\n\n\n  /**\n  \t * The error runner instance bound to DocPad\n  \t * @property {Object} errorRunnerInstance\n   */\n\n  DocPad.prototype.errorRunnerInstance = null;\n\n\n  /**\n  \t * Get the error runner instance\n  \t * @method {Object} getErrorRunner\n  \t * @return {Object} the error runner instance\n   */\n\n  DocPad.prototype.getErrorRunner = function() {\n    return this.errorRunnerInstance;\n  };\n\n\n  /**\n  \t * The track runner instance bound to DocPad\n  \t * @private\n  \t * @property {Object} trackRunnerInstance\n   */\n\n  DocPad.prototype.trackRunnerInstance = null;\n\n\n  /**\n  \t * Get the track runner instance\n  \t * @method getTrackRunner\n  \t * @return {Object} the track runner instance\n   */\n\n  DocPad.prototype.getTrackRunner = function() {\n    return this.trackRunnerInstance;\n  };\n\n\n  /**\n  \t * Event Listing. String array of event names.\n  \t * Whenever an event is created, it must be applied here to be available to plugins and configuration files\n  \t * https://github.com/bevry/docpad/wiki/Events\n  \t * @private\n  \t * @property {Array} string array of event names\n   */\n\n  DocPad.prototype.events = ['extendTemplateData', 'extendCollections', 'docpadLoaded', 'docpadReady', 'docpadDestroy', 'consoleSetup', 'generateBefore', 'populateCollectionsBefore', 'populateCollections', 'contextualizeBefore', 'contextualizeAfter', 'renderBefore', 'renderCollectionBefore', 'render', 'renderDocument', 'renderCollectionAfter', 'renderAfter', 'writeBefore', 'writeAfter', 'generateAfter', 'generated', 'serverBefore', 'serverExtend', 'serverAfter', 'notify'];\n\n\n  /**\n  \t * Get the list of available events\n  \t * @method getEvents\n  \t * @return {Object} string array of event names\n   */\n\n  DocPad.prototype.getEvents = function() {\n    return this.events;\n  };\n\n\n  /**\n  \t * QueryEngine collection\n  \t * @private\n  \t * @property {Object} database\n   */\n\n  DocPad.prototype.database = null;\n\n\n  /**\n  \t * A FilesCollection of models updated\n  \t * from the DocPad database after each regeneration.\n  \t * @private\n  \t * @property {Object} databaseTempCache FileCollection of models\n   */\n\n  DocPad.prototype.databaseTempCache = null;\n\n\n  /**\n  \t * Description for getDatabase\n  \t * @method {Object} getDatabase\n   */\n\n  DocPad.prototype.getDatabase = function() {\n    return this.database;\n  };\n\n\n  /**\n  \t * Safe method for retrieving the database by\n  \t * either returning the database itself or the temporary\n  \t * database cache\n  \t * @method getDatabaseSafe\n  \t * @return {Object}\n   */\n\n  DocPad.prototype.getDatabaseSafe = function() {\n    return this.databaseTempCache || this.database;\n  };\n\n\n  /**\n  \t * Destructor. Destroy the DocPad database\n  \t * @private\n  \t * @method destroyDatabase\n   */\n\n  DocPad.prototype.destroyDatabase = function() {\n    if (this.database != null) {\n      this.database.destroy();\n      this.database = null;\n    }\n    if (this.databaseTempCache != null) {\n      this.databaseTempCache.destroy();\n      this.databaseTempCache = null;\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Files by url. Used to speed up fetching\n  \t * @private\n  \t * @property {Object} filesByUrl\n   */\n\n  DocPad.prototype.filesByUrl = null;\n\n\n  /**\n  \t * Files by Selector. Used to speed up fetching\n  \t * @private\n  \t * @property {Object} filesBySelector\n   */\n\n  DocPad.prototype.filesBySelector = null;\n\n\n  /**\n  \t * Files by Out Path. Used to speed up conflict detection. Do not use for anything else\n  \t * @private\n  \t * @property {Object} filesByOutPath\n   */\n\n  DocPad.prototype.filesByOutPath = null;\n\n\n  /**\n  \t * Blocks\n  \t * @private\n  \t * @property {Object} blocks\n   */\n\n  DocPad.prototype.blocks = null;\n\n\n  /* {\n  \t\t * A collection of meta elements\n  \t\tmeta: null  # Elements Collection\n  \n  \t\t * A collection of script elements\n  \t\tscripts: null  # Scripts Collection\n  \n  \t\t * Collection of style elements\n  \t\tstyles: null  # Styles Collection\n  \t}\n   */\n\n\n  /**\n  \t * Get a block by block name. Optionally clone block.\n  \t * @method getBlock\n  \t * @param {String} name\n  \t * @param {Object} [clone]\n  \t * @return {Object} block\n   */\n\n  DocPad.prototype.getBlock = function(name, clone) {\n    var block, classname;\n    block = this.blocks[name];\n    if (clone) {\n      classname = name[0].toUpperCase() + name.slice(1) + 'Collection';\n      block = new this[classname](block.models);\n    }\n    return block;\n  };\n\n\n  /**\n  \t * Set a block by name and value\n  \t * @method setBlock\n  \t * @param {String} name\n  \t * @param {Object} value\n   */\n\n  DocPad.prototype.setBlock = function(name, value) {\n    if (this.blocks[name] != null) {\n      this.blocks[name].destroy();\n      if (value) {\n        this.blocks[name] = value;\n      } else {\n        delete this.blocks[name];\n      }\n    } else {\n      this.blocks[name] = value;\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Get all blocks\n  \t * @method getBlocks\n  \t * @return {Object} collection of blocks\n   */\n\n  DocPad.prototype.getBlocks = function() {\n    return this.blocks;\n  };\n\n\n  /**\n  \t * Set all blocks\n  \t * @method setBlocks\n  \t * @param {Object} blocks\n   */\n\n  DocPad.prototype.setBlocks = function(blocks) {\n    var name, value;\n    for (name in blocks) {\n      if (!hasProp.call(blocks, name)) continue;\n      value = blocks[name];\n      this.setBlock(name, value);\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Apply the passed function to each block\n  \t * @method eachBlock\n  \t * @param {Function} fn\n   */\n\n  DocPad.prototype.eachBlock = function(fn) {\n    eachr(this.blocks, fn);\n    return this;\n  };\n\n\n  /**\n  \t * Destructor. Destroy all blocks\n  \t * @private\n  \t * @method destroyBlocks\n   */\n\n  DocPad.prototype.destroyBlocks = function() {\n    var block, name, ref2;\n    if (this.blocks) {\n      ref2 = this.blocks;\n      for (name in ref2) {\n        if (!hasProp.call(ref2, name)) continue;\n        block = ref2[name];\n        block.destroy();\n        this.blocks[name] = null;\n      }\n    }\n    return this;\n  };\n\n\n  /**\n  \t * The DocPad collections\n  \t * @private\n  \t * @property {Object} collections\n   */\n\n  DocPad.prototype.collections = null;\n\n\n  /**\n  \t * Get a collection by collection name or key.\n  \t * This is often accessed within the docpad.coffee\n  \t * file or a layout/page via @getCollection.\n  \t * Because getCollection returns a docpad collection,\n  \t * a call to this method is often chained with a\n  \t * QueryEngine style query.\n  \t *\n  \t * \t@getCollection('documents').findAllLive({relativeOutDirPath: 'posts'},[{date:-1}])\n  \t *\n  \t * @method getCollection\n  \t * @param {String} value\n  \t * @return {Object} collection\n   */\n\n  DocPad.prototype.getCollection = function(value) {\n    var collection, i, j, len, len1, ref2, ref3;\n    if (value) {\n      if (typeof value === 'string') {\n        if (value === 'database') {\n          return this.getDatabase();\n        } else {\n          ref2 = this.collections;\n          for (i = 0, len = ref2.length; i < len; i++) {\n            collection = ref2[i];\n            if (value === collection.options.name || value === collection.options.key) {\n              return collection;\n            }\n          }\n        }\n      } else {\n        ref3 = this.collections;\n        for (j = 0, len1 = ref3.length; j < len1; j++) {\n          collection = ref3[j];\n          if (value === collection) {\n            return collection;\n          }\n        }\n      }\n    }\n    return null;\n  };\n\n\n  /**\n  \t * Destroy a collection by collection name or key\n  \t * @method destroyCollection\n  \t * @param {String} value\n  \t * @return {Object} description\n   */\n\n  DocPad.prototype.destroyCollection = function(value) {\n    if (value) {\n      if (typeof value === 'string' && value !== 'database') {\n        this.collections = this.collections.filter(function(collection) {\n          if (value === collection.options.name || value === collection.options.key) {\n            if (collection != null) {\n              collection.destroy();\n            }\n            return false;\n          } else {\n            return true;\n          }\n        });\n      } else if (value !== this.getDatabase()) {\n        this.collections = this.collections.filter(function(collection) {\n          if (value === collection) {\n            if (collection != null) {\n              collection.destroy();\n            }\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n    }\n    return null;\n  };\n\n\n  /**\n  \t * Add a collection\n  \t * @method addCollection\n  \t * @param {Object} collection\n   */\n\n  DocPad.prototype.addCollection = function(collection) {\n    if (collection && (collection !== this.getDatabase() && collection !== this.getCollection(collection))) {\n      this.collections.push(collection);\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Set a name for a collection.\n  \t * A collection can have multiple names\n  \t *\n  \t * The partials plugin (https://github.com/docpad/docpad-plugin-partials)\n  \t * creates a live collection and passes this to setCollection with\n  \t * the name 'partials'.\n  \t *\n  \t * \t# Add our partials collection\n  \t *\tdocpad.setCollection('partials', database.createLiveChildCollection()\n  \t *\t\t.setQuery('isPartial', {\n  \t *\t\t\t\t$or:\n  \t *\t\t\t\t\tisPartial: true\n  \t *\t\t\t\t\tfullPath: $startsWith: config.partialsPath\n  \t *\t\t})\n  \t *\t\t.on('add', (model) ->\n  \t *\t\t\tdocpad.log('debug', util.format(locale.addingPartial, model.getFilePath()))\n  \t *\t\t\tmodel.setDefaults(\n  \t *\t\t\t\tisPartial: true\n  \t *\t\t\t\trender: false\n  \t *\t\t\t\twrite: false\n  \t *\t\t\t)\n  \t *\t\t)\n  \t *\t)\n  \t *\n  \t *\n  \t * @method setCollection\n  \t * @param {String} name the name to give to the collection\n  \t * @param {Object} collection a DocPad collection\n   */\n\n  DocPad.prototype.setCollection = function(name, collection) {\n    if (collection) {\n      if (name) {\n        collection.options.name = name;\n        if (this.getCollection(name) !== collection) {\n          this.destroyCollection(name);\n        }\n      }\n      return this.addCollection(collection);\n    } else {\n      return this.destroyCollection(name);\n    }\n  };\n\n\n  /**\n  \t * Get the DocPad project's collections\n  \t * @method getCollections\n  \t * @return {Object} the collections\n   */\n\n  DocPad.prototype.getCollections = function() {\n    return this.collections;\n  };\n\n\n  /**\n  \t * Set the DocPad project's collections\n  \t * @method setCollections\n   */\n\n  DocPad.prototype.setCollections = function(collections) {\n    var i, len, name, value;\n    if (Array.isArray(collections)) {\n      for (i = 0, len = collections.length; i < len; i++) {\n        value = collections[i];\n        this.addCollection(value);\n      }\n    } else {\n      for (name in collections) {\n        if (!hasProp.call(collections, name)) continue;\n        value = collections[name];\n        this.setCollection(name, value);\n      }\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Apply the passed function to each collection\n  \t * @method eachCollection\n  \t * @param {Function} fn\n   */\n\n  DocPad.prototype.eachCollection = function(fn) {\n    var collection, i, index, len, ref2;\n    fn(this.getDatabase(), 'database');\n    ref2 = this.collections;\n    for (index = i = 0, len = ref2.length; i < len; index = ++i) {\n      collection = ref2[index];\n      fn(collection, collection.options.name || collection.options.key || index);\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Destructor. Destroy the DocPad project's collections.\n  \t * @private\n  \t * @method destroyCollections\n   */\n\n  DocPad.prototype.destroyCollections = function() {\n    var collection, i, len, ref2;\n    if (this.collections) {\n      ref2 = this.collections;\n      for (i = 0, len = ref2.length; i < len; i++) {\n        collection = ref2[i];\n        collection.destroy();\n      }\n      this.collections = [];\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Get all the files in the DocPad database (will use live collections)\n  \t * @method getFiles\n  \t * @param {Object} query\n  \t * @param {Object} sorting\n  \t * @param {Object} paging\n  \t * @return {Object} collection\n   */\n\n  DocPad.prototype.getFiles = function(query, sorting, paging) {\n    var collection, key;\n    key = JSON.stringify({\n      query: query,\n      sorting: sorting,\n      paging: paging\n    });\n    collection = this.getCollection(key);\n    if (!collection) {\n      collection = this.getDatabase().findAllLive(query, sorting, paging);\n      collection.options.key = key;\n      this.addCollection(collection);\n    }\n    return collection;\n  };\n\n\n  /**\n  \t * Get a single file based on a query\n  \t * @method getFile\n  \t * @param {Object} query\n  \t * @param {Object} sorting\n  \t * @param {Object} paging\n  \t * @return {Object} a file\n   */\n\n  DocPad.prototype.getFile = function(query, sorting, paging) {\n    var file;\n    file = this.getDatabase().findOne(query, sorting, paging);\n    return file;\n  };\n\n\n  /**\n  \t * Get files at a path\n  \t * @method getFilesAtPath\n  \t * @param {String} path\n  \t * @param {Object} sorting\n  \t * @param {Object} paging\n  \t * @return {Object} files\n   */\n\n  DocPad.prototype.getFilesAtPath = function(path, sorting, paging) {\n    var files, query;\n    query = {\n      $or: [\n        {\n          relativePath: {\n            $startsWith: path\n          }\n        }, {\n          fullPath: {\n            $startsWith: path\n          }\n        }\n      ]\n    };\n    files = this.getFiles(query, sorting, paging);\n    return files;\n  };\n\n\n  /**\n  \t * Get a file at a relative or absolute path or url\n  \t * @method getFileAtPath\n  \t * @param {String} path\n  \t * @param {Object} sorting\n  \t * @param {Object} paging\n  \t * @return {Object} a file\n   */\n\n  DocPad.prototype.getFileAtPath = function(path, sorting, paging) {\n    var file;\n    file = this.getDatabase().fuzzyFindOne(path, sorting, paging);\n    return file;\n  };\n\n\n  /**\n  \t * Get a file by its url\n  \t * @method getFileByUrl\n  \t * @param {String} url\n  \t * @param {Object} [opts={}]\n  \t * @return {Object} a file\n   */\n\n  DocPad.prototype.getFileByUrl = function(url, opts) {\n    var file;\n    if (opts == null) {\n      opts = {};\n    }\n    if (opts.collection == null) {\n      opts.collection = this.getDatabase();\n    }\n    file = opts.collection.get(this.filesByUrl[url]);\n    return file;\n  };\n\n\n  /**\n  \t * Get a file by its id\n  \t * @method getFileById\n  \t * @param {String} id\n  \t * @param {Object} [opts={}]\n  \t * @return {Object} a file\n   */\n\n  DocPad.prototype.getFileById = function(id, opts) {\n    var file;\n    if (opts == null) {\n      opts = {};\n    }\n    if (opts.collection == null) {\n      opts.collection = this.getDatabase();\n    }\n    file = opts.collection.get(id);\n    return file;\n  };\n\n\n  /**\n  \t * Remove the query string from a url\n  \t * Pathname convention taken from document.location.pathname\n  \t * @method getUrlPathname\n  \t * @param {String} url\n  \t * @return {String}\n   */\n\n  DocPad.prototype.getUrlPathname = function(url) {\n    return url.replace(/\\?.*/, '');\n  };\n\n\n  /**\n  \t * Get a file by its route and return\n  \t * it to the supplied callback.\n  \t * @method getFileByRoute\n  \t * @param {String} url\n  \t * @param {Object} next\n  \t * @param {Error} next.err\n  \t * @param {String} next.file\n   */\n\n  DocPad.prototype.getFileByRoute = function(url, next) {\n    var cleanUrl, database, docpad, file;\n    docpad = this;\n    if (docpad.generated === false) {\n      docpad.once('generated', function() {\n        return docpad.getFileByRoute(url, next);\n      });\n      return this;\n    }\n    database = docpad.getDatabaseSafe();\n    cleanUrl = docpad.getUrlPathname(url);\n    file = docpad.getFileByUrl(url, {\n      collection: database\n    }) || docpad.getFileByUrl(cleanUrl, {\n      collection: database\n    });\n    next(null, file);\n    return this;\n  };\n\n\n  /**\n  \t * Get a file by its selector\n  \t * @method getFileBySelector\n  \t * @param {Object} selector\n  \t * @param {Object} [opts={}]\n  \t * @return {Object} a file\n   */\n\n  DocPad.prototype.getFileBySelector = function(selector, opts) {\n    var file;\n    if (opts == null) {\n      opts = {};\n    }\n    if (opts.collection == null) {\n      opts.collection = this.getDatabase();\n    }\n    file = opts.collection.get(this.filesBySelector[selector]);\n    if (!file) {\n      file = opts.collection.fuzzyFindOne(selector);\n      if (file) {\n        this.filesBySelector[selector] = file.id;\n      }\n    }\n    return file;\n  };\n\n\n  /**\n  \t * Skeletons Collection\n  \t * @private\n  \t * @property {Object} skeletonsCollection\n   */\n\n  DocPad.prototype.skeletonsCollection = null;\n\n\n  /**\n  \t * Get Skeletons\n  \t * Get all the available skeletons with their details and\n  \t * return this collection to the supplied callback.\n  \t * @method getSkeletons\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.skeletonsCollection DocPad collection of skeletons\n  \t * @return {Object} DocPad skeleton collection\n   */\n\n  DocPad.prototype.getSkeletons = function(next) {\n    var docpad, locale;\n    docpad = this;\n    locale = this.getLocale();\n    if (this.skeletonsCollection != null) {\n      return next(null, this.skeletonsCollection);\n    }\n    this.skeletonsCollection = new Collection();\n    this.skeletonsCollection.comparator = queryEngine.generateComparator({\n      position: 1,\n      name: 1\n    });\n    this.getExchange(function(err, exchange) {\n      var index;\n      if (err) {\n        return next(err);\n      }\n      index = 0;\n      if (exchange) {\n        eachr(exchange.skeletons, function(skeleton, skeletonKey) {\n          if (skeleton.id == null) {\n            skeleton.id = skeletonKey;\n          }\n          if (skeleton.name == null) {\n            skeleton.name = skeletonKey;\n          }\n          if (skeleton.position == null) {\n            skeleton.position = index;\n          }\n          docpad.skeletonsCollection.add(new Model(skeleton));\n          return ++index;\n        });\n      }\n      docpad.skeletonsCollection.add(new Model({\n        id: 'none',\n        name: locale.skeletonNoneName,\n        description: locale.skeletonNoneDescription,\n        position: index\n      }));\n      return next(null, docpad.skeletonsCollection);\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Plugins that are loading really slow\n  \t * @property {Object} slowPlugins\n   */\n\n  DocPad.prototype.slowPlugins = null;\n\n\n  /**\n  \t * Loaded plugins indexed by name\n  \t * @property {Object} loadedPlugins\n   */\n\n  DocPad.prototype.loadedPlugins = null;\n\n\n  /**\n  \t * A listing of all the available extensions for DocPad\n  \t * @property {Object} exchange\n   */\n\n  DocPad.prototype.exchange = null;\n\n\n  /**\n  \t * The DocPad directory\n  \t * @property {String} corePath\n   */\n\n  DocPad.prototype.corePath = corePath;\n\n\n  /**\n  \t * The DocPad library directory\n  \t * @private\n  \t * @property {String} libPath\n   */\n\n  DocPad.prototype.libPath = __dirname;\n\n\n  /**\n  \t * The main DocPad file\n  \t * @property {String} mainPath\n   */\n\n  DocPad.prototype.mainPath = pathUtil.resolve(__dirname, 'docpad');\n\n\n  /**\n  \t * The DocPad package.json path\n  \t * @property {String} packagePath\n   */\n\n  DocPad.prototype.packagePath = pathUtil.resolve(__dirname, '..', '..', 'package.json');\n\n\n  /**\n  \t * The DocPad locale path\n  \t * @property {String} localePath\n   */\n\n  DocPad.prototype.localePath = pathUtil.resolve(__dirname, '..', '..', 'locale');\n\n\n  /**\n  \t * The DocPad debug log path (docpad-debug.log)\n  \t * @property {String} debugLogPath\n   */\n\n  DocPad.prototype.debugLogPath = pathUtil.join(process.cwd(), 'docpad-debug.log');\n\n\n  /**\n  \t * The User's configuration path (.docpad.cson)\n  \t * @property {String} userConfigPath\n   */\n\n  DocPad.prototype.userConfigPath = '.docpad.cson';\n\n\n  /**\n  \t * Description for initialTemplateData\n  \t * @private\n  \t * @property {Object} initialTemplateData\n   */\n\n  DocPad.prototype.initialTemplateData = null;\n\n\n  /**\n  \t * Plugin's Extended Template Data\n  \t * @private\n  \t * @property {Object} pluginsTemplateData\n   */\n\n  DocPad.prototype.pluginsTemplateData = null;\n\n\n  /**\n  \t * Get Complete Template Data\n  \t * @method getTemplateData\n  \t * @param {Object} userTemplateData\n  \t * @return {Object} templateData\n   */\n\n  DocPad.prototype.getTemplateData = function(userTemplateData) {\n    var base, base1, base2, docpad, locale, templateData;\n    userTemplateData || (userTemplateData = {});\n    docpad = this;\n    locale = this.getLocale();\n    if (this.initialTemplateData == null) {\n      this.initialTemplateData = {\n        site: {},\n        getEnvironment: function() {\n          return docpad.getEnvironment();\n        },\n        getEnvironments: function() {\n          return docpad.getEnvironments();\n        },\n        referencesOthers: function(flag) {\n          var document;\n          document = this.getDocument();\n          document.referencesOthers();\n          return null;\n        },\n        getDocument: function() {\n          return this.documentModel;\n        },\n        getPath: function(path, parentPath) {\n          var document;\n          document = this.getDocument();\n          path = document.getPath(path, parentPath);\n          return path;\n        },\n        getFiles: function(query, sorting, paging) {\n          var result;\n          this.referencesOthers();\n          result = docpad.getFiles(query, sorting, paging);\n          return result;\n        },\n        getFile: function(query, sorting, paging) {\n          var result;\n          this.referencesOthers();\n          result = docpad.getFile(query, sorting, paging);\n          return result;\n        },\n        getFilesAtPath: function(path, sorting, paging) {\n          var result;\n          this.referencesOthers();\n          path = this.getPath(path);\n          result = docpad.getFilesAtPath(path, sorting, paging);\n          return result;\n        },\n        getFileAtPath: function(relativePath) {\n          var path, result;\n          this.referencesOthers();\n          path = this.getPath(relativePath);\n          result = docpad.getFileAtPath(path);\n          return result;\n        },\n        getFileById: function(id) {\n          var result;\n          this.referencesOthers();\n          result = docpad.getFileById(id);\n          return result;\n        },\n        getDatabase: function() {\n          this.referencesOthers();\n          return docpad.getDatabase();\n        },\n        getCollection: function(name) {\n          this.referencesOthers();\n          return docpad.getCollection(name);\n        },\n        getBlock: function(name) {\n          return docpad.getBlock(name, true);\n        },\n        include: function(subRelativePath, strict) {\n          var err, file;\n          if (strict == null) {\n            strict = true;\n          }\n          file = this.getFileAtPath(subRelativePath);\n          if (file) {\n            if (strict && file.get('rendered') === false) {\n              if (docpad.getConfig().renderPasses === 1) {\n                docpad.warn(util.format(locale.renderedEarlyViaInclude, subRelativePath));\n              }\n              return null;\n            }\n            return file.getOutContent();\n          } else {\n            err = new Error(util.format(locale.includeFailed, subRelativePath));\n            throw err;\n          }\n        }\n      };\n    }\n    templateData = extendr.extend({}, this.initialTemplateData, this.pluginsTemplateData, this.getConfig().templateData, userTemplateData);\n    (base = templateData.site).url || (base.url = this.getSimpleServerUrl());\n    (base1 = templateData.site).date || (base1.date = new Date());\n    (base2 = templateData.site).keywords || (base2.keywords = []);\n    if (typeChecker.isString(templateData.site.keywords)) {\n      templateData.site.keywords = templateData.site.keywords.split(/,\\s*/g);\n    }\n    return templateData;\n  };\n\n\n  /**\n  \t * Determined locale\n  \t * @private\n  \t * @property {Object} locale\n   */\n\n  DocPad.prototype.locale = null;\n\n\n  /**\n  \t * Get the locale (language code and locale code)\n  \t * @method getLocale\n  \t * @return {Object} locale\n   */\n\n  DocPad.prototype.getLocale = function() {\n    var code, codes, config, locales;\n    if ((this.locale != null) === false) {\n      config = this.getConfig();\n      codes = uniq(['en', safeps.getLanguageCode(config.localeCode), safeps.getLanguageCode(safeps.getLocaleCode()), safeps.getLocaleCode(config.localeCode), safeps.getLocaleCode(safeps.getLocaleCode())]);\n      locales = (function() {\n        var i, len, results;\n        results = [];\n        for (i = 0, len = codes.length; i < len; i++) {\n          code = codes[i];\n          results.push(this.loadLocale(code));\n        }\n        return results;\n      }).call(this);\n      this.locale = extendr.extend.apply(extendr, locales);\n    }\n    return this.locale;\n  };\n\n\n  /**\n  \t * Load the locale\n  \t * @method loadLocale\n  \t * @param {String} code\n  \t * @return {Object} locale\n   */\n\n  DocPad.prototype.loadLocale = function(code) {\n    var docpad, locale, localeFilename, localePath;\n    docpad = this;\n    localeFilename = code + \".cson\";\n    localePath = pathUtil.join(this.localePath, localeFilename);\n    if (!safefs.existsSync(localePath)) {\n      return null;\n    }\n    locale = CSON.parseCSONFile(localePath);\n    if (locale instanceof Error) {\n      locale.context = \"Failed to parse the CSON locale file: \" + localePath;\n      docpad.error(locale);\n      return null;\n    }\n    return locale;\n  };\n\n\n  /**\n  \t * Get the DocPad environment, eg: development,\n  \t * production or static\n  \t * @method getEnvironment\n  \t * @return {String} the environment\n   */\n\n  DocPad.prototype.getEnvironment = function() {\n    var env;\n    env = this.getConfig().env || 'development';\n    return env;\n  };\n\n\n  /**\n  \t * Get the environments\n  \t * @method getEnvironments\n  \t * @return {Array} array of environment strings\n   */\n\n  DocPad.prototype.getEnvironments = function() {\n    var env, envs;\n    env = this.getEnvironment();\n    envs = env.split(/[, ]+/);\n    return envs;\n  };\n\n\n  /**\n  \t * Hash Key\n  \t * The key that we use to hash some data before sending it to our statistic server\n  \t * @private\n  \t * @property {String} string constant\n   */\n\n  DocPad.prototype.hashKey = '7>9}$3hP86o,4=@T';\n\n\n  /**\n  \t * Website Package Configuration\n  \t * @private\n  \t * @property {Object} websitePackageConfig\n   */\n\n  DocPad.prototype.websitePackageConfig = null;\n\n\n  /**\n  \t * Merged Configuration\n  \t * Merged in the order of:\n  \t * - initialConfig\n  \t * - userConfig\n  \t * - websiteConfig\n  \t * - instanceConfig\n  \t * - environmentConfig\n  \t * Use getConfig to retrieve this value\n  \t * @private\n  \t * @property {Object} config\n   */\n\n  DocPad.prototype.config = null;\n\n\n  /**\n  \t * Instance Configuration\n  \n  \t * @private\n  \t * @property {Object} instanceConfig\n   */\n\n  DocPad.prototype.instanceConfig = null;\n\n\n  /**\n  \t * Website Configuration\n  \t * Merged into the config property\n  \t * @private\n  \t * @property {Object} websiteConfig\n   */\n\n  DocPad.prototype.websiteConfig = null;\n\n\n  /**\n  \t * User Configuraiton\n  \t * Merged into the config property\n  \t * @private\n  \t * @property {Object} userConfig\n   */\n\n  DocPad.prototype.userConfig = {\n    name: null,\n    email: null,\n    username: null,\n    subscribed: null,\n    subscribeTryAgain: null,\n    tos: null,\n    identified: null\n  };\n\n\n  /**\n  \t * Initial Configuration. The default docpadConfig\n  \t * settings that can be overridden in a project's docpad.coffee file.\n  \t * Merged into the config property\n  \t * @private\n  \t * @property {Object} initialConfig\n   */\n\n  DocPad.prototype.initialConfig = {\n    force: false,\n    global: false,\n    enableUnlistedPlugins: true,\n    enabledPlugins: {},\n    skipUnsupportedPlugins: true,\n    warnUncompiledPrivatePlugins: true,\n    plugins: {},\n    rootPath: process.cwd(),\n    databaseCachePath: '.docpad.db',\n    packagePath: 'package.json',\n    configPaths: ['docpad.js', 'docpad.coffee', 'docpad.json', 'docpad.cson'],\n    pluginPaths: [],\n    pluginsPaths: ['node_modules', 'plugins'],\n    reloadPaths: [],\n    regeneratePaths: [],\n    regenerateDelay: 100,\n    slowFilesDelay: 20 * 1000,\n    outPath: 'out',\n    srcPath: 'src',\n    documentsPaths: ['documents', 'render'],\n    filesPaths: ['files', 'static', 'public'],\n    layoutsPaths: ['layouts'],\n    ignorePaths: false,\n    ignoreHiddenFiles: false,\n    ignoreCommonPatterns: true,\n    ignoreCustomPatterns: false,\n    watchOptions: null,\n    port: null,\n    hostname: null,\n    maxAge: 86400000,\n    serverExpress: null,\n    serverHttp: null,\n    extendServer: true,\n    middlewareStandard: true,\n    middlewareBodyParser: true,\n    middlewareMethodOverride: true,\n    middlewareExpressRouter: true,\n    middleware404: true,\n    middleware500: true,\n    logLevel: ((indexOf.call(process.argv, '-d') >= 0) ? 7 : 6),\n    catchExceptions: true,\n    reportErrors: process.argv.join('').indexOf('test') === -1,\n    reportStatistics: process.argv.join('').indexOf('test') === -1,\n    color: null,\n    databaseCache: false,\n    detectEncoding: false,\n    renderSingleExtensions: false,\n    renderPasses: 1,\n    offline: false,\n    checkVersion: false,\n    welcome: false,\n    prompts: false,\n    progress: true,\n    poweredByDocPad: true,\n    helperUrl: true ? 'http://helper.docpad.org/' : 'http://localhost:8000/',\n    safeMode: false,\n    templateData: {},\n    collections: {},\n    events: {},\n    regenerateEvery: false,\n    regenerateEveryOptions: {\n      populate: true,\n      partial: false\n    },\n    localeCode: null,\n    env: null,\n    environments: {\n      development: {\n        maxAge: false,\n        checkVersion: isUser,\n        welcome: isUser,\n        prompts: isUser\n      }\n    }\n  };\n\n\n  /**\n  \t * Regenerate Timer\n  \t * When config.regenerateEvery is set to a value, we create a timer here\n  \t * @private\n  \t * @property {Object} regenerateTimer\n   */\n\n  DocPad.prototype.regenerateTimer = null;\n\n\n  /**\n  \t * Get the DocPad configuration. Commonly\n  \t * called within the docpad.coffee file or within\n  \t * plugins to access application specific configurations.\n  \t * \tserverExtend: (opts) ->\n  \t\t\t * Extract the server from the options\n  \t\t\t{server} = opts\n  \t\t\tdocpad = @docpad\n  \n  \t\t\t * As we are now running in an event,\n  \t\t\t * ensure we are using the latest copy of the docpad configuraiton\n  \t\t\t * and fetch our urls from it\n  \t\t\tlatestConfig = docpad.getConfig()\n  \t\t\toldUrls = latestConfig.templateData.site.oldUrls or []\n  \t\t\tnewUrl = latestConfig.templateData.site.url\n  \n  \t\t\t * Redirect any requests accessing one of our sites oldUrls to the new site url\n  \t\t\tserver.use (req,res,next) ->\n  \t\t\t\t...\n  \t * @method getConfig\n  \t * @return {Object} the DocPad configuration object\n   */\n\n  DocPad.prototype.getConfig = function() {\n    return this.config || {};\n  };\n\n\n  /**\n  \t * Get the port that DocPad is listening on (eg 9778)\n  \t * @method getPort\n  \t * @return {Number} the port number\n   */\n\n  DocPad.prototype.getPort = function() {\n    var ref2, ref3;\n    return (ref2 = (ref3 = this.getConfig().port) != null ? ref3 : require('hostenv').PORT) != null ? ref2 : 9778;\n  };\n\n\n  /**\n  \t * Get the Hostname\n  \t * @method getHostname\n  \t * @return {String}\n   */\n\n  DocPad.prototype.getHostname = function() {\n    var ref2, ref3;\n    return (ref2 = (ref3 = this.getConfig().hostname) != null ? ref3 : require('hostenv').HOSTNAME) != null ? ref2 : '0.0.0.0';\n  };\n\n\n  /**\n  \t * Get address\n  \t * @method getServerUrl\n  \t * @param {Object} [opts={}]\n  \t * @return {String}\n   */\n\n  DocPad.prototype.getServerUrl = function(opts) {\n    var ref2;\n    if (opts == null) {\n      opts = {};\n    }\n    if (opts.hostname == null) {\n      opts.hostname = this.getHostname();\n    }\n    if (opts.port == null) {\n      opts.port = this.getPort();\n    }\n    if (opts.simple == null) {\n      opts.simple = false;\n    }\n    if (opts.simple === true && ((ref2 = opts.hostname) === '0.0.0.0' || ref2 === '::' || ref2 === '::1')) {\n      return \"http://127.0.0.1:\" + opts.port;\n    } else {\n      return \"http://\" + opts.hostname + \":\" + opts.port;\n    }\n  };\n\n\n  /**\n  \t * Get simple server URL (changes 0.0.0.0, ::, and ::1 to 127.0.0.1)\n  \t * @method getSimpleServerUrl\n  \t * @param {Object} [opts={}]\n  \t * @param {Boolean} [opts.simple=true]\n  \t * @return {String}\n   */\n\n  DocPad.prototype.getSimpleServerUrl = function(opts) {\n    if (opts == null) {\n      opts = {};\n    }\n    opts.simple = true;\n    return this.getServerUrl(opts);\n  };\n\n\n  /**\n  \t * Constructor method. Sets up the DocPad instance.\n  \t * next(err)\n  \t * @method constructor\n  \t * @param {Object} instanceConfig\n  \t * @param {Function} next callback\n  \t * @param {Error} next.err\n   */\n\n  function DocPad(instanceConfig, next) {\n    var action, configEventContext, docpad, i, len, logger, loggerConsole, loggers, methodName, ref2, ref3, ref4;\n    ref2 = extractOptsAndCallback(instanceConfig, next), instanceConfig = ref2[0], next = ref2[1];\n    docpad = this;\n    this.TaskGroup = (function(superClass1) {\n      extend(_Class, superClass1);\n\n      function _Class() {\n        var tasks;\n        _Class.__super__.constructor.apply(this, arguments);\n        tasks = this;\n        tasks.on('started', function() {\n          var config, name, progress, totals;\n          config = tasks.getConfig();\n          name = tasks.getNames();\n          progress = config.progress;\n          if (progress) {\n            totals = tasks.getItemTotals();\n            return progress.step(name).total(totals.total).setTick(totals.completed);\n          } else {\n            return docpad.log('debug', name + ' > started');\n          }\n        });\n        tasks.on('item.add', function(item) {\n          var config, name, progress, totals;\n          config = tasks.getConfig();\n          name = item.getNames();\n          progress = config.progress;\n          if (progress) {\n            totals = tasks.getItemTotals();\n            return progress.step(name).total(totals.total).setTick(totals.completed);\n          } else {\n            return docpad.log('debug', name + ' > added');\n          }\n        });\n        tasks.on('item.started', function(item) {\n          var config, name, progress, totals;\n          config = tasks.getConfig();\n          name = item.getNames();\n          progress = config.progress;\n          if (progress) {\n            totals = tasks.getItemTotals();\n            return progress.step(name).total(totals.total).setTick(totals.completed);\n          } else {\n            return docpad.log('debug', name + ' > started');\n          }\n        });\n        tasks.on('item.done', function(item, err) {\n          var config, name, progress, totals;\n          config = tasks.getConfig();\n          name = item.getNames();\n          progress = config.progress;\n          if (progress) {\n            totals = tasks.getItemTotals();\n            return progress.step(name).total(totals.total).setTick(totals.completed);\n          } else {\n            return docpad.log('debug', name + ' > done');\n          }\n        });\n        this;\n      }\n\n      return _Class;\n\n    })(TaskGroup);\n    ref3 = \"action\\nlog warn error fatal inspector notify track identify subscribe checkRequest\\nserverMiddlewareRouter serverMiddlewareHeader serverMiddleware404 serverMiddleware500\\ndestroyWatchers\".split(/\\s+/);\n    for (i = 0, len = ref3.length; i < len; i++) {\n      methodName = ref3[i];\n      this[methodName] = this[methodName].bind(this);\n    }\n    this.setMaxListeners(0);\n    configEventContext = {\n      docpad: docpad\n    };\n    this.getEvents().forEach(function(eventName) {\n      return docpad.on(eventName, function(opts, next) {\n        var args, eventHandler, ref4;\n        eventHandler = (ref4 = docpad.getConfig().events) != null ? ref4[eventName] : void 0;\n        if (typeChecker.isFunction(eventHandler)) {\n          args = [opts, next];\n          return ambi.apply(null, [eventHandler.bind(configEventContext)].concat(slice.call(args)));\n        } else {\n          return next();\n        }\n      });\n    });\n    this.actionRunnerInstance = this.TaskGroup.create('action runner').whenDone(function(err) {\n      if (err) {\n        return docpad.error(err);\n      }\n    });\n    this.trackRunnerInstance = this.TaskGroup.create('track runner').whenDone(function(err) {\n      var locale;\n      if (err && docpad.getDebugging()) {\n        locale = docpad.getLocale();\n        return docpad.warn(locale.trackError, err);\n      }\n    });\n    if ((loggers = instanceConfig.loggers)) {\n      delete instanceConfig.loggers;\n    } else {\n      logger = new (require('caterpillar').Logger)({\n        lineOffset: 2\n      });\n      loggerConsole = logger.pipe(new (require('caterpillar-filter').Filter)).pipe(new (require('caterpillar-human').Human));\n      loggers = {\n        logger: logger,\n        console: loggerConsole\n      };\n    }\n    safefs.unlink(this.debugLogPath, function() {});\n    this.setLoggers(loggers);\n    this.setLogLevel((ref4 = instanceConfig.logLevel) != null ? ref4 : this.initialConfig.logLevel);\n    this.on('log', function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return docpad.log.apply(this, args);\n    });\n    this.slowPlugins = {};\n    this.loadedPlugins = {};\n    this.exchange = {};\n    this.pluginsTemplateData = {};\n    this.instanceConfig = {};\n    this.collections = [];\n    this.blocks = {};\n    this.filesByUrl = {};\n    this.filesBySelector = {};\n    this.filesByOutPath = {};\n    this.database = new FilesCollection(null, {\n      name: 'database'\n    }).on('remove', function(model, options) {\n      var j, len1, outPath, ref5, updatedModels, url;\n      if (model.get('write') === false) {\n        return;\n      }\n      ref5 = model.get('urls') || [];\n      for (j = 0, len1 = ref5.length; j < len1; j++) {\n        url = ref5[j];\n        delete docpad.filesByUrl[url];\n      }\n      outPath = model.get('outPath');\n      if (outPath) {\n        updatedModels = docpad.database.findAll({\n          outPath: outPath\n        });\n        updatedModels.remove(model);\n        updatedModels.each(function(model) {\n          return model.set({\n            'mtime': new Date()\n          });\n        });\n        docpad.log('debug', 'Updated mtime for these models due to remove of a similar one', updatedModels.pluck('relativePath'));\n      }\n      return true;\n    }).on('add change:urls', function(model) {\n      var j, k, len1, len2, ref5, ref6, url;\n      if (model.get('write') === false) {\n        return;\n      }\n      ref5 = model.previous('urls') || [];\n      for (j = 0, len1 = ref5.length; j < len1; j++) {\n        url = ref5[j];\n        delete docpad.filesByUrl[url];\n      }\n      ref6 = model.get('urls');\n      for (k = 0, len2 = ref6.length; k < len2; k++) {\n        url = ref6[k];\n        docpad.filesByUrl[url] = model.cid;\n      }\n      return true;\n    }).on('add change:outPath', function(model) {\n      var base, existingModel, existingModelId, existingModelPath, modelPath, outPath, previousModelId, previousModels, previousOutPath;\n      if (model.get('write') === false) {\n        return;\n      }\n      previousOutPath = model.previous('outPath');\n      if (previousOutPath) {\n        previousModels = docpad.database.findAll({\n          outPath: previousOutPath\n        });\n        previousModels.remove(model);\n        previousModels.each(function(model) {\n          return model.set({\n            'mtime': new Date()\n          });\n        });\n        docpad.log('debug', 'Updated mtime for these models due to addition of a similar one', previousModels.pluck('relativePath'));\n        previousModelId = docpad.filesByOutPath[previousOutPath];\n        if (previousModelId === model.id) {\n          if (previousModels.length) {\n            docpad.filesByOutPath[previousOutPath] = previousModelId;\n          } else {\n            delete docpad.filesByOutPath[previousOutPath];\n          }\n        }\n      }\n      if ((outPath = model.get('outPath'))) {\n        existingModelId = (base = docpad.filesByOutPath)[outPath] != null ? base[outPath] : base[outPath] = model.id;\n        if (existingModelId !== model.id) {\n          existingModel = docpad.database.get(existingModelId);\n          if (existingModel) {\n            modelPath = model.get('fullPath') || (model.get('relativePath') + ':' + model.id);\n            existingModelPath = existingModel.get('fullPath') || (existingModel.get('relativePath') + ':' + existingModel.id);\n            docpad.warn(util.format(docpad.getLocale().outPathConflict, outPath, modelPath, existingModelPath));\n          } else {\n            docpad.filesByOutPath[outPath] = model.id;\n          }\n        }\n      }\n      return true;\n    });\n    this.userConfig = extendr.dereference(this.userConfig);\n    this.initialConfig = extendr.dereference(this.initialConfig);\n    if (instanceConfig.action != null) {\n      action = instanceConfig.action;\n    } else {\n      action = 'load ready';\n    }\n    if (action) {\n      this.action(action, instanceConfig, function(err) {\n        if (next != null) {\n          return next(err, docpad);\n        } else if (err) {\n          return docpad.fatal(err);\n        }\n      });\n    } else {\n      if (typeof next === \"function\") {\n        next(null, docpad);\n      }\n    }\n    this;\n  }\n\n\n  /**\n  \t * Destructor. Destroy the DocPad instance\n  \t * This is an action, and should be called as such\n  \t * E.g. docpad.action('destroy', next)\n  \t * @method destroy\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.destroy = function(opts, next) {\n    var docpad, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    docpad.destroyRegenerateTimer();\n    docpadUtil.wait(1000, function() {\n      return docpad.emitSerial('docpadDestroy', function(err) {\n        if (err) {\n          return typeof next === \"function\" ? next(err) : void 0;\n        }\n        docpad.destroyPlugins();\n        docpad.destroyServer();\n        docpad.destroyWatchers();\n        docpad.destroyBlocks();\n        docpad.destroyCollections();\n        docpad.destroyDatabase();\n        docpad.destroyLoggers();\n        process.removeListener('uncaughtException', docpad.error);\n        docpad.removeAllListeners();\n        return typeof next === \"function\" ? next() : void 0;\n      });\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Emit event, serial\n  \t * @private\n  \t * @method emitSerial\n  \t * @param {String} eventName\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.emitSerial = function(eventName, opts, next) {\n    var docpad, locale, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    locale = docpad.getLocale();\n    docpad.log('debug', util.format(locale.emittingEvent, eventName));\n    DocPad.__super__.emitSerial.call(this, eventName, opts, function(err) {\n      if (err) {\n        return next(err);\n      }\n      docpad.log('debug', util.format(locale.emittedEvent, eventName));\n      return next(err);\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Emit event, parallel\n  \t * @private\n  \t * @method emitParallel\n  \t * @param {String} eventName\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.emitParallel = function(eventName, opts, next) {\n    var docpad, locale, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    locale = docpad.getLocale();\n    docpad.log('debug', util.format(locale.emittingEvent, eventName));\n    DocPad.__super__.emitParallel.call(this, eventName, opts, function(err) {\n      if (err) {\n        return next(err);\n      }\n      docpad.log('debug', util.format(locale.emittedEvent, eventName));\n      return next(err);\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Get the ignore options for the DocPad project\n  \t * @method getIgnoreOpts\n  \t * @return {Array} string array of ignore options\n   */\n\n  DocPad.prototype.getIgnoreOpts = function() {\n    return pick(this.config, ['ignorePaths', 'ignoreHiddenFiles', 'ignoreCommonPatterns', 'ignoreCustomPatterns']);\n  };\n\n\n  /**\n  \t * Is the supplied path ignored?\n  \t * @method isIgnoredPath\n  \t * @param {String} path\n  \t * @param {Object} [opts={}]\n  \t * @return {Boolean}\n   */\n\n  DocPad.prototype.isIgnoredPath = function(path, opts) {\n    if (opts == null) {\n      opts = {};\n    }\n    opts = extendr.extend(this.getIgnoreOpts(), opts);\n    return ignorefs.isIgnoredPath(path, opts);\n  };\n\n\n  /**\n  \t * Scan directory\n  \t * @method scandir\n  \t * @param {Object} [opts={}]\n   */\n\n  DocPad.prototype.scandir = function(opts) {\n    if (opts == null) {\n      opts = {};\n    }\n    opts = extendr.extend(this.getIgnoreOpts(), opts);\n    return scandir(opts);\n  };\n\n\n  /**\n  \t * Watch Directory. Wrapper around the Bevry watchr\n  \t * module (https://github.com/bevry/watchr). Used\n  \t * internally by DocPad to watch project documents\n  \t * and files and then activate the regeneration process\n  \t * when any of those items are updated.\n  \t *\n  \t * Although it is possible to pass a range of options to watchdir\n  \t * in practice these options are provided as part of\n  \t * the DocPad config object with a number of default options\n  \t * specified in the DocPad config.\n  \t * @method watchdir\n  \t * @param {Object} [opts={}]\n  \t * @param {String} [opts.path] a single path to watch.\n  \t * @param {Array} [opts.paths] an array of paths to watch.\n  \t * @param {Function} [opts.listener] a single change listener to fire when a change occurs.\n  \t * @param {Array} [opts.listeners] an array of listeners.\n  \t * @param {Function} [opts.next] callback.\n  \t * @param {Object} [opts.stat] a file stat object to use for the path, instead of fetching a new one.\n  \t * @param {Number} [opts.interval=5007] for systems that poll to detect file changes, how often should it poll in millseconds.\n  \t * @param {Number} [opts.catupDelay=200] handles system swap file deletions and renaming\n  \t * @param {Array} [opts.preferredMethods=['watch','watchFile'] which order should we prefer our watching methods to be tried?.\n  \t * @param {Boolean} [opts.followLinks=true] follow symlinks, i.e. use stat rather than lstat.\n  \t * @param {Boolean|Array} [opts.ignorePaths=false] an array of full paths to ignore.\n  \t * @param {Boolean|Array} [opts.ignoreHiddenFiles=false] whether or not to ignored files which filename starts with a \".\".\n  \t * @param {Boolean} [opts.ignoreCommonPatterns=true] whether or not to ignore common undesirable file patterns (e.g. .svn, .git, .DS_Store, thumbs.db, etc).\n  \t * @param {Boolean|Array} [opts.ignoreCustomPatterns=null] any custom ignore patterns that you would also like to ignore along with the common patterns.\n  \t * @return {Object} the watcher\n   */\n\n  DocPad.prototype.watchdir = function(opts) {\n    if (opts == null) {\n      opts = {};\n    }\n    opts = extendr.extend(this.getIgnoreOpts(), opts, this.config.watchOptions);\n    return require('watchr').watch(opts);\n  };\n\n\n  /**\n  \t * DocPad is ready. Peforms the tasks needed after DocPad construction\n  \t * and DocPad has loaded. Triggers the docpadReady event.\n  \t * next(err,docpadInstance)\n  \t * @private\n  \t * @method ready\n  \t * @param {Object} [opts]\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.docpadInstance\n   */\n\n  DocPad.prototype.ready = function(opts, next) {\n    var config, docpad, instanceConfig, locale, pluginName, pluginsList, ref2, tasks;\n    ref2 = extractOptsAndCallback(instanceConfig, next), instanceConfig = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.getConfig();\n    locale = this.getLocale();\n    this.DocumentModel.prototype.defaults.renderSingleExtensions = config.renderSingleExtensions;\n    this.compareVersion();\n    if (this.getDebugging()) {\n      pluginsList = ((function() {\n        var i, len, ref3, results;\n        ref3 = Object.keys(this.loadedPlugins).sort();\n        results = [];\n        for (i = 0, len = ref3.length; i < len; i++) {\n          pluginName = ref3[i];\n          results.push(pluginName + \" v\" + this.loadedPlugins[pluginName].version);\n        }\n        return results;\n      }).call(this)).join(', ');\n    } else {\n      pluginsList = Object.keys(this.loadedPlugins).sort().join(', ');\n    }\n    docpad.log('info', util.format(locale.welcome, this.getVersionString()));\n    docpad.log('notice', locale.welcomeDonate);\n    docpad.log('info', locale.welcomeContribute);\n    docpad.log('info', util.format(locale.welcomePlugins, pluginsList));\n    docpad.log('info', util.format(locale.welcomeEnvironment, this.getEnvironment()));\n    tasks = new this.TaskGroup('ready tasks', {\n      next: function(err) {\n        if (err) {\n          return docpad.error(err);\n        }\n        return typeof next === \"function\" ? next(null, docpad) : void 0;\n      }\n    });\n    tasks.addTask('welcome event', function(complete) {\n      if (!config.welcome) {\n        return complete();\n      }\n      return docpad.emitSerial('welcome', {\n        docpad: docpad\n      }, complete);\n    });\n    tasks.addTask('track', function(complete) {\n      return docpad.identify(complete);\n    });\n    tasks.addTask('emit docpadReady', function(complete) {\n      return docpad.emitSerial('docpadReady', {\n        docpad: docpad\n      }, complete);\n    });\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Performs the merging of the passed configuration objects\n  \t * @private\n  \t * @method mergeConfigurations\n  \t * @param {Object} configPackages\n  \t * @param {Object} configsToMerge\n   */\n\n  DocPad.prototype.mergeConfigurations = function(configPackages, configsToMerge) {\n    var configPackage, env, envConfig, envs, i, j, len, len1, ref2;\n    envs = this.getEnvironments();\n    for (i = 0, len = configPackages.length; i < len; i++) {\n      configPackage = configPackages[i];\n      if (!configPackage) {\n        continue;\n      }\n      configsToMerge.push(configPackage);\n      for (j = 0, len1 = envs.length; j < len1; j++) {\n        env = envs[j];\n        envConfig = (ref2 = configPackage.environments) != null ? ref2[env] : void 0;\n        if (envConfig) {\n          configsToMerge.push(envConfig);\n        }\n      }\n    }\n    extendr.safeDeepExtendPlainObjects.apply(extendr, configsToMerge);\n    return this;\n  };\n\n\n  /**\n  \t * Set the instance configuration\n  \t * by merging the properties of the passed object\n  \t * with the existing DocPad instanceConfig object\n  \t * @private\n  \t * @method setInstanceConfig\n  \t * @param {Object} instanceConfig\n   */\n\n  DocPad.prototype.setInstanceConfig = function(instanceConfig) {\n    var logLevel;\n    if (instanceConfig) {\n      logLevel = this.getLogLevel();\n      extendr.safeDeepExtendPlainObjects(this.instanceConfig, instanceConfig);\n      if (this.config) {\n        extendr.safeDeepExtendPlainObjects(this.config, instanceConfig);\n      }\n      if (instanceConfig.logLevel && instanceConfig.logLevel !== logLevel) {\n        this.setLogLevel(instanceConfig.logLevel);\n      }\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Set the DocPad configuration object.\n  \t * Performs a number of tasks, including\n  \t * merging the pass instanceConfig with DocPad's\n  \t * other config objects.\n  \t * next(err,config)\n  \t * @private\n  \t * @method setConfig\n  \t * @param {Object} instanceConfig\n  \t * @param {Object} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.config\n   */\n\n  DocPad.prototype.setConfig = function(instanceConfig, next) {\n    var configPackages, configsToMerge, docpad, i, j, k, key, l, len, len1, len2, len3, locale, postTasks, ref2, ref3, ref4, type, typePath, typePaths;\n    ref2 = extractOptsAndCallback(instanceConfig, next), instanceConfig = ref2[0], next = ref2[1];\n    docpad = this;\n    locale = this.getLocale();\n    if (instanceConfig) {\n      this.setInstanceConfig(instanceConfig);\n    }\n    this.config.env = this.instanceConfig.env || this.websiteConfig.env || this.initialConfig.env || process.env.NODE_ENV;\n    configPackages = [this.initialConfig, this.userConfig, this.websiteConfig, this.instanceConfig];\n    configsToMerge = [this.config];\n    docpad.mergeConfigurations(configPackages, configsToMerge);\n    this.setServer(extendr.safeShallowExtendPlainObjects({\n      serverHttp: this.config.serverHttp,\n      serverExpress: this.config.serverExpress\n    }, this.config.server));\n    this.setLogLevel(this.config.logLevel);\n    this.config.rootPath = pathUtil.resolve(this.config.rootPath);\n    this.config.outPath = pathUtil.resolve(this.config.rootPath, this.config.outPath);\n    this.config.srcPath = pathUtil.resolve(this.config.rootPath, this.config.srcPath);\n    this.config.databaseCachePath = pathUtil.resolve(this.config.rootPath, this.config.databaseCachePath);\n    this.config.packagePath = pathUtil.resolve(this.config.rootPath, this.config.packagePath);\n    ref3 = ['documents', 'files', 'layouts'];\n    for (i = 0, len = ref3.length; i < len; i++) {\n      type = ref3[i];\n      typePaths = this.config[type + 'Paths'];\n      for (key = j = 0, len1 = typePaths.length; j < len1; key = ++j) {\n        typePath = typePaths[key];\n        typePaths[key] = pathUtil.resolve(this.config.srcPath, typePath);\n      }\n    }\n    ref4 = ['plugins'];\n    for (k = 0, len2 = ref4.length; k < len2; k++) {\n      type = ref4[k];\n      typePaths = this.config[type + 'Paths'];\n      for (key = l = 0, len3 = typePaths.length; l < len3; key = ++l) {\n        typePath = typePaths[key];\n        typePaths[key] = pathUtil.resolve(this.config.rootPath, typePath);\n      }\n    }\n    process.removeListener('uncaughtException', this.error);\n    this.removeListener('error', this.error);\n    if (this.config.catchExceptions) {\n      process.setMaxListeners(0);\n      process.on('uncaughtException', this.error);\n      this.on('error', this.error);\n    }\n    postTasks = new this.TaskGroup('setConfig post tasks', {\n      next: function(err) {\n        return next(err, docpad.config);\n      }\n\n      /*\n      \t\tpostTasks.addTask 'lazy depedencnies: encoding', (complete) =>\n      \t\t\treturn complete()  unless @config.detectEncoding\n      \t\t\treturn lazyRequire 'encoding', {cwd:corePath, stdio:'inherit'}, (err) ->\n      \t\t\t\tdocpad.warn(locale.encodingLoadFailed)  if err\n      \t\t\t\treturn complete()\n       */\n    });\n    postTasks.addTask('load plugins', function(complete) {\n      return docpad.loadPlugins(complete);\n    });\n    postTasks.addTask('extend collections', function(complete) {\n      return docpad.extendCollections(complete);\n    });\n    postTasks.addTask('fetch plugins templateData', function(complete) {\n      return docpad.emitSerial('extendTemplateData', {\n        templateData: docpad.pluginsTemplateData\n      }, complete);\n    });\n    postTasks.addTask('fire the docpadLoaded event', function(complete) {\n      return docpad.emitSerial('docpadLoaded', complete);\n    });\n    postTasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Load the various configuration files from the\n  \t * file system. Set the instanceConfig.\n  \t * next(err,config)\n  \t * @private\n  \t * @method load\n  \t * @param {Object} instanceConfig\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.config\n   */\n\n  DocPad.prototype.load = function(instanceConfig, next) {\n    var docpad, locale, preTasks, ref2;\n    ref2 = extractOptsAndCallback(instanceConfig, next), instanceConfig = ref2[0], next = ref2[1];\n    docpad = this;\n    locale = this.getLocale();\n    instanceConfig || (instanceConfig = {});\n    this.websitePackageConfig = {};\n    this.websiteConfig = {};\n    this.config = {};\n    this.setInstanceConfig(instanceConfig);\n    preTasks = new this.TaskGroup('load tasks', {\n      next: (function(_this) {\n        return function(err) {\n          if (err) {\n            return next(err);\n          }\n          return _this.setConfig(next);\n        };\n      })(this)\n    });\n    preTasks.addTask('normalize the userConfigPath', (function(_this) {\n      return function(complete) {\n        return safeps.getHomePath(function(err, homePath) {\n          var dropboxPath;\n          if (err) {\n            return complete(err);\n          }\n          dropboxPath = pathUtil.resolve(homePath, 'Dropbox');\n          return safefs.exists(dropboxPath, function(dropboxPathExists) {\n            var userConfigDirPath;\n            userConfigDirPath = dropboxPathExists ? dropboxPath : homePath;\n            _this.userConfigPath = pathUtil.resolve(userConfigDirPath, _this.userConfigPath);\n            return complete();\n          });\n        });\n      };\n    })(this));\n    preTasks.addTask(\"load the user's configuration\", (function(_this) {\n      return function(complete) {\n        var configPath;\n        configPath = _this.userConfigPath;\n        docpad.log('debug', util.format(locale.loadingUserConfig, configPath));\n        return _this.loadConfigPath({\n          configPath: configPath\n        }, function(err, data) {\n          if (err) {\n            return complete(err);\n          }\n          extendr.extend(_this.userConfig, data || {});\n          docpad.log('debug', util.format(locale.loadingUserConfig, configPath));\n          return complete();\n        });\n      };\n    })(this));\n    preTasks.addTask(\"load the anonymous user's configuration\", (function(_this) {\n      return function(complete) {\n        if (_this.userConfig.username) {\n          return complete();\n        }\n        return require('getmac').getMac(function(err, macAddress) {\n          var base, base1, macAddressHash;\n          if (err || !macAddress) {\n            docpad.warn(locale.macError, err);\n            return complete();\n          }\n          try {\n            macAddressHash = require('crypto').createHmac('sha1', docpad.hashKey).update(macAddress).digest('hex');\n          } catch (error) {\n            err = error;\n            if (err) {\n              return complete();\n            }\n          }\n          if (macAddressHash) {\n            if ((base = _this.userConfig).name == null) {\n              base.name = \"MAC \" + macAddressHash;\n            }\n            if ((base1 = _this.userConfig).username == null) {\n              base1.username = macAddressHash;\n            }\n          }\n          return complete();\n        });\n      };\n    })(this));\n    preTasks.addTask(\"load the website's package data\", (function(_this) {\n      return function(complete) {\n        var configPath, rootPath;\n        rootPath = pathUtil.resolve(_this.instanceConfig.rootPath || _this.initialConfig.rootPath);\n        configPath = pathUtil.resolve(rootPath, _this.instanceConfig.packagePath || _this.initialConfig.packagePath);\n        docpad.log('debug', util.format(locale.loadingWebsitePackageConfig, configPath));\n        return _this.loadConfigPath({\n          configPath: configPath\n        }, function(err, data) {\n          if (err) {\n            return complete(err);\n          }\n          data || (data = {});\n          _this.websitePackageConfig = data;\n          docpad.log('debug', util.format(locale.loadedWebsitePackageConfig, configPath));\n          return complete();\n        });\n      };\n    })(this));\n    preTasks.addTask(\"read the .env file if it exists\", (function(_this) {\n      return function(complete) {\n        var configPath, rootPath;\n        rootPath = pathUtil.resolve(_this.instanceConfig.rootPath || _this.websitePackageConfig.rootPath || _this.initialConfig.rootPath);\n        configPath = pathUtil.resolve(rootPath, '.env');\n        docpad.log('debug', util.format(locale.loadingEnvConfig, configPath));\n        return safefs.exists(configPath, function(exists) {\n          if (!exists) {\n            return complete();\n          }\n          return require('envfile').parseFile(configPath, function(err, data) {\n            var key, value;\n            if (err) {\n              return complete(err);\n            }\n            for (key in data) {\n              if (!hasProp.call(data, key)) continue;\n              value = data[key];\n              process.env[key] = value;\n            }\n            docpad.log('debug', util.format(locale.loadingEnvConfig, configPath));\n            return complete();\n          });\n        });\n      };\n    })(this));\n    preTasks.addTask(\"load the website's configuration\", (function(_this) {\n      return function(complete) {\n        var configPath, configPaths, i, index, len, rootPath;\n        docpad.log('debug', util.format(locale.loadingWebsiteConfig));\n        rootPath = pathUtil.resolve(_this.instanceConfig.rootPath || _this.initialConfig.rootPath);\n        configPaths = _this.instanceConfig.configPaths || _this.initialConfig.configPaths;\n        for (index = i = 0, len = configPaths.length; i < len; index = ++i) {\n          configPath = configPaths[index];\n          configPaths[index] = pathUtil.resolve(rootPath, configPath);\n        }\n        return _this.loadConfigPath({\n          configPaths: configPaths\n        }, function(err, data) {\n          if (err) {\n            return complete(err);\n          }\n          data || (data = {});\n          extendr.extend(_this.websiteConfig, data);\n          docpad.log('debug', util.format(locale.loadedWebsiteConfig));\n          return complete();\n        });\n      };\n    })(this));\n    preTasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Update user configuration with the passed data\n  \t * @method updateUserConfig\n  \t * @param {Object} [data={}]\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.updateUserConfig = function(data, next) {\n    var docpad, ref2, userConfigPath;\n    if (data == null) {\n      data = {};\n    }\n    ref2 = extractOptsAndCallback(data, next), data = ref2[0], next = ref2[1];\n    docpad = this;\n    userConfigPath = this.userConfigPath;\n    if (data) {\n      extendr.extend(this.userConfig, data);\n    }\n    CSON.createCSONString(this.userConfig, function(err, userConfigString) {\n      if (err) {\n        err.context = \"Failed to create the CSON string for the user configuration\";\n        return next(err);\n      }\n      return safefs.writeFile(userConfigPath, userConfigString, 'utf8', function(err) {\n        return next(err);\n      });\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Load a configuration url.\n  \t * @method loadConfigUrl\n  \t * @param {String} configUrl\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.parsedData\n   */\n\n  DocPad.prototype.loadConfigUrl = function(configUrl, next) {\n    var docpad, locale;\n    docpad = this;\n    locale = this.getLocale();\n    docpad.log('debug', util.format(locale.loadingConfigUrl, configUrl));\n    superAgent.get(configUrl).timeout(30 * 1000).end(function(err, res) {\n      if (err) {\n        return next(err);\n      }\n      return CSON.parseCSONString(res.text, next);\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Load the configuration from a file path\n  \t * passed as one of the options (opts.configPath) or\n  \t * from DocPad's configPaths\n  \t * @private\n  \t * @method loadConfigPath\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.parsedData\n   */\n\n  DocPad.prototype.loadConfigPath = function(opts, next) {\n    var docpad, load, locale, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    locale = this.getLocale();\n    load = function(configPath) {\n      if (!configPath) {\n        return next();\n      }\n      docpad.log('debug', util.format(locale.loadingConfigPath, configPath));\n      return safefs.exists(configPath, function(exists) {\n        var csonOptions;\n        if (!exists) {\n          return next();\n        }\n        csonOptions = {\n          cson: true,\n          json: true,\n          coffeescript: true,\n          javascript: true\n        };\n        return CSON.requireFile(configPath, csonOptions, function(err, data) {\n          if (err) {\n            err.context = util.format(locale.loadingConfigPathFailed, configPath);\n            return next(err);\n          }\n          while (typeChecker.isFunction(data)) {\n            try {\n              data = data(docpad);\n            } catch (error) {\n              err = error;\n              return next(err);\n            }\n          }\n          if (!typeChecker.isObject(data)) {\n            err = new Error(\"Loading the configuration \" + (docpad.inspector(configPath)) + \" returned an invalid result \" + (docpad.inspector(data)));\n            if (err) {\n              return next(err);\n            }\n          }\n          return next(null, data);\n        });\n      });\n    };\n    if (opts.configPath) {\n      load(opts.configPath);\n    } else {\n      this.getConfigPath(opts, function(err, configPath) {\n        return load(configPath);\n      });\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Get config paths and check that those\n  \t * paths exist\n  \t * @private\n  \t * @method getConfigPath\n  \t * @param {Object} opts\n  \t * @param {Object} next\n  \t * @param {Error} next.err\n  \t * @param {String} next.path\n   */\n\n  DocPad.prototype.getConfigPath = function(opts, next) {\n    var config, docpad, ref2, result, tasks;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.getConfig();\n    result = null;\n    if (opts.configPaths == null) {\n      opts.configPaths = config.configPaths;\n    }\n    if (!typeChecker.isArray(opts.configPaths)) {\n      opts.configPaths = [opts.configPaths];\n    }\n    tasks = new this.TaskGroup('getConfigPath tasks', {\n      next: function(err) {\n        return next(err, result);\n      }\n    });\n    opts.configPaths.forEach(function(configPath) {\n      return tasks.addTask(\"Checking if [\" + configPath + \"] exists\", function(complete) {\n        if (result) {\n          return complete();\n        }\n        return safefs.exists(configPath, function(exists) {\n          if (exists) {\n            result = configPath;\n            tasks.clear();\n            return complete();\n          } else {\n            return complete();\n          }\n        });\n      });\n    });\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Extend collecitons. Create DocPad's\n  \t * standard (documents, files\n  \t * layouts) and special (generate, referencesOthers,\n  \t * hasLayout, html, stylesheet) collections. Set blocks\n  \t * @private\n  \t * @method extendCollections\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.extendCollections = function(next) {\n    var database, docpad, docpadConfig, locale, tasks;\n    docpad = this;\n    docpadConfig = this.getConfig();\n    locale = this.getLocale();\n    database = this.getDatabase();\n    this.setCollections({\n      documents: database.createLiveChildCollection().setQuery('isDocument', {\n        render: true,\n        write: true\n      }).on('add', function(model) {\n        return docpad.log('debug', util.format(locale.addingDocument, model.getFilePath()));\n      }),\n      files: database.createLiveChildCollection().setQuery('isFile', {\n        render: false,\n        write: true\n      }).on('add', function(model) {\n        return docpad.log('debug', util.format(locale.addingFile, model.getFilePath()));\n      }),\n      layouts: database.createLiveChildCollection().setQuery('isLayout', {\n        $or: {\n          isLayout: true,\n          fullPath: {\n            $startsWith: docpadConfig.layoutsPaths\n          }\n        }\n      }).on('add', function(model) {\n        docpad.log('debug', util.format(locale.addingLayout, model.getFilePath()));\n        return model.setDefaults({\n          isLayout: true,\n          render: false,\n          write: false\n        });\n      }),\n      generate: database.createLiveChildCollection().setQuery('generate', {\n        dynamic: false,\n        ignored: false\n      }).on('add', function(model) {\n        return docpad.log('debug', util.format(locale.addingGenerate, model.getFilePath()));\n      }),\n      referencesOthers: database.createLiveChildCollection().setQuery('referencesOthers', {\n        dynamic: false,\n        ignored: false,\n        referencesOthers: true\n      }).on('add', function(model) {\n        return docpad.log('debug', util.format(locale.addingReferencesOthers, model.getFilePath()));\n      }),\n      hasLayout: database.createLiveChildCollection().setQuery('hasLayout', {\n        dynamic: false,\n        ignored: false,\n        layout: {\n          $exists: true\n        }\n      }).on('add', function(model) {\n        return docpad.log('debug', util.format(locale.addingHasLayout, model.getFilePath()));\n      }),\n      html: database.createLiveChildCollection().setQuery('isHTML', {\n        write: true,\n        outExtension: 'html'\n      }).on('add', function(model) {\n        return docpad.log('debug', util.format(locale.addingHtml, model.getFilePath()));\n      }),\n      stylesheet: database.createLiveChildCollection().setQuery('isStylesheet', {\n        write: true,\n        outExtension: 'css'\n      })\n    });\n    this.setBlocks({\n      meta: new MetaCollection(),\n      scripts: new ScriptsCollection(),\n      styles: new StylesCollection()\n    });\n    tasks = new this.TaskGroup(\"extendCollections tasks\", {\n      concurrency: 0,\n      next: function(err) {\n        if (err) {\n          docpad.error(err);\n        }\n        return docpad.emitSerial('extendCollections', next);\n      }\n    });\n    eachr(docpadConfig.collections || {}, function(fn, name) {\n      var err;\n      if (!name || !typeChecker.isString(name)) {\n        err = new Error(\"Inside your DocPad configuration you have a custom collection with an invalid name of: \" + (docpad.inspector(name)));\n        docpad.error(err);\n        return;\n      }\n      if (!fn || !typeChecker.isFunction(fn)) {\n        err = new Error(\"Inside your DocPad configuration you have a custom collection called \" + (docpad.inspector(name)) + \" with an invalid method of: \" + (docpad.inspector(fn)));\n        docpad.error(err);\n        return;\n      }\n      return tasks.addTask(\"creating the custom collection: \" + name, function(complete) {\n        return ambi([fn.bind(docpad), fn], database, function(err, collection) {\n          if (err) {\n            docpad.error(err);\n            return complete();\n          } else if (!(collection instanceof QueryCollection)) {\n            docpad.warn(util.format(locale.errorInvalidCollection, name));\n            return complete();\n          }\n          if (collection) {\n            collection.live(true);\n          }\n          docpad.setCollection(name, collection);\n          return complete();\n        });\n      });\n    });\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Reset collections. Perform a complete clean of our collections\n  \t * @private\n  \t * @method resetCollections\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.resetCollections = function(opts, next) {\n    var database, docpad, meta, ref2, scripts, styles;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    database = docpad.getDatabase();\n    docpad.generated = false;\n    database.reset([]);\n    meta = this.getBlock('meta').reset([]);\n    scripts = this.getBlock('scripts').reset([]);\n    styles = this.getBlock('styles').reset([]);\n    if (docpad.getConfig().poweredByDocPad !== false) {\n      meta.add(\"<meta name=\\\"generator\\\" content=\\\"DocPad v\" + (docpad.getVersion()) + \"\\\" />\");\n    }\n    this.filesByUrl = {};\n    this.filesBySelector = {};\n    this.filesByOutPath = {};\n    next();\n    return this;\n  };\n\n\n  /**\n  \t * Initialise git repo\n  \t * @private\n  \t * @method initGitRepo\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.results\n   */\n\n  DocPad.prototype.initGitRepo = function(opts, next) {\n    var config, docpad, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.getConfig();\n    if (opts.cwd == null) {\n      opts.cwd = config.rootPath;\n    }\n    if (opts.output == null) {\n      opts.output = this.getDebugging();\n    }\n    safeps.initGitRepo(opts, next);\n    return this;\n  };\n\n\n  /**\n  \t * Init node modules\n  \t * @private\n  \t * @method initNodeModules\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.results\n   */\n\n  DocPad.prototype.initNodeModules = function(opts, next) {\n    var config, docpad, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.getConfig();\n    if (opts.cwd == null) {\n      opts.cwd = config.rootPath;\n    }\n    if (opts.output == null) {\n      opts.output = docpad.getDebugging();\n    }\n    if (opts.force == null) {\n      opts.force = config.offline ? false : true;\n    }\n    if (opts.args == null) {\n      opts.args = [];\n    }\n    if (config.force) {\n      opts.args.push('--force');\n    }\n    if (config.offline) {\n      opts.args.push('--no-registry');\n    }\n    if (opts.output) {\n      docpad.log('info', 'npm install');\n    }\n    safeps.initNodeModules(opts, next);\n    return this;\n  };\n\n\n  /**\n  \t * Fix node package versions\n  \t * Combat to https://github.com/npm/npm/issues/4587#issuecomment-35370453\n  \t * @private\n  \t * @method fixNodePackageVersions\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.fixNodePackageVersions = function(opts, next) {\n    var config, docpad, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.getConfig();\n    if (opts.packagePath == null) {\n      opts.packagePath = config.packagePath;\n    }\n    safefs.readFile(opts.packagePath, function(err, buffer) {\n      var data;\n      data = buffer.toString();\n      data = data.replace(/(\"docpad(?:.*?)\": \")\\^/g, '$1~');\n      return safefs.writeFile(opts.packagePath, data, function(err) {\n        return next(err);\n      });\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Install node module. Same as running\n  \t * 'npm install' through the command line\n  \t * @private\n  \t * @method installNodeModule\n  \t * @param {Array} names\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.result\n   */\n\n  DocPad.prototype.installNodeModule = function(names, opts, next) {\n    var command, config, docpad, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.getConfig();\n    if (opts.cwd == null) {\n      opts.cwd = config.rootPath;\n    }\n    if (opts.args == null) {\n      opts.args = [];\n    }\n    if (docpad.getDebugging()) {\n      if (opts.stdio == null) {\n        opts.stdio = 'inherit';\n      }\n    }\n    if (opts.global == null) {\n      opts.global = false;\n    }\n    if (opts.global === true) {\n      opts.global = ['--global'];\n    }\n    if (opts.global && Array.isArray(opts.global) === false) {\n      opts.global = [opts.global];\n    }\n    if (opts.save == null) {\n      opts.save = !opts.global;\n    }\n    if (opts.save === true) {\n      opts.save = ['--save'];\n    }\n    if (opts.save && Array.isArray(opts.save) === false) {\n      opts.save = [opts.save];\n    }\n    command = ['npm', 'install'];\n    if (!typeChecker.isArray(names)) {\n      names = names.split(/[,\\s]+/);\n    }\n    names.forEach(function(name) {\n      if (!name) {\n        return;\n      }\n      if (name.indexOf('@') === -1) {\n        name += '@latest';\n      }\n      return command.push(name);\n    });\n    command.push.apply(command, opts.args);\n    if (config.force) {\n      command.push('--force');\n    }\n    if (config.offline) {\n      command.push('--no-registry');\n    }\n    if (opts.save) {\n      command.push.apply(command, opts.save);\n    }\n    if (opts.global) {\n      command.push.apply(command, opts.global);\n    }\n    if (opts.output) {\n      docpad.log('info', command.join(' '));\n    }\n    safeps.spawn(command, opts, next);\n    return this;\n  };\n\n\n  /**\n  \t * Uninstall node module. Same as running\n  \t * 'npm uninstall' through the command line\n  \t * @private\n  \t * @method uninstallNodeModule\n  \t * @param {Array} names\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.result\n   */\n\n  DocPad.prototype.uninstallNodeModule = function(names, opts, next) {\n    var command, config, docpad, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.getConfig();\n    if (opts.cwd == null) {\n      opts.cwd = config.rootPath;\n    }\n    if (opts.output == null) {\n      opts.output = docpad.getDebugging();\n    }\n    if (opts.args == null) {\n      opts.args = [];\n    }\n    if (opts.global == null) {\n      opts.global = false;\n    }\n    if (opts.global === true) {\n      opts.global = ['--global'];\n    }\n    if (opts.global && Array.isArray(opts.global) === false) {\n      opts.global = [opts.global];\n    }\n    if (opts.save == null) {\n      opts.save = !opts.global;\n    }\n    if (opts.save === true) {\n      opts.save = ['--save', '--save-dev'];\n    }\n    if (opts.save && Array.isArray(opts.save) === false) {\n      opts.save = [opts.save];\n    }\n    command = ['npm', 'uninstall'];\n    if (!typeChecker.isArray(names)) {\n      names = names.split(/[,\\s]+/);\n    }\n    command.push.apply(command, names);\n    command.push.apply(command, opts.args);\n    if (opts.save) {\n      command.push.apply(command, opts.save);\n    }\n    if (opts.global) {\n      command.push.apply(command, opts.global);\n    }\n    if (opts.output) {\n      docpad.log('info', command.join(' '));\n    }\n    safeps.spawn(command, opts, next);\n    return this;\n  };\n\n\n  /**\n  \t * Set the log level\n  \t * @private\n  \t * @method setLogLevel\n  \t * @param {Number} level\n   */\n\n  DocPad.prototype.setLogLevel = function(level) {\n    var loggers;\n    this.getLogger().setConfig({\n      level: level\n    });\n    if (level === 7) {\n      loggers = this.getLoggers();\n      if ((loggers.debug != null) === false) {\n        loggers.debug = loggers.logger.pipe(new (require('caterpillar-human').Human)({\n          color: false\n        })).pipe(require('fs').createWriteStream(this.debugLogPath));\n      }\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Get the log level\n  \t * @method getLogLevel\n  \t * @return {Number} the log level\n   */\n\n  DocPad.prototype.getLogLevel = function() {\n    return this.getConfig().logLevel;\n  };\n\n\n  /**\n  \t * Are we debugging?\n  \t * @method getDebugging\n  \t * @return {Boolean}\n   */\n\n  DocPad.prototype.getDebugging = function() {\n    return this.getLogLevel() === 7;\n  };\n\n\n  /**\n  \t * Handle a fatal error\n  \t * @private\n  \t * @method fatal\n  \t * @param {Object} err\n   */\n\n  DocPad.prototype.fatal = function(err) {\n    var config, docpad;\n    docpad = this;\n    config = this.getConfig();\n    if (!err) {\n      return this;\n    }\n    this.error(err);\n    docpadUtil.writeError(err);\n    this.destroy();\n    return this;\n  };\n\n\n  /**\n  \t * Inspect. Converts object to JSON string. Wrapper around nodes util.inspect method.\n  \t * Can't use the inspect namespace as for some silly reason it destroys everything\n  \t * @method inspector\n  \t * @param {Object} obj\n  \t * @param {Object} opts\n  \t * @return {String} JSON string of passed object\n   */\n\n  DocPad.prototype.inspector = function(obj, opts) {\n    if (opts == null) {\n      opts = {};\n    }\n    if (opts.colors == null) {\n      opts.colors = this.getConfig().color;\n    }\n    return docpadUtil.inspect(obj, opts);\n  };\n\n\n  /**\n  \t * Log arguments\n  \t * @property {Object} log\n  \t * @param {Mixed} args...\n   */\n\n  DocPad.prototype.log = function() {\n    var args, logger;\n    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    logger = this.getLogger() || console;\n    logger.log.apply(logger, args);\n    return this;\n  };\n\n\n  /**\n  \t * Create an error object\n  \t * @method createError\n  \t * @param {Object} err\n  \t * @param {Object} opts\n  \t * @return {Object} the error\n   */\n\n  DocPad.prototype.createError = function(err, opts) {\n    var key, ref2, ref3, ref4, ref5, ref6, ref7, ref8, value;\n    if (opts == null) {\n      opts = {};\n    }\n    if (opts.level == null) {\n      opts.level = (ref2 = err.level) != null ? ref2 : 'error';\n    }\n    if (opts.track == null) {\n      opts.track = (ref3 = err.track) != null ? ref3 : true;\n    }\n    if (opts.tracked == null) {\n      opts.tracked = (ref4 = err.tracked) != null ? ref4 : false;\n    }\n    if (opts.log == null) {\n      opts.log = (ref5 = err.log) != null ? ref5 : true;\n    }\n    if (opts.logged == null) {\n      opts.logged = (ref6 = err.logged) != null ? ref6 : false;\n    }\n    if (opts.notify == null) {\n      opts.notify = (ref7 = err.notify) != null ? ref7 : true;\n    }\n    if (opts.notified == null) {\n      opts.notified = (ref8 = err.notified) != null ? ref8 : false;\n    }\n    if (err.context != null) {\n      if (opts.context == null) {\n        opts.context = err.context;\n      }\n    }\n    if (!err.stack) {\n      err = new Error(err);\n    }\n    for (key in opts) {\n      if (!hasProp.call(opts, key)) continue;\n      value = opts[key];\n      if (err[key] == null) {\n        err[key] = value;\n      }\n    }\n    return err;\n  };\n\n\n  /**\n  \t * Create an error (tracks it) and log it\n  \t * @method error\n  \t * @param {Object} err\n  \t * @param {Object} [level='err']\n   */\n\n  DocPad.prototype.error = function(err, level) {\n    var docpad;\n    if (level == null) {\n      level = 'err';\n    }\n    docpad = this;\n    err = this.createError(err, {\n      level: level\n    });\n    this.trackError(err);\n    this.logError(err);\n    this.notifyError(err);\n    return this;\n  };\n\n\n  /**\n  \t * Log an error\n  \t * @method logError\n  \t * @param {Object} err\n   */\n\n  DocPad.prototype.logError = function(err) {\n    var docpad, locale, message, occured, ref2;\n    docpad = this;\n    locale = this.getLocale();\n    if (err && err.log !== false && err.logged !== true) {\n      err = this.createError(err, {\n        logged: true\n      });\n      occured = (ref2 = err.level) === 'warn' || ref2 === 'warning' ? locale.warnOccured : locale.errorOccured;\n      message = err.context ? err.context + locale.errorFollows : occured;\n      message += '\\n\\n' + err.stack.toString().trim();\n      message += '\\n\\n' + locale.errorSubmission;\n      docpad.log(err.level, message);\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Track an error in the background\n  \t * @private\n  \t * @method trackError\n  \t * @param {Object} err\n   */\n\n  DocPad.prototype.trackError = function(err) {\n    var config, data, docpad;\n    docpad = this;\n    config = this.getConfig();\n    if (err && err.track !== false && err.tracked !== true && config.offline === false && config.reportErrors === true) {\n      err = this.createError(err, {\n        tracked: true\n      });\n      data = {};\n      data.message = err.message;\n      if (err.stack) {\n        data.stack = err.stack.toString().trim();\n      }\n      data.config = config;\n      data.env = process.env;\n      docpad.track('error', data);\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Notify error\n  \t * @private\n  \t * @method notifyError\n  \t * @param {Object} err\n   */\n\n  DocPad.prototype.notifyError = function(err) {\n    var docpad, locale, occured, ref2;\n    docpad = this;\n    locale = this.getLocale();\n    if (err.notify !== false && err.notified !== true) {\n      err.notified = true;\n      occured = (ref2 = err.level) === 'warn' || ref2 === 'warning' ? locale.warnOccured : locale.errorOccured;\n      docpad.notify(err.message, {\n        title: occured\n      });\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Log an error of level 'warn'\n  \t * @method warn\n  \t * @param {String} message\n  \t * @param {Object} err\n  \t * @return {Object} description\n   */\n\n  DocPad.prototype.warn = function(message, err) {\n    if (err) {\n      err.context = message;\n      err.level = 'warn';\n      this.error(err);\n    } else {\n      err = message instanceof Error ? message : new Error(message);\n      err.level = 'warn';\n      this.error(err);\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Send a notify event to plugins (like growl)\n  \t * @method notify\n  \t * @param {String} message\n  \t * @param {Object} [opts={}]\n   */\n\n  DocPad.prototype.notify = function(message, opts) {\n    var docpad;\n    if (opts == null) {\n      opts = {};\n    }\n    docpad = this;\n    docpad.emitSerial('notify', {\n      message: message,\n      opts: opts\n    }, function(err) {\n      if (err) {\n        return docpad.error(err);\n      }\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Check Request\n  \t * @private\n  \t * @method checkRequest\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.res\n   */\n\n  DocPad.prototype.checkRequest = function(next) {\n    if (next == null) {\n      next = this.error.bind(this);\n    }\n    return function(err, res) {\n      var ref2, ref3;\n      if (err) {\n        return next(err, res);\n      }\n      if (((ref2 = res.body) != null ? ref2.success : void 0) === false || ((ref3 = res.body) != null ? ref3.error : void 0)) {\n        err = new Error(res.body.error || 'unknown request error');\n        return next(err, res);\n      }\n      return next(null, res);\n    };\n  };\n\n\n  /**\n  \t * Subscribe to the DocPad email list.\n  \t * @private\n  \t * @method subscribe\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.subscribe = function(next) {\n    var config, data, err, ref2;\n    config = this.getConfig();\n    if (config.offline === false) {\n      if ((ref2 = this.userConfig) != null ? ref2.email : void 0) {\n        data = {};\n        data.email = this.userConfig.email;\n        data.name = this.userConfig.name || null;\n        data.username = this.userConfig.username || null;\n        superAgent.post(config.helperUrl).type('json').set('Accept', 'application/json').query({\n          method: 'add-subscriber'\n        }).send(data).timeout(30 * 1000).end(this.checkRequest(next));\n      } else {\n        err = new Error('Email not provided');\n        if (typeof next === \"function\") {\n          next(err);\n        }\n      }\n    } else {\n      if (typeof next === \"function\") {\n        next();\n      }\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Track\n  \t * @private\n  \t * @method track\n  \t * @param {String} name\n  \t * @param {Object} [things={}]\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.track = function(name, things, next) {\n    var config, data, docpad, ref2, trackRunner;\n    if (things == null) {\n      things = {};\n    }\n    docpad = this;\n    config = this.getConfig();\n    if (config.offline === false && config.reportStatistics) {\n      data = {};\n      data.userId = this.userConfig.username || null;\n      data.event = name;\n      data.properties = things;\n      if ((ref2 = this.websitePackageConfig) != null ? ref2.name : void 0) {\n        things.websiteName = this.websitePackageConfig.name;\n      }\n      things.platform = this.getProcessPlatform();\n      things.environment = this.getEnvironment();\n      things.version = this.getVersion();\n      things.nodeVersion = this.getProcessVersion();\n      eachr(docpad.loadedPlugins, function(value, key) {\n        return things['plugin-' + key] = value.version || true;\n      });\n      trackRunner = docpad.getTrackRunner();\n      trackRunner.addTask('track task', function(complete) {\n        return superAgent.post(config.helperUrl).type('json').set('Accept', 'application/json').query({\n          method: 'analytics',\n          action: 'track'\n        }).send(data).timeout(30 * 1000).end(docpad.checkRequest(function(err) {\n          if (typeof next === \"function\") {\n            next(err);\n          }\n          return complete(err);\n        }));\n      });\n      trackRunner.run();\n    } else {\n      if (typeof next === \"function\") {\n        next();\n      }\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Identify DocPad user\n  \t * @private\n  \t * @method identify\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.identify = function(next) {\n    var config, data, docpad, now, ref2, things;\n    docpad = this;\n    config = this.getConfig();\n    if (config.offline === false && config.reportStatistics && ((ref2 = this.userConfig) != null ? ref2.username : void 0)) {\n      data = {};\n      data.userId = this.userConfig.username;\n      data.traits = things = {};\n      now = new Date();\n      things.username = this.userConfig.username;\n      things.email = this.userConfig.email || null;\n      things.name = this.userConfig.name || null;\n      things.lastLogin = now.toISOString();\n      things.lastSeen = now.toISOString();\n      things.countryCode = safeps.getCountryCode();\n      things.languageCode = safeps.getLanguageCode();\n      things.platform = this.getProcessPlatform();\n      things.version = this.getVersion();\n      things.nodeVersion = this.getProcessVersion();\n      if (docpad.userConfig.identified !== true) {\n        things.created = now.toISOString();\n        docpad.getTrackRunner().addTask('create new user', function(complete) {\n          return superAgent.post(config.helperUrl).type('json').set('Accept', 'application/json').query({\n            method: 'analytics',\n            action: 'identify'\n          }).send(data).timeout(30 * 1000).end(docpad.checkRequest(function(err) {\n            return docpad.updateUserConfig({\n              identified: true\n            }, complete);\n          }));\n        });\n      } else {\n        docpad.getTrackRunner().addTask('update user', function(complete) {\n          return superAgent.post(config.helperUrl).type('json').set('Accept', 'application/json').query({\n            method: 'analytics',\n            action: 'identify'\n          }).send(data).timeout(30 * 1000).end(docpad.checkRequest(complete));\n        });\n      }\n    }\n    if (typeof next === \"function\") {\n      next();\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Create file model. Calls\n  \t * {{#crossLink \"DocPad/createModel:method\"}}{{/crossLink}}\n  \t * with the 'file' modelType.\n  \t * @method createFile\n  \t * @param {Object} [attrs={}]\n  \t * @param {Object} [opts={}]\n  \t * @return {Object} FileModel\n   */\n\n  DocPad.prototype.createFile = function(attrs, opts) {\n    if (attrs == null) {\n      attrs = {};\n    }\n    if (opts == null) {\n      opts = {};\n    }\n    opts.modelType = 'file';\n    return this.createModel(attrs, opts);\n  };\n\n\n  /**\n  \t * Create document model. Calls\n  \t * {{#crossLink \"DocPad/createModel:method\"}}{{/crossLink}}\n  \t * with the 'document' modelType.\n  \t * @method createDocument\n  \t * @param {Object} [attrs={}]\n  \t * @param {Object} [opts={}]\n  \t * @return {Object} DocumentModel\n   */\n\n  DocPad.prototype.createDocument = function(attrs, opts) {\n    if (attrs == null) {\n      attrs = {};\n    }\n    if (opts == null) {\n      opts = {};\n    }\n    opts.modelType = 'document';\n    return this.createModel(attrs, opts);\n  };\n\n\n  /**\n  \t * Parse the files directory and\n  \t * return a files collection to\n  \t * the passed callback\n  \t * @method parseFileDirectory\n  \t * @param {Object} [opts={}]\n  \t * @param {Function} next callback\n  \t * @param {Error} next.err\n  \t * @param {Object} next.files files collection\n   */\n\n  DocPad.prototype.parseFileDirectory = function(opts, next) {\n    if (opts == null) {\n      opts = {};\n    }\n    if (opts.modelType == null) {\n      opts.modelType = 'file';\n    }\n    if (opts.collection == null) {\n      opts.collection = this.getDatabase();\n    }\n    return this.parseDirectory(opts, next);\n  };\n\n\n  /**\n  \t * Parse the documents directory and\n  \t * return a documents collection to\n  \t * the passed callback.\n  \t *\n  \t * The partials plugin (https://github.com/docpad/docpad-plugin-partials)\n  \t * uses this method to load a collection of\n  \t * files from the partials directory.\n  \t *\n  \t * \tdocpad.parseDocumentDirectory({path: config.partialsPath}, next)\n  \t *\n  \t * @method parseDocumentDirectory\n  \t * @param {Object} [opts={}]\n  \t * @param {String} [opts.modelType='document']\n  \t * @param {Object} [opts.collection=docpad.database]\n  \t * @param {Object} [opts.path]\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.files files collection of documents\n   */\n\n  DocPad.prototype.parseDocumentDirectory = function(opts, next) {\n    if (opts == null) {\n      opts = {};\n    }\n    if (opts.modelType == null) {\n      opts.modelType = 'document';\n    }\n    if (opts.collection == null) {\n      opts.collection = this.getDatabase();\n    }\n    return this.parseDirectory(opts, next);\n  };\n\n\n  /**\n  \t * Attach events to a document model.\n  \t * @private\n  \t * @method attachModelEvents\n  \t * @param {Object} model\n   */\n\n  DocPad.prototype.attachModelEvents = function(model) {\n    var docpad;\n    docpad = this;\n    if (model.attachedDocumentEvents !== true) {\n      model.attachedDocumentEvents = true;\n      if (model.type === 'document') {\n        model.on('clone', function(clonedModel) {\n          return docpad.attachModelEvents(clonedModel);\n        });\n        model.on('render', function() {\n          var args;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return docpad.emitSerial.apply(docpad, ['render'].concat(slice.call(args)));\n        });\n        model.on('renderDocument', function() {\n          var args;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return docpad.emitSerial.apply(docpad, ['renderDocument'].concat(slice.call(args)));\n        });\n        model.on('getLayout', function(opts, next) {\n          var layout;\n          if (opts == null) {\n            opts = {};\n          }\n          opts.collection = docpad.getCollection('layouts');\n          layout = docpad.getFileBySelector(opts.selector, opts);\n          return next(null, {\n            layout: layout\n          });\n        });\n      }\n      model.on('error', function() {\n        var args;\n        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        return docpad.error.apply(docpad, args);\n      });\n      model.on('log', function() {\n        var args, ref2, ref3;\n        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        if (args.length === 2) {\n          if ((ref2 = args[0]) === 'err' || ref2 === 'error') {\n            docpad.error(args[1]);\n            return;\n          }\n          if ((ref3 = args[0]) === 'warn' || ref3 === 'warning') {\n            docpad.warn(args[1]);\n            return;\n          }\n        }\n        return docpad.log.apply(docpad, args);\n      });\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Add supplied model to the DocPad database. If the passed\n  \t * model definition is a plain object of properties, a new\n  \t * model will be created prior to adding to the database.\n  \t * Calls {{#crossLink \"DocPad/createModel:method\"}}{{/crossLink}}\n  \t * before adding the model to the database.\n  \t *\n  \t *\t# Override the stat's mtime to now\n  \t *\t# This is because renames will not update the mtime\n  \t *\tfileCurrentStat?.mtime = new Date()\n  \t *\n  \t *\t# Create the file object\n  \t *\tfile = docpad.addModel({fullPath:filePath, stat:fileCurrentStat})\n  \t *\n  \t * @method addModel\n  \t * @param {Object} model either a plain object defining the required properties, in particular\n  \t * the file path or an actual model object\n  \t * @param {Object} opts\n  \t * @return {Object} the model\n   */\n\n  DocPad.prototype.addModel = function(model, opts) {\n    model = this.createModel(model, opts);\n    this.getDatabase().add(model);\n    return model;\n  };\n\n\n  /**\n  \t * Add the supplied collection of models to the DocPad database.\n  \t * Calls {{#crossLink \"DocPad/createModels:method\"}}{{/crossLink}}\n  \t * before adding the models to the database.\n  \t *\n  \t * \tdatabaseData = JSON.parse data.toString()\n  \t *\tmodels = docpad.addModels(databaseData.models)\n  \t *\n  \t * @method addModels\n  \t * @param {Object} models DocPad collection of models\n  \t * @param {Object} opts\n  \t * @return {Object} the models\n   */\n\n  DocPad.prototype.addModels = function(models, opts) {\n    models = this.createModels(models, opts);\n    this.getDatabase().add(models);\n    return models;\n  };\n\n\n  /**\n  \t * Create a collection of models from the supplied collection\n  \t * ensuring that the collection is suitable for adding to the\n  \t * DocPad database. The method calls {{#crossLink \"DocPad/createModel\"}}{{/crossLink}}\n  \t * for each model in the models array.\n  \t * @private\n  \t * @method createModels\n  \t * @param {Object} models DocPad collection of models\n  \t * @param {Object} opts\n  \t * @return {Object} the models\n   */\n\n  DocPad.prototype.createModels = function(models, opts) {\n    var i, len, model, results;\n    results = [];\n    for (i = 0, len = models.length; i < len; i++) {\n      model = models[i];\n      results.push(this.createModel(model, opts));\n    }\n    return results;\n  };\n\n\n  /**\n  \t * Creates either a file or document model.\n  \t * The model type to be created can be passed\n  \t * as an opts property, if not, the method will\n  \t * attempt to determing the model type by checking\n  \t * if the file is in one of the documents or\n  \t * layout paths.\n  \t *\n  \t * Ensures a duplicate model is not created\n  \t * and all required attributes are present and\n  \t * events attached.\n  \t *\n  \t * Generally it is not necessary for an application\n  \t * to manually create a model via creatModel as DocPad\n  \t * will handle this process when watching a project's\n  \t * file and document directories. However, it is possible\n  \t * that a plugin might have a requirement to do so.\n  \t *\n  \t * \tmodel = @docpad.createModel({fullPath:fullPath})\n      *   model.load()\n      *   @docpad.getDatabase().add(model)\n  \t *\n  \t * @method createModel\n  \t * @param {Object} [attrs={}]\n  \t * @param {String} attrs.fullPath the full path to the file\n  \t * @param {Object} [opts={}]\n  \t * @param {String} opts.modelType either 'file' or 'document'\n  \t * @return {Object} the file or document model\n   */\n\n  DocPad.prototype.createModel = function(attrs, opts) {\n    var config, database, dirPath, docpad, fileFullPath, i, j, len, len1, model, ref2, ref3, result;\n    if (attrs == null) {\n      attrs = {};\n    }\n    if (opts == null) {\n      opts = {};\n    }\n    if (attrs instanceof FileModel) {\n      return attrs;\n    }\n    docpad = this;\n    config = this.getConfig();\n    database = this.getDatabase();\n    fileFullPath = attrs.fullPath || null;\n    if (attrs.fullPath) {\n      result = database.findOne({\n        fullPath: attrs.fullPath\n      });\n      if (result) {\n        return result;\n      }\n    }\n    if (fileFullPath) {\n      if (!opts.modelType) {\n        ref2 = config.documentsPaths.concat(config.layoutsPaths);\n        for (i = 0, len = ref2.length; i < len; i++) {\n          dirPath = ref2[i];\n          if (fileFullPath.indexOf(dirPath) === 0) {\n            attrs.relativePath || (attrs.relativePath = fileFullPath.replace(dirPath, '').replace(/^[\\/\\\\]/, ''));\n            opts.modelType = 'document';\n            break;\n          }\n        }\n      }\n      if (!opts.modelType) {\n        ref3 = config.filesPaths;\n        for (j = 0, len1 = ref3.length; j < len1; j++) {\n          dirPath = ref3[j];\n          if (fileFullPath.indexOf(dirPath) === 0) {\n            attrs.relativePath || (attrs.relativePath = fileFullPath.replace(dirPath, '').replace(/^[\\/\\\\]/, ''));\n            opts.modelType = 'file';\n            break;\n          }\n        }\n      }\n    }\n    opts = extendr.extend({\n      detectEncoding: config.detectEncoding,\n      rootOutDirPath: config.outPath,\n      locale: this.getLocale(),\n      TaskGroup: this.TaskGroup\n    }, opts);\n    if (opts.modelType === 'file') {\n      model = new FileModel(attrs, opts);\n    } else {\n      model = new DocumentModel(attrs, opts);\n    }\n    this.attachModelEvents(model);\n    return model;\n  };\n\n\n  /**\n  \t * Parse a directory and return a\n  \t * files collection\n  \t * @method parseDirectory\n  \t * @param {Object} [opts={}]\n  \t * @param {Object} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.files files collection\n   */\n\n  DocPad.prototype.parseDirectory = function(opts, next) {\n    var createFunction, docpad, files, locale, path, ref2;\n    if (opts == null) {\n      opts = {};\n    }\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    locale = this.getLocale();\n    path = opts.path, createFunction = opts.createFunction;\n    if (createFunction == null) {\n      createFunction = this.createModel;\n    }\n    files = opts.collection || new FilesCollection();\n    safefs.exists(path, function(exists) {\n      if (!exists) {\n        docpad.log('debug', util.format(locale.renderDirectoryNonexistant, path));\n        return next();\n      }\n      docpad.log('debug', util.format(locale.renderDirectoryParsing, path));\n      return docpad.scandir({\n        path: path,\n        fileAction: function(fileFullPath, fileRelativePath, nextFile, fileStat) {\n          var data, file;\n          data = {\n            fullPath: fileFullPath,\n            relativePath: fileRelativePath,\n            stat: fileStat\n          };\n          file = createFunction.call(docpad, data, opts);\n          return file.action('load', function(err) {\n            if (err) {\n              return nextFile(err);\n            }\n            files.add(file);\n            return nextFile();\n          });\n        },\n        next: function(err) {\n          if (err) {\n            return next(err);\n          }\n          docpad.log('debug', util.format(locale.renderDirectoryParsed, path));\n          return next(null, files);\n        }\n      });\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Get a plugin by it's name\n  \t * @method getPlugin\n  \t * @param {Object} pluginName\n  \t * @return {Object} a DocPad plugin\n   */\n\n  DocPad.prototype.getPlugin = function(pluginName) {\n    return this.loadedPlugins[pluginName];\n  };\n\n\n  /**\n  \t * Check if we have any plugins\n  \t * @method hasPlugins\n  \t * @return {Boolean}\n   */\n\n  DocPad.prototype.hasPlugins = function() {\n    return typeChecker.isEmptyObject(this.loadedPlugins) === false;\n  };\n\n\n  /**\n  \t * Destructor. Destroy plugins\n  \t * @private\n  \t * @method destroyPlugins\n   */\n\n  DocPad.prototype.destroyPlugins = function() {\n    var name, plugin, ref2;\n    ref2 = this.loadedPlugins;\n    for (name in ref2) {\n      if (!hasProp.call(ref2, name)) continue;\n      plugin = ref2[name];\n      plugin.destroy();\n      this.loadedPlugins[name] = null;\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Load plugins from the file system\n  \t * next(err)\n  \t * @private\n  \t * @method loadPlugins\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.loadPlugins = function(next) {\n    var docpad, locale, snore, tasks;\n    docpad = this;\n    locale = this.getLocale();\n    this.slowPlugins = {};\n    snore = balUtil.createSnore(function() {\n      return docpad.log('notice', util.format(locale.pluginsSlow, Object.keys(docpad.slowPlugins).join(', ')));\n    });\n    tasks = new this.TaskGroup(\"loadPlugins tasks\", {\n      concurrency: 0,\n      next: function(err) {\n        docpad.slowPlugins = {};\n        snore.clear();\n        return next(err);\n      }\n    });\n    (this.config.pluginsPaths || []).forEach(function(pluginsPath) {\n      return tasks.addTask(\"load the website's plugins at: \" + pluginsPath, function(complete) {\n        return safefs.exists(pluginsPath, function(exists) {\n          if (!exists) {\n            return complete();\n          }\n          return docpad.loadPluginsIn(pluginsPath, complete);\n        });\n      });\n    });\n    (this.config.pluginPaths || []).forEach(function(pluginPath) {\n      return tasks.addTask(\"load custom plugins at: \" + pluginPath, function(complete) {\n        return safefs.exists(pluginPath, function(exists) {\n          if (!exists) {\n            return complete();\n          }\n          return docpad.loadPlugin(pluginPath, complete);\n        });\n      });\n    });\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Checks if a plugin was loaded succesfully.\n  \t * @method loadedPlugin\n  \t * @param {String} pluginName\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Boolean} next.loaded\n   */\n\n  DocPad.prototype.loadedPlugin = function(pluginName, next) {\n    var docpad, loaded;\n    docpad = this;\n    loaded = docpad.loadedPlugins[pluginName] != null;\n    next(null, loaded);\n    return this;\n  };\n\n\n  /**\n  \t * Load a plugin from its full file path\n  \t * _next(err)\n  \t * @private\n  \t * @method loadPlugin\n  \t * @param {String} fileFullPath\n  \t * @param {Function} _next\n  \t * @param {Error} _next.err\n  \t * @return {Object} description\n   */\n\n  DocPad.prototype.loadPlugin = function(fileFullPath, _next) {\n    var config, docpad, enabled, loader, locale, next, pluginName;\n    docpad = this;\n    config = this.getConfig();\n    locale = this.getLocale();\n    next = function(err) {\n      delete docpad.slowPlugins[pluginName];\n      return _next(err);\n    };\n    loader = new PluginLoader({\n      dirPath: fileFullPath,\n      docpad: this,\n      BasePlugin: BasePlugin\n    });\n    pluginName = loader.pluginName;\n    enabled = (config.enableUnlistedPlugins && (config.enabledPlugins[pluginName] != null) === false) || config.enabledPlugins[pluginName] === true;\n    if (docpad.loadedPlugins[pluginName] != null) {\n      docpad.loadedPlugins[pluginName].setConfig();\n      return _next();\n    }\n    docpad.slowPlugins[pluginName] = true;\n    if (!enabled) {\n      docpad.log('debug', util.format(locale.pluginSkipped, pluginName));\n      return next();\n    } else {\n      docpad.log('debug', util.format(locale.pluginLoading, pluginName));\n      loader.exists(function(err, exists) {\n        if (err || !exists) {\n          return next(err);\n        }\n        return loader.unsupported(function(err, unsupported) {\n          if (err) {\n            return next(err);\n          }\n          if (unsupported) {\n            if ((unsupported === 'version-docpad' || unsupported === 'version-plugin') && config.skipUnsupportedPlugins === false) {\n              docpad.log('warn', util.format(locale.pluginContinued, pluginName));\n            } else {\n              if (unsupported === 'type') {\n                docpad.log('debug', util.format(locale.pluginSkippedDueTo, pluginName, unsupported));\n              } else {\n                docpad.log('warn', util.format(locale.pluginSkippedDueTo, pluginName, unsupported));\n              }\n              return next();\n            }\n          }\n          return loader.load(function(err) {\n            if (err) {\n              return next(err);\n            }\n            return loader.create({}, function(err, pluginInstance) {\n              if (err) {\n                return next(err);\n              }\n              docpad.loadedPlugins[loader.pluginName] = pluginInstance;\n              docpad.log('debug', util.format(locale.pluginLoaded, pluginName));\n              return next();\n            });\n          });\n        });\n      });\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Load plugins from a directory path\n  \t * @private\n  \t * @method loadPluginsIn\n  \t * @param {String} pluginsPath\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.loadPluginsIn = function(pluginsPath, next) {\n    var docpad, locale;\n    docpad = this;\n    locale = this.getLocale();\n    docpad.log('debug', util.format(locale.pluginsLoadingFor, pluginsPath));\n    this.scandir({\n      path: pluginsPath,\n      fileAction: false,\n      dirAction: function(fileFullPath, fileRelativePath, nextFile) {\n        var pluginName;\n        pluginName = pathUtil.basename(fileFullPath);\n        if (fileFullPath === pluginsPath) {\n          return nextFile(null, false);\n        }\n        return docpad.loadPlugin(fileFullPath, function(err) {\n          if (err) {\n            docpad.warn(util.format(locale.pluginFailedToLoad, pluginName, fileFullPath), err);\n          }\n          return nextFile(null, true);\n        });\n      },\n      next: function(err) {\n        docpad.log('debug', util.format(locale.pluginsLoadedFor, pluginsPath));\n        return next(err);\n      }\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Compare current DocPad version to the latest\n  \t * and print out the result to the console.\n  \t * Used at startup.\n  \t * @private\n  \t * @method compareVersion\n   */\n\n  DocPad.prototype.compareVersion = function() {\n    var config, docpad, locale;\n    docpad = this;\n    config = this.getConfig();\n    locale = this.getLocale();\n    if (config.offline || !config.checkVersion) {\n      return this;\n    }\n    balUtil.packageCompare({\n      local: this.packagePath,\n      remote: config.helperUrl + 'latest',\n      newVersionCallback: function(details) {\n        var currentVersion, isLocalInstallation, latestVersion, message, messageFilled, upgradeUrl;\n        isLocalInstallation = docpadUtil.isLocalDocPadExecutable();\n        message = (isLocalInstallation ? locale.versionOutdatedLocal : locale.versionOutdatedGlobal);\n        currentVersion = 'v' + details.local.version;\n        latestVersion = 'v' + details.remote.version;\n        upgradeUrl = details.local.upgradeUrl || details.remote.installUrl || details.remote.homepage;\n        messageFilled = util.format(message, currentVersion, latestVersion, upgradeUrl);\n        docpad.notify(latestVersion, {\n          title: locale.versionOutdatedNotification\n        });\n        return docpad.log('notice', messageFilled);\n      }\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Get DocPad's exchange data\n  \t * Requires internet access\n  \t * next(err,exchange)\n  \t * @private\n  \t * @method getExchange\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.exchange docpad.exchange\n   */\n\n  DocPad.prototype.getExchange = function(next) {\n    var config, docpad, exchangeUrl, locale;\n    docpad = this;\n    config = this.getConfig();\n    locale = this.getLocale();\n    if (typeChecker.isEmptyObject(docpad.exchange) === false) {\n      return next(null, docpad.exchange);\n    }\n    if (config.offline) {\n      return next(null, null);\n    }\n    docpad.log('info', locale.exchangeUpdate + ' ' + locale.pleaseWait);\n    exchangeUrl = config.helperUrl + '?method=exchange&version=' + this.version;\n    docpad.loadConfigUrl(exchangeUrl, function(err, parsedData) {\n      if (err) {\n        locale = docpad.getLocale();\n        docpad.warn(locale.exchangeError, err);\n        return next();\n      }\n      docpad.log('info', locale.exchangeUpdated);\n      docpad.exchange = parsedData;\n      return next(null, parsedData);\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Contextualize files.\n  \t * Contextualizing is the process of adding layouts and\n  \t * awareness of other documents to our document. The\n  \t * contextualizeBefore and contextualizeAfter events\n  \t * are emitted here.\n  \t * @private\n  \t * @method contextualizeFiles\n  \t * @param {Object} [opts={}]\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.contextualizeFiles = function(opts, next) {\n    var collection, config, docpad, locale, ref2, ref3, slowFilesObject, slowFilesTimer, templateData;\n    if (opts == null) {\n      opts = {};\n    }\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    collection = opts.collection, templateData = opts.templateData;\n    docpad = this;\n    config = this.getConfig();\n    locale = this.getLocale();\n    slowFilesObject = {};\n    slowFilesTimer = null;\n    if ((ref3 = opts.progress) != null) {\n      ref3.step(\"contextualizeFiles (preparing)\").total(1).setTick(0);\n    }\n    docpad.log('debug', util.format(locale.contextualizingFiles, collection.length));\n    docpad.emitSerial('contextualizeBefore', {\n      collection: collection,\n      templateData: templateData\n    }, function(err) {\n      var ref4, tasks;\n      if (err) {\n        return next(err);\n      }\n      tasks = new docpad.TaskGroup(\"contextualizeFiles tasks\", {\n        concurrency: 0,\n        next: function(err) {\n          var ref4;\n          clearInterval(slowFilesTimer);\n          slowFilesTimer = null;\n          if (err) {\n            return next(err);\n          }\n          if ((ref4 = opts.progress) != null) {\n            ref4.step(\"contextualizeFiles (postparing)\").total(1).setTick(0);\n          }\n          return docpad.emitSerial('contextualizeAfter', {\n            collection: collection\n          }, function(err) {\n            if (err) {\n              return next(err);\n            }\n            docpad.log('debug', util.format(locale.contextualizedFiles, collection.length));\n            return next();\n          });\n        }\n      });\n      if ((ref4 = opts.progress) != null) {\n        ref4.step('contextualizeFiles').total(collection.length).setTick(0);\n      }\n      collection.forEach(function(file, index) {\n        var filePath;\n        filePath = file.getFilePath();\n        slowFilesObject[file.id] = file.get('relativePath') || file.id;\n        return tasks.addTask(\"conextualizing: \" + filePath, function(complete) {\n          return file.action('contextualize', function(err) {\n            var ref5;\n            delete slowFilesObject[file.id];\n            if ((ref5 = opts.progress) != null) {\n              ref5.tick();\n            }\n            return complete(err);\n          });\n        });\n      });\n      slowFilesTimer = setInterval(function() {\n        var key, slowFilesArray, value;\n        slowFilesArray = (function() {\n          var results;\n          results = [];\n          for (key in slowFilesObject) {\n            if (!hasProp.call(slowFilesObject, key)) continue;\n            value = slowFilesObject[key];\n            results.push(value || key);\n          }\n          return results;\n        })();\n        return docpad.log('info', util.format(locale.slowFiles, 'contextualizeFiles') + ' \\n' + slowFilesArray.join('\\n'));\n      }, config.slowFilesDelay);\n      return tasks.run();\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Render the DocPad project's files.\n  \t * The renderCollectionBefore, renderCollectionAfter,\n  \t * renderBefore, renderAfter events are all emitted here.\n  \t * @private\n  \t * @method renderFiles\n  \t * @param {Object} [opts={}]\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.renderFiles = function(opts, next) {\n    var collection, config, docpad, locale, ref2, ref3, renderCollection, renderFile, renderPasses, slowFilesObject, slowFilesTimer, templateData;\n    if (opts == null) {\n      opts = {};\n    }\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    collection = opts.collection, templateData = opts.templateData, renderPasses = opts.renderPasses;\n    docpad = this;\n    config = this.getConfig();\n    locale = this.getLocale();\n    slowFilesObject = {};\n    slowFilesTimer = null;\n    if ((ref3 = opts.progress) != null) {\n      ref3.step(\"renderFiles (preparing)\").total(1).setTick(0);\n    }\n    docpad.log('debug', util.format(locale.renderingFiles, collection.length));\n    renderFile = function(file, next) {\n      if (file.get('render') === false || !file.get('relativePath')) {\n        file.attributes.rtime = new Date();\n        next(null, file.getOutContent(), file);\n      } else {\n        file.action('render', {\n          templateData: templateData\n        }, next);\n      }\n      return file;\n    };\n    renderCollection = function(collectionToRender, arg, next) {\n      var renderPass;\n      renderPass = arg.renderPass;\n      return docpad.emitSerial('renderCollectionBefore', {\n        collection: collectionToRender,\n        renderPass: renderPass\n      }, function(err) {\n        var ref4, subTasks;\n        if (err) {\n          return next(err);\n        }\n        subTasks = new docpad.TaskGroup(\"renderCollection: \" + collectionToRender.options.name, {\n          concurrency: 0,\n          next: function(err) {\n            if (err) {\n              return next(err);\n            }\n            return docpad.emitSerial('renderCollectionAfter', {\n              collection: collectionToRender,\n              renderPass: renderPass\n            }, next);\n          }\n        });\n        if ((ref4 = opts.progress) != null) {\n          ref4.step(\"renderFiles (pass \" + renderPass + \")\").total(collectionToRender.length).setTick(0);\n        }\n        collectionToRender.forEach(function(file) {\n          var filePath;\n          filePath = file.getFilePath();\n          slowFilesObject[file.id] = file.get('relativePath');\n          return subTasks.addTask(\"rendering: \" + filePath, function(complete) {\n            return renderFile(file, function(err) {\n              var ref5;\n              delete slowFilesObject[file.id] || file.id;\n              if ((ref5 = opts.progress) != null) {\n                ref5.tick();\n              }\n              return complete(err);\n            });\n          });\n        });\n        subTasks.run();\n        return collectionToRender;\n      });\n    };\n    docpad.emitSerial('renderBefore', {\n      collection: collection,\n      templateData: templateData\n    }, function(err) {\n      var i, initialCollection, results, subsequentCollection, tasks;\n      if (err) {\n        return next(err);\n      }\n      tasks = new docpad.TaskGroup(\"renderCollection: renderBefore tasks\", {\n        next: function(err) {\n          var ref4;\n          clearInterval(slowFilesTimer);\n          slowFilesTimer = null;\n          if (err) {\n            return next(err);\n          }\n          if ((ref4 = opts.progress) != null) {\n            ref4.step(\"renderFiles (postparing)\").total(1).setTick(0);\n          }\n          return docpad.emitSerial('renderAfter', {\n            collection: collection\n          }, function(err) {\n            if (err) {\n              return next(err);\n            }\n            docpad.log('debug', util.format(locale.renderedFiles, collection.length));\n            return next();\n          });\n        }\n      });\n      initialCollection = collection.findAll({\n        'referencesOthers': false\n      });\n      subsequentCollection = null;\n      tasks.addTask(\"rendering the initial collection\", function(complete) {\n        return renderCollection(initialCollection, {\n          renderPass: 1\n        }, function(err) {\n          if (err) {\n            return complete(err);\n          }\n          subsequentCollection = collection.findAll({\n            'referencesOthers': true\n          });\n          return renderCollection(subsequentCollection, {\n            renderPass: 2\n          }, complete);\n        });\n      });\n      if (renderPasses > 1) {\n        (function() {\n          results = [];\n          for (var i = 3; 3 <= renderPasses ? i <= renderPasses : i >= renderPasses; 3 <= renderPasses ? i++ : i--){ results.push(i); }\n          return results;\n        }).apply(this).forEach(function(renderPass) {\n          return tasks.addTask(\"rendering the subsequent collection index \" + renderPass, function(complete) {\n            return renderCollection(subsequentCollection, {\n              renderPass: renderPass\n            }, complete);\n          });\n        });\n      }\n      slowFilesTimer = setInterval(function() {\n        var key, slowFilesArray, value;\n        slowFilesArray = (function() {\n          var results1;\n          results1 = [];\n          for (key in slowFilesObject) {\n            if (!hasProp.call(slowFilesObject, key)) continue;\n            value = slowFilesObject[key];\n            results1.push(value || key);\n          }\n          return results1;\n        })();\n        return docpad.log('info', util.format(locale.slowFiles, 'renderFiles') + ' \\n' + slowFilesArray.join('\\n'));\n      }, config.slowFilesDelay);\n      return tasks.run();\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Write rendered files to the DocPad out directory.\n  \t * The writeBefore and writeAfter events are emitted here.\n  \t * @private\n  \t * @method writeFiles\n  \t * @param {Object} [opts={}]\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.writeFiles = function(opts, next) {\n    var collection, config, docpad, locale, ref2, ref3, slowFilesObject, slowFilesTimer, templateData;\n    if (opts == null) {\n      opts = {};\n    }\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    collection = opts.collection, templateData = opts.templateData;\n    docpad = this;\n    config = this.getConfig();\n    locale = this.getLocale();\n    slowFilesObject = {};\n    slowFilesTimer = null;\n    if ((ref3 = opts.progress) != null) {\n      ref3.step(\"writeFiles (preparing)\").total(1).setTick(0);\n    }\n    docpad.log('debug', util.format(locale.writingFiles, collection.length));\n    docpad.emitSerial('writeBefore', {\n      collection: collection,\n      templateData: templateData\n    }, function(err) {\n      var ref4, tasks;\n      if (err) {\n        return next(err);\n      }\n      tasks = new docpad.TaskGroup(\"writeFiles tasks\", {\n        concurrency: 0,\n        next: function(err) {\n          var ref4;\n          clearInterval(slowFilesTimer);\n          slowFilesTimer = null;\n          if (err) {\n            return next(err);\n          }\n          if ((ref4 = opts.progress) != null) {\n            ref4.step(\"writeFiles (postparing)\").total(1).setTick(0);\n          }\n          return docpad.emitSerial('writeAfter', {\n            collection: collection\n          }, function(err) {\n            if (err) {\n              return next(err);\n            }\n            return next();\n          });\n        }\n      });\n      if ((ref4 = opts.progress) != null) {\n        ref4.step('writeFiles').total(collection.length).setTick(0);\n      }\n      collection.forEach(function(file, index) {\n        var filePath;\n        filePath = file.getFilePath();\n        return tasks.addTask(\"writing the file: \" + filePath, function(complete) {\n          var fileTasks;\n          slowFilesObject[file.id] = file.get('relativePath');\n          fileTasks = new docpad.TaskGroup(\"tasks for file write: \" + filePath, {\n            concurrency: 0,\n            next: function(err) {\n              var ref5;\n              delete slowFilesObject[file.id];\n              if ((ref5 = opts.progress) != null) {\n                ref5.tick();\n              }\n              return complete(err);\n            }\n          });\n          if (file.get('write') !== false && file.get('dynamic') !== true && file.get('outPath')) {\n            fileTasks.addTask(\"write out\", function(complete) {\n              return file.action('write', complete);\n            });\n          }\n          if (file.get('writeSource') === true && file.get('fullPath')) {\n            fileTasks.addTask(\"write source\", function(complete) {\n              return file.action('writeSource', complete);\n            });\n          }\n          return fileTasks.run();\n        });\n      });\n      slowFilesTimer = setInterval(function() {\n        var key, slowFilesArray, value;\n        slowFilesArray = (function() {\n          var results;\n          results = [];\n          for (key in slowFilesObject) {\n            if (!hasProp.call(slowFilesObject, key)) continue;\n            value = slowFilesObject[key];\n            results.push(value || key);\n          }\n          return results;\n        })();\n        return docpad.log('info', util.format(locale.slowFiles, 'writeFiles') + ' \\n' + slowFilesArray.join('\\n'));\n      }, config.slowFilesDelay);\n      return tasks.run();\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Has DocPad's generation process started?\n  \t * @private\n  \t * @property {Boolean} generateStarted\n   */\n\n  DocPad.prototype.generateStarted = null;\n\n\n  /**\n  \t * Has DocPad's generation process ended?\n  \t * @private\n  \t * @property {Boolean} generateEnded\n   */\n\n  DocPad.prototype.generateEnded = null;\n\n\n  /**\n  \t * Is DocPad currently generating?\n  \t * @private\n  \t * @property {Boolean} generating\n   */\n\n  DocPad.prototype.generating = false;\n\n\n  /**\n  \t * Has DocPad done at least one generation?\n  \t * True once the first generation has occured.\n  \t * @private\n  \t * @property {Object} generated\n   */\n\n  DocPad.prototype.generated = false;\n\n\n  /**\n  \t * Create the console progress bar.\n  \t * Progress only shown if the DocPad config 'progress'\n  \t * option is true, the DocPad config 'prompts' option is true\n  \t * and the log level is 6 (default)\n  \t * @private\n  \t * @method createProgress\n  \t * @return {Object} the progress object\n   */\n\n  DocPad.prototype.createProgress = function() {\n    var config, docpad, progress;\n    docpad = this;\n    config = docpad.getConfig();\n    progress = null;\n    if (config.progress && config.prompts && this.getLogLevel() === 6) {\n      progress = require('progressbar').create();\n      this.getLoggers().console.unpipe(process.stdout);\n      this.getLogger().once('log', progress.logListener != null ? progress.logListener : progress.logListener = function(data) {\n        if (data.levelNumber <= 5) {\n          return docpad.destroyProgress(progress);\n        }\n      });\n    }\n    return progress;\n  };\n\n\n  /**\n  \t * Destructor. Destroy the progress object\n  \t * @private\n  \t * @method destroyProgress\n  \t * @param {Object} progress\n  \t * @return {Object} the progress object\n   */\n\n  DocPad.prototype.destroyProgress = function(progress) {\n    if (progress) {\n      progress.finish();\n      this.getLoggers().console.unpipe(process.stdout).pipe(process.stdout);\n    }\n    return progress;\n  };\n\n\n  /**\n  \t * Destructor. Destroy the regeneration timer.\n  \t * @private\n  \t * @method destroyRegenerateTimer\n   */\n\n  DocPad.prototype.destroyRegenerateTimer = function() {\n    var docpad;\n    docpad = this;\n    if (docpad.regenerateTimer) {\n      clearTimeout(docpad.regenerateTimer);\n      docpad.regenerateTimer = null;\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Create the regeneration timer\n  \t * @private\n  \t * @method createRegenerateTimer\n   */\n\n  DocPad.prototype.createRegenerateTimer = function() {\n    var config, docpad, locale;\n    docpad = this;\n    locale = docpad.getLocale();\n    config = docpad.getConfig();\n    if (config.regenerateEvery) {\n      docpad.regenerateTimer = setTimeout(function() {\n        docpad.log('info', locale.renderInterval);\n        return docpad.action('generate', config.regenerateEveryOptions);\n      }, config.regenerateEvery);\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Set off DocPad's generation process.\n  \t * The generated, populateCollectionsBefore, populateCollections, populateCollections\n  \t * generateBefore and generateAfter events are emitted here\n  \t * @method generate\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.generate = function(opts, next) {\n    var addGroup, addTask, config, database, docpad, lastGenerateStarted, locale, ref2, ref3, tasks;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = docpad.getConfig();\n    locale = docpad.getLocale();\n    database = docpad.getDatabase();\n    if (((ref3 = opts.collection) != null ? ref3.length : void 0) === 0) {\n      return next();\n    }\n    lastGenerateStarted = docpad.generateStarted;\n    docpad.generateStarted = new Date();\n    docpad.generateEnded = null;\n    docpad.generating = true;\n    if (database.models.length) {\n      docpad.databaseTempCache = new FilesCollection(database.models);\n    }\n    if (opts.progress == null) {\n      opts.progress = docpad.createProgress();\n    }\n    opts.templateData = docpad.getTemplateData(opts.templateData || {});\n    opts.renderPasses || (opts.renderPasses = config.renderPasses);\n    docpad.destroyRegenerateTimer();\n    if (!docpad.hasPlugins()) {\n      docpad.log('notice', locale.renderNoPlugins);\n    }\n    docpad.log('info', locale.renderGenerating);\n    docpad.notify((new Date()).toLocaleTimeString(), {\n      title: locale.renderGeneratingNotification\n    });\n    tasks = new this.TaskGroup(\"generate tasks\", {\n      progress: opts.progress\n    }).done(function(err) {\n      var howMany, ref4, seconds;\n      docpad.generating = false;\n      docpad.generateEnded = new Date();\n      docpad.databaseTempCache = null;\n      docpad.createRegenerateTimer();\n      if (opts.progress) {\n        docpad.destroyProgress(opts.progress);\n        opts.progress = null;\n      }\n      if (err) {\n        return next(err);\n      }\n      seconds = (docpad.generateEnded - docpad.generateStarted) / 1000;\n      howMany = (((ref4 = opts.collection) != null ? ref4.length : void 0) || 0) + \"/\" + database.length;\n      docpad.log('info', util.format(locale.renderGenerated, howMany, seconds));\n      docpad.notify((new Date()).toLocaleTimeString(), {\n        title: locale.renderGeneratedNotification\n      });\n      if (opts.initial === true) {\n        docpad.generated = true;\n        return docpad.emitSerial('generated', opts, next);\n      } else if (docpad.generated === false) {\n        return next(new Error('DocPad is in an invalid state, please report this on the github issue tracker. Reference 3360'));\n      } else {\n        return next();\n      }\n    });\n    addGroup = tasks.addGroup.bind(tasks);\n    addTask = tasks.addTask.bind(tasks);\n    addTask('Reset our collections', function(complete) {\n      if (!(opts.reset === true || docpad.generated === false)) {\n        return complete();\n      }\n      return docpad.resetCollections(opts, complete);\n    });\n    addTask('Figure out options', function() {\n      if (opts.cache == null) {\n        opts.cache = config.databaseCache;\n      }\n      if (opts.initial == null) {\n        opts.initial = !docpad.generated;\n      }\n      if (opts.reset == null) {\n        opts.reset = opts.initial;\n      }\n      if (opts.populate == null) {\n        opts.populate = opts.reset;\n      }\n      if (opts.reload == null) {\n        opts.reload = opts.reset;\n      }\n      if (opts.partial == null) {\n        opts.partial = !opts.reset;\n      }\n      return docpad.log('debug', 'Generate options:', pick(opts, ['cache', 'initial', 'reset', 'populate', 'reload', 'partial', 'renderPasses']));\n    });\n    addTask('check source directory exists', function(complete) {\n      if (opts.initial !== true) {\n        return complete();\n      }\n      return safefs.exists(config.srcPath, function(exists) {\n        var err;\n        if (!exists) {\n          err = new Error(locale.renderNonexistant);\n          return complete(err);\n        }\n        return complete();\n      });\n    });\n    addGroup('fetch data to render', function(addGroup, addTask) {\n      var ref4;\n      if (opts.populate === true) {\n        addTask('populateCollectionsBefore', function(complete) {\n          return docpad.emitSerial('populateCollectionsBefore', opts, complete);\n        });\n        if (opts.initial === true && ((ref4 = opts.cache) === true || ref4 === 'read')) {\n          addTask('import data from cache', function(complete) {\n            return safefs.exists(config.databaseCachePath, function(exists) {\n              if (exists === false) {\n                return complete();\n              }\n              return safefs.readFile(config.databaseCachePath, function(err, data) {\n                var addedModels, databaseData;\n                if (err) {\n                  return complete(err);\n                }\n                databaseData = JSON.parse(data.toString());\n                opts.cache = true;\n                opts.initial = true;\n                opts.reset = false;\n                opts.populate = true;\n                opts.reload = true;\n                opts.partial = true;\n                lastGenerateStarted = new Date(databaseData.generateStarted);\n                addedModels = docpad.addModels(databaseData.models);\n                docpad.log('info', util.format(locale.databaseCacheRead, database.length, databaseData.models.length));\n                return complete();\n              });\n            });\n          });\n        }\n        if (opts.reload === true) {\n          addGroup('import data from file system', function(addGroup, addTask) {\n            config.documentsPaths.forEach(function(documentsPath) {\n              return addTask('import documents', function(complete) {\n                return docpad.parseDirectory({\n                  modelType: 'document',\n                  collection: database,\n                  path: documentsPath,\n                  next: complete\n                });\n              });\n            });\n            config.filesPaths.forEach(function(filesPath) {\n              return addTask('import files', function(complete) {\n                return docpad.parseDirectory({\n                  modelType: 'file',\n                  collection: database,\n                  path: filesPath,\n                  next: complete\n                });\n              });\n            });\n            return config.layoutsPaths.forEach(function(layoutsPath) {\n              return addTask('import layouts', function(complete) {\n                return docpad.parseDirectory({\n                  modelType: 'document',\n                  collection: database,\n                  path: layoutsPath,\n                  next: complete\n                });\n              });\n            });\n          });\n        }\n        return addTask('populateCollections', function(complete) {\n          return docpad.emitSerial('populateCollections', opts, complete);\n        });\n      }\n    });\n    addGroup('determine files to render', function(addGroup, addTask) {\n      if (opts.partial === false) {\n        return addTask('Add all database models to render queue', function() {\n          return opts.collection != null ? opts.collection : opts.collection = new FilesCollection().add(docpad.getCollection('generate').models);\n        });\n      } else {\n        return addTask('Add only changed models to render queue', function() {\n          var changedQuery;\n          changedQuery = {\n            $or: {\n              mtime: {\n                $gte: lastGenerateStarted\n              },\n              $and: {\n                wtime: null,\n                write: true\n              }\n            }\n          };\n          return opts.collection != null ? opts.collection : opts.collection = new FilesCollection().add(docpad.getCollection('generate').findAll(changedQuery).models);\n        });\n      }\n    });\n    addTask('generateBefore', function(complete) {\n      if (opts.collection.length === 0) {\n        tasks.clear();\n        return complete();\n      } else {\n        return docpad.emitSerial('generateBefore', opts, complete);\n      }\n    });\n    addTask('prepare files', function(complete) {\n      var addLayoutChildren, allStandalone, model, standalones;\n      docpad.log('debug', 'Files to generate at', lastGenerateStarted, '\\n', (function() {\n        var i, len, ref4, results;\n        ref4 = opts.collection.models;\n        results = [];\n        for (i = 0, len = ref4.length; i < len; i++) {\n          model = ref4[i];\n          results.push({\n            id: model.id,\n            path: model.getFilePath(),\n            mtime: model.get('mtime'),\n            wtime: model.get('wtime'),\n            dynamic: model.get('dynamic'),\n            ignored: model.get('ignored'),\n            write: model.get('write')\n          });\n        }\n        return results;\n      })());\n      standalones = opts.collection.pluck('standalone');\n      allStandalone = standalones.indexOf(false) === -1;\n      if (allStandalone === false) {\n        opts.collection.add(docpad.getCollection('referencesOthers').models);\n      }\n      addLayoutChildren = function(collection) {\n        return collection.forEach(function(file) {\n          var layoutChildrenCollection, layoutChildrenQuery;\n          if (file.get('isLayout') === true) {\n            layoutChildrenQuery = {\n              layoutRelativePath: file.get('relativePath')\n            };\n            layoutChildrenCollection = docpad.getCollection('hasLayout').findAll(layoutChildrenQuery);\n            docpad.log('debug', 'Layout children to generate at', lastGenerateStarted, '\\n', (function() {\n              var i, len, ref4, results;\n              ref4 = layoutChildrenCollection.models;\n              results = [];\n              for (i = 0, len = ref4.length; i < len; i++) {\n                model = ref4[i];\n                results.push({\n                  id: model.id,\n                  path: model.getFilePath(),\n                  mtime: model.get('mtime'),\n                  wtime: model.get('wtime'),\n                  write: model.get('write')\n                });\n              }\n              return results;\n            })(), '\\n', layoutChildrenQuery);\n            addLayoutChildren(layoutChildrenCollection);\n            return opts.collection.add(layoutChildrenCollection.models);\n          }\n        });\n      };\n      addLayoutChildren(opts.collection);\n      opts.collection.reset(opts.collection.reject(function(file) {\n        return file.get('render') === false && file.get('write') === false;\n      }));\n      docpad.log('debug', 'Files to generate at', lastGenerateStarted, '\\n', (function() {\n        var i, len, ref4, results;\n        ref4 = opts.collection.models;\n        results = [];\n        for (i = 0, len = ref4.length; i < len; i++) {\n          model = ref4[i];\n          results.push({\n            id: model.id,\n            path: model.getFilePath(),\n            mtime: model.get('mtime'),\n            wtime: model.get('wtime'),\n            dynamic: model.get('dynamic'),\n            ignored: model.get('ignored'),\n            write: model.get('write')\n          });\n        }\n        return results;\n      })());\n      return complete();\n    });\n    addGroup('process file', function(addGroup, addTask) {\n      addTask('contextualizeFiles', {\n        args: [opts]\n      }, docpad.contextualizeFiles.bind(docpad));\n      addTask('renderFiles', {\n        args: [opts]\n      }, docpad.renderFiles.bind(docpad));\n      return addTask('writeFiles', {\n        args: [opts]\n      }, docpad.writeFiles.bind(docpad));\n    });\n    addTask('generateAfter', function(complete) {\n      return docpad.emitSerial('generateAfter', opts, complete);\n    });\n    addTask('Write the database cache', function(complete) {\n      var databaseData, databaseDataDump, model, ref4;\n      if ((ref4 = opts.cache) !== true && ref4 !== 'write') {\n        return complete();\n      }\n      databaseData = {\n        generateStarted: docpad.generateStarted,\n        generateEnded: docpad.generateEnded,\n        models: (function() {\n          var i, len, ref5, results;\n          ref5 = database.models;\n          results = [];\n          for (i = 0, len = ref5.length; i < len; i++) {\n            model = ref5[i];\n            results.push(model.getAttributes());\n          }\n          return results;\n        })()\n      };\n      databaseDataDump = JSON.stringify(databaseData, null, '  ');\n      docpad.log('info', util.format(locale.databaseCacheWrite, databaseData.models.length));\n      return safefs.writeFile(config.databaseCachePath, databaseDataDump, complete);\n    });\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Load a document\n  \t * @private\n  \t * @method loadDocument\n  \t * @param {Object} document\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.document\n   */\n\n  DocPad.prototype.loadDocument = function(document, opts, next) {\n    var ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    document.action('load contextualize', opts, next);\n    return this;\n  };\n\n\n  /**\n  \t * Load and render a document\n  \t * @method loadAndRenderDocument\n  \t * @param {Object} document\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.document\n   */\n\n  DocPad.prototype.loadAndRenderDocument = function(document, opts, next) {\n    var docpad, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    docpad.loadDocument(document, opts, function(err) {\n      if (err) {\n        return next(err);\n      }\n      return docpad.renderDocument(document, opts, next);\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Render a document\n  \t * @method renderDocument\n  \t * @param {Object} document\n  \t * @param {Object} opts\n  \t * @param {Object} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.result\n  \t * @param {Object} next.document\n   */\n\n  DocPad.prototype.renderDocument = function(document, opts, next) {\n    var clone, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    clone = document.clone().action('render', opts, function(err) {\n      var result;\n      result = clone.getOutContent();\n      return next(err, result, document);\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Render a document at a file path\n  \t * next(err,result)\n  \t * @method renderPath\n  \t * @param {String} path\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.result the rendered document\n   */\n\n  DocPad.prototype.renderPath = function(path, opts, next) {\n    var attributes, document, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    attributes = extendr.extend({\n      fullPath: path\n    }, opts.attributes);\n    document = this.createDocument(attributes);\n    this.loadAndRenderDocument(document, opts, next);\n    return this;\n  };\n\n\n  /**\n  \t * Render the passed content data as a\n  \t * document. Required option, filename\n  \t * (opts.filename)\n  \t * next(err,result)\n  \t * @method renderData\n  \t * @param {String} content\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.result the rendered document\n   */\n\n  DocPad.prototype.renderData = function(content, opts, next) {\n    var attributes, document, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    attributes = extendr.extend({\n      filename: opts.filename,\n      data: content\n    }, opts.attributes);\n    document = this.createDocument(attributes);\n    this.loadAndRenderDocument(document, opts, next);\n    return this;\n  };\n\n\n  /**\n  \t * Render the passed text data as a\n  \t * document. Required option, filename\n  \t * (opts.filename)\n  \t * next(err,result)\n  \t * @private\n  \t * @method renderText\n  \t * @param {String} text\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Object} next.result the rendered content\n  \t * @param {Object} next.document the rendered document model\n   */\n\n  DocPad.prototype.renderText = function(text, opts, next) {\n    var attributes, clone, document, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    if (opts.actions == null) {\n      opts.actions = ['renderExtensions', 'renderDocument'];\n    }\n    attributes = extendr.extend({\n      filename: opts.filename,\n      data: text,\n      body: text,\n      content: text\n    }, opts.attributes);\n    document = this.createDocument(attributes);\n    clone = document.clone().action('normalize contextualize render', opts, function(err) {\n      var result;\n      result = clone.getOutContent();\n      return next(err, result, document);\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Render action\n  \t * next(err,document,result)\n  \t * @method render\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.render = function(opts, next) {\n    var err, locale, path, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    locale = this.getLocale();\n    if (opts.document) {\n      this.renderDocument(opts.document, opts, next);\n    } else if (opts.data) {\n      this.renderData(opts.data, opts, next);\n    } else if (opts.text) {\n      this.renderText(opts.text, opts, next);\n    } else {\n      path = opts.path || opts.fullPath || opts.filename || null;\n      if (path) {\n        this.renderPath(path, opts, next);\n      } else {\n        err = new Error(locale.renderInvalidOptions);\n        return next(err);\n      }\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Array of file watchers\n  \t * @private\n  \t * @property {Array} watchers\n   */\n\n  DocPad.prototype.watchers = null;\n\n\n  /**\n  \t * Destructor. Destroy the watchers used\n  \t * by DocPad\n  \t * @private\n  \t * @method destroyWatchers\n   */\n\n  DocPad.prototype.destroyWatchers = function() {\n    var docpad, i, len, ref2, watcher;\n    docpad = this;\n    if (docpad.watchers) {\n      ref2 = docpad.watchers;\n      for (i = 0, len = ref2.length; i < len; i++) {\n        watcher = ref2[i];\n        watcher.close();\n      }\n      docpad.watchers = [];\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Start up file watchers used by DocPad\n  \t * @private\n  \t * @method watch\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.watch = function(opts, next) {\n    var changeHandler, config, database, docpad, locale, performGenerate, queueRegeneration, ref2, regenerateTimer, restartWatchers;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.getConfig();\n    locale = this.getLocale();\n    database = this.getDatabase();\n    if (this.watchers == null) {\n      this.watchers = [];\n    }\n    restartWatchers = function(next) {\n      var regeneratePaths, reloadPaths, srcPath, tasks;\n      docpad.destroyWatchers();\n      tasks = new docpad.TaskGroup(\"watch tasks\", {\n        concurrency: 0,\n        next: next\n      });\n      reloadPaths = union(config.reloadPaths, config.configPaths);\n      tasks.addTask(\"watch reload paths\", function(complete) {\n        return docpad.watchdir({\n          paths: reloadPaths,\n          listeners: {\n            'log': docpad.log,\n            'error': docpad.error,\n            'change': function() {\n              docpad.log('info', util.format(locale.watchReloadChange, new Date().toLocaleTimeString()));\n              return docpad.action('load', function(err) {\n                if (err) {\n                  return docpad.fatal(err);\n                }\n                return performGenerate({\n                  reset: true\n                });\n              });\n            }\n          },\n          next: function(err, _watchers) {\n            var i, len, watcher;\n            if (err) {\n              docpad.warn(\"Watching the reload paths has failed:\\n\" + docpad.inspector(reloadPaths), err);\n              return complete();\n            }\n            for (i = 0, len = _watchers.length; i < len; i++) {\n              watcher = _watchers[i];\n              docpad.watchers.push(watcher);\n            }\n            return complete();\n          }\n        });\n      });\n      regeneratePaths = config.regeneratePaths;\n      tasks.addTask(\"watch regenerate paths\", function(complete) {\n        return docpad.watchdir({\n          paths: regeneratePaths,\n          listeners: {\n            'log': docpad.log,\n            'error': docpad.error,\n            'change': function() {\n              return performGenerate({\n                reset: true\n              });\n            }\n          },\n          next: function(err, _watchers) {\n            var i, len, watcher;\n            if (err) {\n              docpad.warn(\"Watching the regenerate paths has failed:\\n\" + docpad.inspector(regeneratePaths), err);\n              return complete();\n            }\n            for (i = 0, len = _watchers.length; i < len; i++) {\n              watcher = _watchers[i];\n              docpad.watchers.push(watcher);\n            }\n            return complete();\n          }\n        });\n      });\n      srcPath = config.srcPath;\n      tasks.addTask(\"watch the source path\", function(complete) {\n        return docpad.watchdir({\n          path: srcPath,\n          listeners: {\n            'log': docpad.log,\n            'error': docpad.error,\n            'change': changeHandler\n          },\n          next: function(err, watcher) {\n            if (err) {\n              docpad.warn(\"Watching the src path has failed: \" + srcPath, err);\n              return complete();\n            }\n            docpad.watchers.push(watcher);\n            return complete();\n          }\n        });\n      });\n      tasks.run();\n      return this;\n    };\n    regenerateTimer = null;\n    queueRegeneration = function() {\n      if (regenerateTimer) {\n        clearTimeout(regenerateTimer);\n        regenerateTimer = null;\n      }\n      return regenerateTimer = setTimeout(performGenerate, config.regenerateDelay);\n    };\n    performGenerate = function(opts) {\n      if (opts == null) {\n        opts = {};\n      }\n      docpad.log(util.format(locale.watchRegenerating, new Date().toLocaleTimeString()));\n      return docpad.action('generate', opts, function(err) {\n        if (err) {\n          docpad.error(err);\n        }\n        return docpad.log(util.format(locale.watchRegenerated, new Date().toLocaleTimeString()));\n      });\n    };\n    changeHandler = function(changeType, filePath, fileCurrentStat, filePreviousStat) {\n      var err, file, fileEitherStat, isDirectory, isIgnored;\n      fileEitherStat = fileCurrentStat || filePreviousStat;\n      if (!fileEitherStat) {\n        err = new Error(\"DocPad has encountered an invalid state while detecting changes for your files.\\nSo the DocPad team can fix this right away, please provide any information you can to:\\nhttps://github.com/bevry/docpad/issues/792\");\n        return docpad.error(err);\n      }\n      docpad.log('info', util.format(locale.watchChange, new Date().toLocaleTimeString()), changeType, filePath);\n      isIgnored = docpad.isIgnoredPath(filePath);\n      if (isIgnored) {\n        docpad.log('debug', util.format(locale.watchIgnoredChange, new Date().toLocaleTimeString()), filePath);\n        return;\n      }\n      isDirectory = fileEitherStat.isDirectory();\n      if (isDirectory) {\n        docpad.log('debug', util.format(locale.watchDirectoryChange, new Date().toLocaleTimeString()), filePath);\n        return;\n      }\n      if (fileCurrentStat != null) {\n        fileCurrentStat.mtime = new Date();\n      }\n      file = docpad.addModel({\n        fullPath: filePath,\n        stat: fileCurrentStat\n      });\n      if (changeType === 'update') {\n        file.setStat(fileCurrentStat);\n      }\n      if (changeType === 'delete') {\n        database.remove(file);\n        return file.action('delete', function(err) {\n          if (err) {\n            return docpad.error(err);\n          }\n          return queueRegeneration();\n        });\n      } else if (changeType === 'create' || changeType === 'update') {\n        return file.action('load', function(err) {\n          if (err) {\n            return docpad.error(err);\n          }\n          return queueRegeneration();\n        });\n      }\n    };\n    docpad.log(locale.watchStart);\n    restartWatchers(function(err) {\n      if (err) {\n        return next(err);\n      }\n      docpad.log(locale.watchStarted);\n      return next();\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Run an action\n  \t * @method run\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.run = function(opts, next) {\n    var config, docpad, locale, ref2, rootPath, run, srcPath;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    locale = this.getLocale();\n    config = this.getConfig();\n    srcPath = config.srcPath, rootPath = config.rootPath;\n    run = function(complete) {\n      return balUtil.flow({\n        object: docpad,\n        action: 'server generate watch',\n        args: [opts],\n        next: complete\n      });\n    };\n    safefs.exists(srcPath, function(exists) {\n      if (exists) {\n        return run(next);\n      }\n      return safefs.readdir(rootPath, function(err, files) {\n        if (err) {\n          return next(err);\n        }\n        if (files.length) {\n          docpad.warn(util.format(locale.skeletonNonexistant, rootPath));\n          return next();\n        } else {\n          return docpad.skeleton(opts, function(err) {\n            if (err) {\n              return next(err);\n            }\n            if (opts.global === true || docpad.getConfig().global === true) {\n              return run(next);\n            }\n            docpad.log('notice', locale.startLocal);\n            return docpad.destroy(function(err) {\n              if (err) {\n                return next(err);\n              }\n              return docpadUtil.startLocalDocPadExecutable(next);\n            });\n          });\n        }\n      });\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Initialize the skeleton install process.\n  \t * @private\n  \t * @method initInstall\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.initInstall = function(opts, next) {\n    var config, docpad, ref2, tasks;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.getConfig();\n    tasks = new this.TaskGroup(\"initInstall tasks\", {\n      concurrency: 0,\n      next: next\n    });\n    tasks.addTask(\"node modules\", function(complete) {\n      var path;\n      path = pathUtil.join(config.rootPath, 'node_modules');\n      return safefs.ensurePath(path, complete);\n    });\n    tasks.addTask(\"package\", function(complete) {\n      var path;\n      path = pathUtil.join(config.rootPath, 'package.json');\n      return safefs.exists(path, function(exists) {\n        var data;\n        if (exists) {\n          return complete();\n        }\n        data = JSON.stringify({\n          name: 'no-skeleton.docpad',\n          version: '0.1.0',\n          description: 'New DocPad project without using a skeleton',\n          dependencies: {\n            docpad: '~' + docpad.getVersion()\n          },\n          main: 'node_modules/.bin/docpad-server',\n          scripts: {\n            start: 'node_modules/.bin/docpad-server'\n          }\n        }, null, '  ');\n        return safefs.writeFile(path, data, complete);\n      });\n    });\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Uninstall a plugin.\n  \t * @private\n  \t * @method uninstall\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.uninstall = function(opts, next) {\n    var config, docpad, ref2, tasks;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.getConfig();\n    tasks = new this.TaskGroup(\"uninstall tasks\", {\n      next: next\n    });\n    if (opts.plugin) {\n      tasks.addTask(\"uninstall the plugin: \" + opts.plugin, function(complete) {\n        var plugin, plugins;\n        plugins = (function() {\n          var i, len, ref3, results;\n          ref3 = opts.plugin.split(/[,\\s]+/);\n          results = [];\n          for (i = 0, len = ref3.length; i < len; i++) {\n            plugin = ref3[i];\n            if (plugin.indexOf('docpad-plugin-') !== 0) {\n              plugin = \"docpad-plugin-\" + plugin;\n            }\n            results.push(plugin);\n          }\n          return results;\n        })();\n        return docpad.uninstallNodeModule(plugins, {\n          stdio: 'inherit',\n          next: complete\n        });\n      });\n    }\n    tasks.addTask(\"re-load configuration\", function(complete) {\n      return docpad.load(complete);\n    });\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Install a plugin\n  \t * @private\n  \t * @method install\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.install = function(opts, next) {\n    var config, docpad, ref2, tasks;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.getConfig();\n    tasks = new this.TaskGroup(\"install tasks\", {\n      next: next\n    });\n    tasks.addTask(\"init the installation\", function(complete) {\n      return docpad.initInstall(opts, complete);\n    });\n    if (opts.plugin) {\n      tasks.addTask(\"install the plugin: \" + opts.plugin, function(complete) {\n        var plugin, plugins;\n        plugins = (function() {\n          var i, len, ref3, results;\n          ref3 = opts.plugin.split(/[,\\s]+/);\n          results = [];\n          for (i = 0, len = ref3.length; i < len; i++) {\n            plugin = ref3[i];\n            if (plugin.indexOf('docpad-plugin-') !== 0) {\n              plugin = \"docpad-plugin-\" + plugin;\n            }\n            if (plugin.indexOf('@') === -1) {\n              plugin += '@' + docpad.pluginVersion;\n            }\n            results.push(plugin);\n          }\n          return results;\n        })();\n        return docpad.installNodeModule(plugins, {\n          stdio: 'inherit',\n          next: complete\n        });\n      });\n    }\n    tasks.addTask(\"re-initialize the website's modules\", function(complete) {\n      return docpad.initNodeModules({\n        stdio: 'inherit',\n        next: complete\n      });\n    });\n    tasks.addTask(\"fix node package versions\", function(complete) {\n      return docpad.fixNodePackageVersions(complete);\n    });\n    tasks.addTask(\"re-load the configuration\", function(complete) {\n      return docpad.load(complete);\n    });\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Update global NPM and DocPad\n  \t * @private\n  \t * @method upgrade\n  \t * @param {Object} opts\n  \t * @param {Object} next\n  \t * @param {Error} next.err\n  \t * @return {Object} description\n   */\n\n  DocPad.prototype.upgrade = function(opts, next) {\n    this.installNodeModule('npm docpad@6', {\n      global: true,\n      stdio: 'inherit',\n      next: next\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Update the local DocPad and plugin dependencies\n  \t * @private\n  \t * @method update\n  \t * @param {Object} opts\n  \t * @param {Object} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.update = function(opts, next) {\n    var config, dependencies, devDependencies, docpad, ref2, tasks;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.getConfig();\n    tasks = new this.TaskGroup(\"update tasks\", {\n      next: next\n    });\n    tasks.addTask(\"init the install\", function(complete) {\n      return docpad.initInstall(opts, complete);\n    });\n    dependencies = [];\n    eachr(docpad.websitePackageConfig.dependencies, function(version, name) {\n      if (/^docpad-plugin-/.test(name) === false || /:\\/\\//.test(version) === true) {\n        return;\n      }\n      return dependencies.push(name + '@' + docpad.pluginVersion);\n    });\n    if (dependencies.length !== 0) {\n      tasks.addTask(\"update plugins that are dependencies\", function(complete) {\n        return docpad.installNodeModule('docpad@6 ' + dependencies, {\n          stdio: 'inherit',\n          next: complete\n        });\n      });\n    }\n    devDependencies = [];\n    eachr(docpad.websitePackageConfig.devDependencies, function(version, name) {\n      if (/^docpad-plugin-/.test(name) === false) {\n        return;\n      }\n      return devDependencies.push(name + '@' + docpad.pluginVersion);\n    });\n    if (devDependencies.length !== 0) {\n      tasks.addTask(\"update plugins that are dev dependencies\", function(complete) {\n        return docpad.installNodeModule(devDependencies, {\n          save: '--save-dev',\n          stdio: 'inherit',\n          next: complete\n        });\n      });\n    }\n    tasks.addTask(\"fix node package versions\", function(complete) {\n      return docpad.fixNodePackageVersions(complete);\n    });\n    tasks.addTask(\"re-initialize the rest of the website's modules\", function(complete) {\n      return docpad.initNodeModules({\n        stdio: 'inherit',\n        next: complete\n      });\n    });\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * DocPad cleanup tasks.\n  \t * @private\n  \t * @method clean\n  \t * @param {Object} opts\n  \t * @param {Object} next\n  \t * @param {Error} next.err\n  \t * @return {Object} description\n   */\n\n  DocPad.prototype.clean = function(opts, next) {\n    var config, docpad, locale, ref2, tasks;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = docpad.getConfig();\n    locale = this.getLocale();\n    docpad.log('info', locale.renderCleaning);\n    tasks = new this.TaskGroup(\"clean tasks\", {\n      concurrency: 0\n    }, {\n      next: function(err) {\n        if (err) {\n          return next(err);\n        }\n        docpad.log('info', locale.renderCleaned);\n        return next();\n      }\n    });\n    tasks.addTask('reset the collecitons', function(complete) {\n      return docpad.resetCollections(opts, complete);\n    });\n    tasks.addTask('delete out path', function(complete) {\n      if (config.rootPath.indexOf(config.outPath) !== -1) {\n        return complete();\n      }\n      return rimraf(config.outPath, complete);\n    });\n    tasks.addTask('delete database cache file', function(complete) {\n      return safefs.unlink(config.databaseCachePath, complete);\n    });\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Initialize a Skeleton into to a Directory\n  \t * @private\n  \t * @method initSkeleton\n  \t * @param {Object} skeletonModel\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.initSkeleton = function(skeletonModel, opts, next) {\n    var config, docpad, ref2, tasks;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.getConfig();\n    if (opts.destinationPath == null) {\n      opts.destinationPath = config.rootPath;\n    }\n    tasks = new this.TaskGroup(\"initSkeleton tasks\", {\n      next: next\n    });\n    tasks.addTask(\"ensure the path we are writing to exists\", function(complete) {\n      return safefs.ensurePath(opts.destinationPath, complete);\n    });\n    if ((skeletonModel != null) && skeletonModel.id !== 'none') {\n      tasks.addTask(\"clone out the git repo\", function(complete) {\n        return docpad.initGitRepo({\n          cwd: opts.destinationPath,\n          url: skeletonModel.get('repo'),\n          branch: skeletonModel.get('branch'),\n          remote: 'skeleton',\n          stdio: 'inherit',\n          next: complete\n        });\n      });\n    } else {\n      tasks.addTask(\"ensure src path exists\", function(complete) {\n        return safefs.ensurePath(config.srcPath, complete);\n      });\n      tasks.addGroup(\"initialize the website directory files\", function() {\n        this.setConfig({\n          concurrency: 0\n        });\n        this.addTask(\"README.md\", function(complete) {\n          var path;\n          path = pathUtil.join(config.rootPath, 'README.md');\n          return safefs.exists(path, function(exists) {\n            var data;\n            if (exists) {\n              return complete();\n            }\n            data = \"# Your [DocPad](http://docpad.org) Project\\n\\n## License\\nCopyright &copy; \" + ((new Date()).getFullYear()) + \"+ All rights reserved.\";\n            return safefs.writeFile(path, data, complete);\n          });\n        });\n        this.addTask(\"docpad.coffee configuration file\", function(complete) {\n          return docpad.getConfigPath(function(err, path) {\n            var data;\n            if (err || path) {\n              return complete(err);\n            }\n            path = pathUtil.join(config.rootPath, 'docpad.coffee');\n            data = \"# DocPad Configuration File\\n# http://docpad.org/docs/config\\n\\n# Define the DocPad Configuration\\ndocpadConfig = {\\n\t# ...\\n}\\n\\n# Export the DocPad Configuration\\nmodule.exports = docpadConfig\";\n            return safefs.writeFile(path, data, complete);\n          });\n        });\n        this.addTask(\"documents directory\", function(complete) {\n          return safefs.ensurePath(config.documentsPaths[0], complete);\n        });\n        this.addTask(\"layouts directory\", function(complete) {\n          return safefs.ensurePath(config.layoutsPaths[0], complete);\n        });\n        return this.addTask(\"files directory\", function(complete) {\n          return safefs.ensurePath(config.filesPaths[0], complete);\n        });\n      });\n    }\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Install a Skeleton into a Directory\n  \t * @private\n  \t * @method installSkeleton\n  \t * @param {Object} skeletonModel\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.installSkeleton = function(skeletonModel, opts, next) {\n    var docpad, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    if (opts.destinationPath == null) {\n      opts.destinationPath = this.getConfig().rootPath;\n    }\n    docpad.initSkeleton(skeletonModel, opts, function(err) {\n      if (err) {\n        return next(err);\n      }\n      return docpad.install(opts, next);\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Use a Skeleton\n  \t * @private\n  \t * @method useSkeleton\n  \t * @param {Object} skeletonModel\n  \t * @param {Object} opts\n  \t * @param {Object} next\n  \t * @param {Error} next.err\n  \t * @return {Object} description\n   */\n\n  DocPad.prototype.useSkeleton = function(skeletonModel, opts, next) {\n    var docpad, locale, ref2, skeletonId, skeletonName;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    locale = this.getLocale();\n    if (opts.destinationPath == null) {\n      opts.destinationPath = this.getConfig().rootPath;\n    }\n    skeletonId = (skeletonModel != null ? skeletonModel.id : void 0) || 'none';\n    skeletonName = (skeletonModel != null ? skeletonModel.get('name') : void 0) || locale.skeletonNoneName;\n    docpad.track('skeleton-use', {\n      skeletonId: skeletonId\n    });\n    docpad.log('info', util.format(locale.skeletonInstall, skeletonName, opts.destinationPath) + ' ' + locale.pleaseWait);\n    docpad.installSkeleton(skeletonModel, opts, function(err) {\n      if (err) {\n        return next(err);\n      }\n      docpad.log('info', locale.skeletonInstalled);\n      return next(err);\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Select a Skeleton\n  \t * @private\n  \t * @method selectSkeleton\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n  \t * @param {Error} next.skeletonModel\n   */\n\n  DocPad.prototype.selectSkeleton = function(opts, next) {\n    var docpad, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    if (opts.selectSkeletonCallback == null) {\n      opts.selectSkeletonCallback = null;\n    }\n    docpad.track('skeleton-ask');\n    docpad.getSkeletons(function(err, skeletonsCollection) {\n      if (err) {\n        return next(err);\n      }\n      return opts.selectSkeletonCallback(skeletonsCollection, next);\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Skeleton Empty?\n  \t * @private\n  \t * @method skeletonEmpty\n  \t * @param {Object} path\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.skeletonEmpty = function(path, next) {\n    var locale;\n    locale = this.getLocale();\n    if (path == null) {\n      path = this.getConfig().rootPath;\n    }\n    safefs.exists(pathUtil.join(path, 'package.json'), function(exists) {\n      var err;\n      if (exists) {\n        err = new Error(locale.skeletonExists);\n        return next(err);\n      }\n      return next();\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Initialize the project directory\n  \t * with the basic skeleton.\n  \t * @private\n  \t * @method skeleton\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.skeleton = function(opts, next) {\n    var docpad, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    if (opts.selectSkeletonCallback == null) {\n      opts.selectSkeletonCallback = null;\n    }\n    this.skeletonEmpty(null, function(err) {\n      if (err) {\n        return next(err);\n      }\n      return docpad.selectSkeleton(opts, function(err, skeletonModel) {\n        if (err) {\n          return next(err);\n        }\n        return docpad.useSkeleton(skeletonModel, next);\n      });\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Initialize the project directory\n  \t * with the basic skeleton.\n  \t * @private\n  \t * @method init\n  \t * @param {Object} opts\n  \t * @param {Object} next\n  \t * @param {Error} next.err\n  \t * @return {Object} description\n   */\n\n  DocPad.prototype.init = function(opts, next) {\n    var docpad, ref2;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    this.skeletonEmpty(null, function(err) {\n      if (err) {\n        return next(err);\n      }\n      return docpad.useSkeleton(null, next);\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Serve a document\n  \t * @private\n  \t * @method serveDocument\n  \t * @param {Object} opts\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.serveDocument = function(opts, next) {\n    var charset, collection, config, content, contentType, ctime, docpad, document, dynamic, encoding, err, etag, mtime, ref2, req, res, stat, templateData;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    document = opts.document, err = opts.err, req = opts.req, res = opts.res;\n    docpad = this;\n    config = this.getConfig();\n    if (!document) {\n      if (opts.statusCode != null) {\n        return res.send(opts.statusCode);\n      } else {\n        return next();\n      }\n    }\n    if (res.setHeaderIfMissing == null) {\n      res.setHeaderIfMissing = function(name, value) {\n        if (!res.getHeader(name)) {\n          return res.setHeader(name, value);\n        }\n      };\n    }\n    encoding = document.get('encoding');\n    if (encoding === 'utf8' || encoding === 'utf-8') {\n      charset = 'utf-8';\n    }\n    contentType = document.get('outContentType') || document.get('contentType');\n    res.setHeaderIfMissing('Content-Type', contentType + (charset ? \"; charset=\" + charset : ''));\n    if (config.maxAge) {\n      res.setHeaderIfMissing('Cache-Control', \"public, max-age=\" + config.maxAge);\n    }\n    dynamic = document.get('dynamic');\n    if (dynamic) {\n      collection = new FilesCollection([document], {\n        name: 'dynamic collection'\n      });\n      templateData = extendr.extend({}, req.templateData || {}, {\n        req: req,\n        err: err\n      });\n      docpad.action('generate', {\n        collection: collection,\n        templateData: templateData\n      }, function(err) {\n        var content;\n        content = document.getOutContent();\n        if (err) {\n          docpad.error(err);\n          return next(err);\n        } else {\n          if (opts.statusCode != null) {\n            return res.send(opts.statusCode, content);\n          } else {\n            return res.send(content);\n          }\n        }\n      });\n    } else {\n      ctime = document.get('date');\n      mtime = document.get('wtime');\n      stat = document.getStat();\n      if (mtime && stat) {\n        etag = stat.size + '-' + Number(mtime);\n      }\n      if (etag) {\n        res.setHeaderIfMissing('ETag', '\"' + etag + '\"');\n      }\n      if ((ctime != null ? ctime.toUTCString : void 0) != null) {\n        res.setHeaderIfMissing('Date', ctime.toUTCString());\n      }\n      if ((mtime != null ? mtime.toUTCString : void 0) != null) {\n        res.setHeaderIfMissing('Last-Modified', mtime.toUTCString());\n      }\n      if (etag && etag === (req.get('If-None-Match') || '').replace(/^\"|\"$/g, '')) {\n        res.send(304);\n      } else {\n        content = document.getOutContent();\n        if (content) {\n          if (opts.statusCode != null) {\n            res.send(opts.statusCode, content);\n          } else {\n            res.send(content);\n          }\n        } else {\n          if (opts.statusCode != null) {\n            res.send(opts.statusCode);\n          } else {\n            next();\n          }\n        }\n      }\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Server Middleware: Header\n  \t * @private\n  \t * @method serverMiddlewareHeader\n  \t * @param {Object} req\n  \t * @param {Object} res\n  \t * @param {Object} next\n   */\n\n  DocPad.prototype.serverMiddlewareHeader = function(req, res, next) {\n    var docpad, tools;\n    docpad = this;\n    tools = res.get('X-Powered-By').split(/[,\\s]+/g);\n    tools.push(\"DocPad v\" + (docpad.getVersion()));\n    tools = tools.join(', ');\n    res.set('X-Powered-By', tools);\n    next();\n    return this;\n  };\n\n\n  /**\n  \t * Server Middleware: Router\n  \t * @private\n  \t * @method serverMiddlewareRouter\n  \t * @param {Object} req\n  \t * @param {Object} res\n  \t * @param {Function} next\n  \t * @param {Error} next.err\n   */\n\n  DocPad.prototype.serverMiddlewareRouter = function(req, res, next) {\n    var docpad;\n    docpad = this;\n    docpad.getFileByRoute(req.url, function(err, file) {\n      var cleanUrl, url;\n      if (err || (file != null) === false) {\n        return next(err);\n      }\n      url = file.get('url');\n      cleanUrl = docpad.getUrlPathname(req.url);\n      if ((url !== cleanUrl) && (url !== req.url)) {\n        return res.redirect(301, url);\n      }\n      return docpad.serveDocument({\n        document: file,\n        req: req,\n        res: res,\n        next: next\n      });\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Server Middleware: 404\n  \t * @private\n  \t * @method serverMiddleware404\n  \t * @param {Object} req\n  \t * @param {Object} res\n  \t * @param {Object} next\n   */\n\n  DocPad.prototype.serverMiddleware404 = function(req, res, next) {\n    var database, docpad, document;\n    docpad = this;\n    database = docpad.getDatabaseSafe();\n    docpad.log('notice', \"404 Not Found:\", req.url);\n    if (!database) {\n      return res.send(500);\n    }\n    document = database.findOne({\n      relativeOutPath: '404.html'\n    });\n    docpad.serveDocument({\n      document: document,\n      req: req,\n      res: res,\n      next: next,\n      statusCode: 404\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Server Middleware: 500\n  \t * @private\n  \t * @method serverMiddleware500\n  \t * @param {Object} err\n  \t * @param {Object} req\n  \t * @param {Object} res\n  \t * @param {Function} next\n   */\n\n  DocPad.prototype.serverMiddleware500 = function(err, req, res, next) {\n    var database, docpad, document;\n    docpad = this;\n    database = docpad.getDatabaseSafe();\n    if (!database) {\n      return res.send(500);\n    }\n    document = database.findOne({\n      relativeOutPath: '500.html'\n    });\n    docpad.serveDocument({\n      document: document,\n      err: err,\n      req: req,\n      res: res,\n      next: next,\n      statusCode: 500\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Configure and start up the DocPad web server.\n  \t * Http and express server is created, extended with\n  \t * middleware, started up and begins listening.\n  \t * The events serverBefore, serverExtend and\n  \t * serverAfter emitted here.\n  \t * @private\n  \t * @method server\n  \t * @param {Object} opts\n  \t * @param {Function} next\n   */\n\n  DocPad.prototype.server = function(opts, next) {\n    var config, docpad, express, hostname, http, locale, port, ref2, ref3, ref4, ref5, servers, tasks;\n    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];\n    docpad = this;\n    config = this.config;\n    locale = this.getLocale();\n    port = this.getPort();\n    hostname = this.getHostname();\n    http = require('http');\n    express = require('express');\n    servers = this.getServer(true);\n    if (opts.serverExpress == null) {\n      opts.serverExpress = servers.serverExpress;\n    }\n    if (opts.serverHttp == null) {\n      opts.serverHttp = servers.serverHttp;\n    }\n    if (opts.middlewareBodyParser == null) {\n      opts.middlewareBodyParser = (ref3 = config.middlewareBodyParser) != null ? ref3 : config.middlewareStandard;\n    }\n    if (opts.middlewareMethodOverride == null) {\n      opts.middlewareMethodOverride = (ref4 = config.middlewareMethodOverride) != null ? ref4 : config.middlewareStandard;\n    }\n    if (opts.middlewareExpressRouter == null) {\n      opts.middlewareExpressRouter = (ref5 = config.middlewareExpressRouter) != null ? ref5 : config.middlewareStandard;\n    }\n    if (opts.middleware404 == null) {\n      opts.middleware404 = config.middleware404;\n    }\n    if (opts.middleware500 == null) {\n      opts.middleware500 = config.middleware500;\n    }\n    tasks = new this.TaskGroup(\"server tasks\", {\n      next: next\n    });\n    tasks.addTask(\"emit serverBefore\", function(complete) {\n      return docpad.emitSerial('serverBefore', complete);\n    });\n    if (!opts.serverExpress || !opts.serverHttp) {\n      tasks.addTask(\"create server\", function() {\n        opts.serverExpress || (opts.serverExpress = express());\n        opts.serverHttp || (opts.serverHttp = http.createServer(opts.serverExpress));\n        return docpad.setServer(opts);\n      });\n    }\n    if (config.extendServer === true) {\n      tasks.addTask(\"extend the server\", function(complete) {\n        if (opts.middlewareBodyParser !== false) {\n          opts.serverExpress.use(express.urlencoded());\n          opts.serverExpress.use(express.json());\n        }\n        if (opts.middlewareMethodOverride !== false) {\n          if (typeChecker.isString(opts.middlewareMethodOverride)) {\n            opts.serverExpress.use(require('method-override')(opts.middlewareMethodOverride));\n          } else {\n            opts.serverExpress.use(require('method-override')());\n          }\n        }\n        return docpad.emitSerial('serverExtend', {\n          server: opts.serverExpress,\n          express: opts.serverExpress,\n          serverHttp: opts.serverHttp,\n          serverExpress: opts.serverExpress\n        }, function(err) {\n          if (err) {\n            return next(err);\n          }\n          opts.serverExpress.use(docpad.serverMiddlewareHeader);\n          if (opts.middlewareExpressRouter !== false) {\n            opts.serverExpress.use(opts.serverExpress.router);\n          }\n          opts.serverExpress.use(docpad.serverMiddlewareRouter);\n          if (config.maxAge) {\n            opts.serverExpress.use(express[\"static\"](config.outPath, {\n              maxAge: config.maxAge\n            }));\n          } else {\n            opts.serverExpress.use(express[\"static\"](config.outPath));\n          }\n          if (opts.middleware404 !== false) {\n            opts.serverExpress.use(docpad.serverMiddleware404);\n          }\n          if (opts.middleware500 !== false) {\n            opts.serverExpress.use(docpad.serverMiddleware500);\n          }\n          return complete();\n        });\n      });\n    }\n    tasks.addTask(\"start the server\", function(complete) {\n      opts.serverHttp.once('error', function(err) {\n        if (err.message.indexOf('EADDRINUSE') !== -1) {\n          err = new Error(util.format(locale.serverInUse, port));\n        }\n        return complete(err);\n      });\n      docpad.log('debug', util.format(locale.serverStart, hostname, port));\n      return opts.serverHttp.listen(port, hostname, function() {\n        var address, serverUrl, simpleServerUrl;\n        address = opts.serverHttp.address();\n        serverUrl = docpad.getServerUrl({\n          hostname: address.hostname,\n          port: address.port\n        });\n        simpleServerUrl = docpad.getSimpleServerUrl({\n          hostname: address.hostname,\n          port: address.port\n        });\n        docpad.log('info', util.format(locale.serverStarted, serverUrl));\n        if (serverUrl !== simpleServerUrl) {\n          docpad.log('info', util.format(locale.serverBrowse, simpleServerUrl));\n        }\n        return complete();\n      });\n    });\n    tasks.addTask(\"emit serverAfter\", function(complete) {\n      return docpad.emitSerial('serverAfter', {\n        server: opts.serverExpress,\n        express: opts.serverExpress,\n        serverHttp: opts.serverHttp,\n        serverExpress: opts.serverExpress\n      }, complete);\n    });\n    tasks.run();\n    return this;\n  };\n\n  return DocPad;\n\n})(EventEmitterGrouped);\n\nmodule.exports = DocPad;\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/lib/base.js":"// Generated by CoffeeScript 1.12.4\nvar Collection, Events, Model, QueryCollection, emit, extendr, log, queryEngine,\n  slice = [].slice,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nextendr = require('extendr');\n\nqueryEngine = require('query-engine');\n\nlog = function() {\n  var args;\n  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n  args.unshift('log');\n  this.emit.apply(this, args);\n  return this;\n};\n\nemit = function() {\n  var args;\n  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n  return this.trigger.apply(this, args);\n};\n\n\n/**\n * Base class for the DocPad Events object\n * Extends the backbone.js events object\n * http://backbonejs.org/#Events\n * @class Events\n * @constructor\n * @extends queryEngine.Backbone.Events\n */\n\nEvents = (function() {\n  function Events() {}\n\n  Events.prototype.log = log;\n\n  Events.prototype.emit = emit;\n\n  return Events;\n\n})();\n\nextendr.extend(Events.prototype, queryEngine.Backbone.Events);\n\n\n/**\n * Base class for the DocPad file and document model\n * Extends the backbone.js model\n * http://backbonejs.org/#Model\n * @class Model\n * @constructor\n * @extends queryEngine.Backbone.Model\n */\n\nModel = (function(superClass) {\n  extend(Model, superClass);\n\n  function Model() {\n    return Model.__super__.constructor.apply(this, arguments);\n  }\n\n  Model.prototype.log = log;\n\n  Model.prototype.emit = emit;\n\n  Model.prototype.setDefaults = function(attrs, opts) {\n    var key, ref, set, value;\n    if (attrs == null) {\n      attrs = {};\n    }\n    set = {};\n    for (key in attrs) {\n      if (!hasProp.call(attrs, key)) continue;\n      value = attrs[key];\n      if (this.get(key) === ((ref = this.defaults) != null ? ref[key] : void 0)) {\n        set[key] = value;\n      }\n    }\n    return this.set(set, opts);\n  };\n\n  return Model;\n\n})(queryEngine.Backbone.Model);\n\n\n/**\n * Base class for the DocPad collection object\n * Extends the backbone.js collection object\n * http://backbonejs.org/#Collection\n * @class Collection\n * @constructor\n * @extends queryEngine.Backbone.Collection\n */\n\nCollection = (function(superClass) {\n  extend(Collection, superClass);\n\n  function Collection() {\n    this.destroy = bind(this.destroy, this);\n    return Collection.__super__.constructor.apply(this, arguments);\n  }\n\n  Collection.prototype.log = log;\n\n  Collection.prototype.emit = emit;\n\n  Collection.prototype.destroy = function() {\n    this.emit('destroy');\n    this.off().stopListening();\n    return this;\n  };\n\n  return Collection;\n\n})(queryEngine.Backbone.Collection);\n\nCollection.prototype.model = Model;\n\nCollection.prototype.collection = Collection;\n\n\n/**\n * Base class for the DocPad query collection object\n * Extends the bevry QueryEngine object\n * http://github.com/bevry/query-engine\n * @class QueryCollection\n * @constructor\n * @extends queryEngine.QueryCollection\n */\n\nQueryCollection = (function(superClass) {\n  extend(QueryCollection, superClass);\n\n  function QueryCollection() {\n    this.destroy = bind(this.destroy, this);\n    return QueryCollection.__super__.constructor.apply(this, arguments);\n  }\n\n  QueryCollection.prototype.log = log;\n\n  QueryCollection.prototype.emit = emit;\n\n  QueryCollection.prototype.setParentCollection = function() {\n    var parentCollection;\n    QueryCollection.__super__.setParentCollection.apply(this, arguments);\n    parentCollection = this.getParentCollection();\n    parentCollection.on('destroy', this.destroy);\n    return this;\n  };\n\n  QueryCollection.prototype.destroy = function() {\n    this.emit('destroy');\n    this.off().stopListening();\n    return this;\n  };\n\n  return QueryCollection;\n\n})(queryEngine.QueryCollection);\n\nQueryCollection.prototype.model = Model;\n\nQueryCollection.prototype.collection = QueryCollection;\n\nmodule.exports = {\n  Events: Events,\n  Model: Model,\n  Collection: Collection,\n  QueryCollection: QueryCollection\n};\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/lib/util.js":"// Generated by CoffeeScript 1.12.4\nvar TaskGroup, compact, docpadUtil, extractOptsAndCallback, pathUtil, ref, uniq, util,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  slice = [].slice;\n\npathUtil = require('path');\n\nutil = require('util');\n\nref = require('underscore'), uniq = ref.uniq, compact = ref.compact;\n\nextractOptsAndCallback = require('extract-opts');\n\nTaskGroup = require('taskgroup').TaskGroup;\n\n\n/**\n * The DocPad Util Class.\n * Collection of DocPad utility methods\n * @class docpadUtil\n * @constructor\n * @static\n */\n\nmodule.exports = docpadUtil = {\n\n  /**\n  \t * Write to stderr\n  \t * @private\n  \t * @method writeStderr\n  \t * @param {String} data\n   */\n  writeStderr: function(data) {\n    var err;\n    try {\n      return process.stderr.write(data);\n    } catch (error) {\n      err = error;\n      return process.stdout.write(data);\n    }\n  },\n\n  /**\n  \t * Write an error\n  \t * @private\n  \t * @method writeError\n  \t * @param {Object} err\n   */\n  writeError: function(err) {\n    var ref1;\n    return docpadUtil.writeStderr(((ref1 = err.stack) != null ? typeof ref1.toString === \"function\" ? ref1.toString() : void 0 : void 0) || err.message || err);\n  },\n\n  /**\n  \t * Wait. Wrapper for setTimeout\n  \t * @private\n  \t * @method wait\n  \t * @param {Number} time\n  \t * @param {function} fn\n   */\n  wait: function(time, fn) {\n    return setTimeout(fn, time);\n  },\n\n  /**\n  \t * Get Default Log Level\n  \t * @private\n  \t * @method getDefaultLogLevel\n  \t * @return {Number} default log level\n   */\n  getDefaultLogLevel: function() {\n    if (docpadUtil.isTravis() || (indexOf.call(process.argv, '-d') >= 0)) {\n      return 7;\n    } else {\n      return 5;\n    }\n  },\n\n  /**\n  \t * Are we executing on Travis\n  \t * @private\n  \t * @method isTravis\n  \t * @return {String} The travis node version\n   */\n  isTravis: function() {\n    return process.env.TRAVIS_NODE_VERSION != null;\n  },\n\n  /**\n  \t * Is this TTY\n  \t * @private\n  \t * @method isTTY\n  \t * @return {Boolean}\n   */\n  isTTY: function() {\n    var ref1, ref2;\n    return ((ref1 = process.stdout) != null ? ref1.isTTY : void 0) === true && ((ref2 = process.stderr) != null ? ref2.isTTY : void 0) === true;\n  },\n\n  /**\n  \t * Is Standadlone\n  \t * @private\n  \t * @method isStandalone\n  \t * @return {Object}\n   */\n  isStandalone: function() {\n    return /docpad$/.test(process.argv[1] || '');\n  },\n\n  /**\n  \t * Is user\n  \t * @private\n  \t * @method isUser\n  \t * @return {Boolean}\n   */\n  isUser: function() {\n    return docpadUtil.isStandalone() && docpadUtil.isTTY() && docpadUtil.isTravis() === false;\n  },\n\n  /**\n  \t * Wrapper for the node.js method util.inspect\n  \t * @method inspect\n  \t * @param {Object} obj\n  \t * @param {Object} opts\n  \t * @return {String}\n   */\n  inspect: function(obj, opts) {\n    if (opts == null) {\n      opts = {};\n    }\n    if (docpadUtil.isTTY()) {\n      if (opts.colors == null) {\n        opts.colors = indexOf.call(process.argv, '--no-colors') < 0;\n      }\n    } else {\n      opts.colors = false;\n    }\n    return util.inspect(obj, opts);\n  },\n\n  /**\n  \t * Are we using standard encoding?\n  \t * @private\n  \t * @method isStandardEncoding\n  \t * @param {String} encoding\n  \t * @return {Boolean}\n   */\n  isStandardEncoding: function(encoding) {\n    var ref1;\n    return (ref1 = encoding.toLowerCase()) === 'ascii' || ref1 === 'utf8' || ref1 === 'utf-8';\n  },\n\n  /**\n  \t * Get Local DocPad Installation Executable - ie\n  \t * not the global installation\n  \t * @private\n  \t * @method getLocalDocPadExecutable\n  \t * @return {String} the path to the local DocPad executable\n   */\n  getLocalDocPadExecutable: function() {\n    return pathUtil.join(process.cwd(), 'node_modules', 'docpad', 'bin', 'docpad');\n  },\n\n  /**\n  \t * Is Local DocPad Installation\n  \t * @private\n  \t * @method isLocalDocPadExecutable\n  \t * @return {Boolean}\n   */\n  isLocalDocPadExecutable: function() {\n    var ref1;\n    return ref1 = docpadUtil.getLocalDocPadExecutable(), indexOf.call(process.argv, ref1) >= 0;\n  },\n\n  /**\n  \t * Does the local DocPad Installation Exist?\n  \t * @private\n  \t * @method getLocalDocPadExecutableExistance\n  \t * @return {Boolean}\n   */\n  getLocalDocPadExecutableExistance: function() {\n    return require('safefs').existsSync(docpadUtil.getLocalDocPadExecutable()) === true;\n  },\n\n  /**\n  \t * Spawn Local DocPad Executable\n  \t * @private\n  \t * @method startLocalDocPadExecutable\n  \t * @param {Function} next\n  \t * @return {Object} don't know what\n   */\n  startLocalDocPadExecutable: function(next) {\n    var args, command;\n    args = process.argv.slice(2);\n    command = ['node', docpadUtil.getLocalDocPadExecutable()].concat(args);\n    return require('safeps').spawn(command, {\n      stdio: 'inherit'\n    }, function(err) {\n      var message;\n      if (err) {\n        if (next) {\n          return next(err);\n        } else {\n          message = 'An error occured within the child DocPad instance: ' + err.message + '\\n';\n          return docpadUtil.writeStderr(message);\n        }\n      } else {\n        return typeof next === \"function\" ? next() : void 0;\n      }\n    });\n  },\n\n  /**\n  \t * get a filename without the extension\n  \t * @method getBasename\n  \t * @param {String} filename\n  \t * @return {String} base name\n   */\n  getBasename: function(filename) {\n    var basename;\n    if (filename[0] === '.') {\n      basename = filename.replace(/^(\\.[^\\.]+)\\..*$/, '$1');\n    } else {\n      basename = filename.replace(/\\..*$/, '');\n    }\n    return basename;\n  },\n\n  /**\n  \t * Get the extensions of a filename\n  \t * @method getExtensions\n  \t * @param {String} filename\n  \t * @return {Array} array of string\n   */\n  getExtensions: function(filename) {\n    var extensions;\n    extensions = filename.split(/\\./g).slice(1);\n    return extensions;\n  },\n\n  /**\n  \t * Get the extension from a bunch of extensions\n  \t * @method getExtension\n  \t * @param {Array} extensions\n  \t * @return {String} the extension\n   */\n  getExtension: function(extensions) {\n    var extension;\n    if (!require('typechecker').isArray(extensions)) {\n      extensions = docpadUtil.getExtensions(extensions);\n    }\n    if (extensions.length !== 0) {\n      extension = extensions.slice(-1)[0] || null;\n    } else {\n      extension = null;\n    }\n    return extension;\n  },\n\n  /**\n  \t * Get the directory path.\n  \t * Wrapper around the node.js path.dirname method\n  \t * @method getDirPath\n  \t * @param {String} path\n  \t * @return {String}\n   */\n  getDirPath: function(path) {\n    return pathUtil.dirname(path) || '';\n  },\n\n  /**\n  \t * Get the file name.\n  \t * Wrapper around the node.js path.basename method\n  \t * @method getFilename\n  \t * @param {String} path\n  \t * @return {String}\n   */\n  getFilename: function(path) {\n    return pathUtil.basename(path);\n  },\n\n  /**\n  \t * Get the DocPad out file name\n  \t * @method getOutFilename\n  \t * @param {String} basename\n  \t * @param {String} extension\n  \t * @return {String}\n   */\n  getOutFilename: function(basename, extension) {\n    if (basename === '.' + extension) {\n      return basename;\n    } else {\n      return basename + (extension ? '.' + extension : '');\n    }\n  },\n\n  /**\n  \t * Get the URL\n  \t * @method getUrl\n  \t * @param {String} relativePath\n  \t * @return {String}\n   */\n  getUrl: function(relativePath) {\n    return '/' + relativePath.replace(/[\\\\]/g, '/');\n  },\n\n  /**\n  \t * Get the post slug from the URL\n  \t * @method getSlug\n  \t * @param {String} relativeBase\n  \t * @return {String} the slug\n   */\n  getSlug: function(relativeBase) {\n    return require('bal-util').generateSlugSync(relativeBase);\n  },\n\n  /**\n  \t * Perform an action\n  \t * next(err,...), ... = any special arguments from the action\n  \t * this should be it's own npm module\n  \t * as we also use the concept of actions in a few other packages.\n  \t * Important concept in DocPad.\n  \t * @method action\n  \t * @param {Object} action\n  \t * @param {Object} opts\n  \t * @param {Function} next\n   */\n  action: function(action, opts, next) {\n    var actionMethod, actionTaskOrGroup, actions, err, i, len, locale, me, ref1, ref2, ref3, run, runner, runnerTask, task;\n    ref1 = extractOptsAndCallback(opts, next), opts = ref1[0], next = ref1[1];\n    me = this;\n    locale = me.getLocale();\n    run = (ref2 = opts.run) != null ? ref2 : true;\n    runner = (ref3 = opts.runner) != null ? ref3 : me.getActionRunner();\n    if (Array.isArray(action)) {\n      actions = action;\n    } else {\n      actions = action.split(/[,\\s]+/g);\n    }\n    actions = uniq(compact(actions));\n    if (actions.length === 0) {\n      err = new Error(locale.actionEmpty);\n      return next(err);\n      me;\n    }\n    if (actions.length > 1) {\n      actionTaskOrGroup = runner.createGroup('actions bundle: ' + actions.join(' '));\n      for (i = 0, len = actions.length; i < len; i++) {\n        action = actions[i];\n        actionMethod = me[action].bind(me);\n        if (!actionMethod) {\n          err = new Error(util.format(locale.actionNonexistant, action));\n          return next(err);\n          me;\n        }\n        task = actionTaskOrGroup.createTask(action, actionMethod, {\n          args: [opts]\n        });\n        actionTaskOrGroup.addTask(task);\n      }\n    } else {\n      action = actions[0];\n      actionMethod = me[action].bind(me);\n      if (!actionMethod) {\n        err = new Error(util.format(locale.actionNonexistant, action));\n        return next(err);\n        me;\n      }\n      actionTaskOrGroup = runner.createTask(action, actionMethod, {\n        args: [opts]\n      });\n    }\n    runnerTask = runner.createTask(\"runner task for action: \" + action, function(continueWithRunner) {\n      actionTaskOrGroup.done(function() {\n        var args;\n        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        if (next) {\n          next.apply(null, args);\n          args[0] = null;\n        }\n        return continueWithRunner.apply(null, args);\n      });\n      return actionTaskOrGroup.run();\n    });\n    runner.addTask(runnerTask);\n    if (run === true) {\n      runner.run();\n    }\n    return me;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/lib/models/file.js":"// Generated by CoffeeScript 1.12.4\nvar FileModel, Model, TaskGroup, docpadUtil, encodingUtil, extendr, extractOptsAndCallback, isTextOrBinary, jschardet, mime, pathUtil, safefs, typeChecker, util,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  slice = [].slice;\n\nutil = require('util');\n\npathUtil = require('path');\n\nisTextOrBinary = require('istextorbinary');\n\ntypeChecker = require('typechecker');\n\nTaskGroup = require('taskgroup').TaskGroup;\n\nsafefs = require('safefs');\n\nmime = require('mime');\n\nextendr = require('extendr');\n\nextractOptsAndCallback = require('extract-opts');\n\njschardet = null;\n\nencodingUtil = null;\n\nModel = require('../base').Model;\n\ndocpadUtil = require('../util');\n\n\n/**\n * The FileModel class is DocPad's representation\n * of a file in the file system.\n * Extends the DocPad Model class\n * https://github.com/docpad/docpad/blob/master/src/lib/base.coffee#L49.\n * FileModel manages the loading\n * of a file and parsing both the content and the metadata (if any).\n * Once loaded, the content, metadata and file stat (file info)\n * properties of the FileModel are populated, as well\n * as a number of DocPad specific attributes and properties.\n * Typically we do not need to create FileModels ourselves as\n * DocPad handles all of that. But it is possible that a plugin\n * may need to manually create FileModels for some reason.\n *\n *\tattrs =\n *\t\tfullPath: 'file/path/to/somewhere'\n *\topts = {}\n *\t#we only really need the path to the source file to create\n *\t#a new file model\n *\tmodel = new FileModel(attrs, opts)\n *\n * The FileModel forms the base class for the DocPad DocumentModel class.\n * @class FileModel\n * @constructor\n * @extends Model\n */\n\nFileModel = (function(superClass) {\n  extend(FileModel, superClass);\n\n  function FileModel() {\n    this.action = bind(this.action, this);\n    return FileModel.__super__.constructor.apply(this, arguments);\n  }\n\n\n  /**\n  \t * The file model class. This should\n  \t * be overridden in any descending classes.\n  \t * @private\n  \t * @property {Object} klass\n   */\n\n  FileModel.prototype.klass = FileModel;\n\n\n  /**\n  \t * String name of the model type.\n  \t * In this case, 'file'. This should\n  \t * be overridden in any descending classes.\n  \t * @private\n  \t * @property {String} type\n   */\n\n  FileModel.prototype.type = 'file';\n\n\n  /**\n  \t * Task Group Class\n  \t * @private\n  \t * @property {Object} TaskGroup\n   */\n\n  FileModel.prototype.TaskGroup = null;\n\n\n  /**\n  \t * The out directory path to put the relative path.\n  \t * @property {String} rootOutDirPath\n   */\n\n  FileModel.prototype.rootOutDirPath = null;\n\n\n  /**\n  \t * Whether or not we should detect encoding\n  \t * @property {Boolean} detectEncoding\n   */\n\n  FileModel.prototype.detectEncoding = false;\n\n\n  /**\n  \t * Node.js file stat object.\n  \t * https://nodejs.org/api/fs.html#fs_class_fs_stats.\n  \t * Basically, information about a file, including file\n  \t * dates and size.\n  \t * @property {Object} stat\n   */\n\n  FileModel.prototype.stat = null;\n\n\n  /**\n  \t * File buffer. Node.js Buffer object.\n  \t * https://nodejs.org/api/buffer.html#buffer_class_buffer.\n  \t * Provides methods for dealing with binary data directly.\n  \t * @property {Object} buffer\n   */\n\n  FileModel.prototype.buffer = null;\n\n\n  /**\n  \t * Buffer time.\n  \t * @property {Object} bufferTime\n   */\n\n  FileModel.prototype.bufferTime = null;\n\n\n  /**\n  \t * The parsed file meta data (header).\n  \t * Is a Model instance.\n  \t * @private\n  \t * @property {Object} meta\n   */\n\n  FileModel.prototype.meta = null;\n\n\n  /**\n  \t * Locale information for the file\n  \t * @private\n  \t * @property {Object} locale\n   */\n\n  FileModel.prototype.locale = null;\n\n\n  /**\n  \t * Get the file's locale information\n  \t * @method getLocale\n  \t * @return {Object} the locale\n   */\n\n  FileModel.prototype.getLocale = function() {\n    return this.locale;\n  };\n\n\n  /**\n  \t * Get Options. Returns an object containing\n  \t * the properties detectEncoding, rootOutDirPath\n  \t * locale, stat, buffer, meta and TaskGroup.\n  \t * @private\n  \t * @method getOptions\n  \t * @return {Object}\n   */\n\n  FileModel.prototype.getOptions = function() {\n    return {\n      detectEncoding: this.detectEncoding,\n      rootOutDirPath: this.rootOutDirPath,\n      locale: this.locale,\n      stat: this.stat,\n      buffer: this.buffer,\n      meta: this.meta,\n      TaskGroup: this.TaskGroup\n    };\n  };\n\n\n  /**\n  \t * Checks whether the passed key is one\n  \t * of the options.\n  \t * @private\n  \t * @method isOption\n  \t * @param {String} key\n  \t * @return {Boolean}\n   */\n\n  FileModel.prototype.isOption = function(key) {\n    var names, result;\n    names = ['detectEncoding', 'rootOutDirPath', 'locale', 'stat', 'data', 'buffer', 'meta', 'TaskGroup'];\n    result = indexOf.call(names, key) >= 0;\n    return result;\n  };\n\n\n  /**\n  \t * Extract Options.\n  \t * @private\n  \t * @method extractOptions\n  \t * @param {Object} attrs\n  \t * @return {Object} the options object\n   */\n\n  FileModel.prototype.extractOptions = function(attrs) {\n    var key, result, value;\n    result = {};\n    for (key in attrs) {\n      if (!hasProp.call(attrs, key)) continue;\n      value = attrs[key];\n      if (this.isOption(key)) {\n        result[key] = value;\n        delete attrs[key];\n      }\n    }\n    return result;\n  };\n\n\n  /**\n  \t * Set the options for the file model.\n  \t * Valid properties for the attrs parameter:\n  \t * TaskGroup, detectEncoding, rootOutDirPath,\n  \t * locale, stat, data, buffer, meta.\n  \t * @method setOptions\n  \t * @param {Object} [attrs={}]\n   */\n\n  FileModel.prototype.setOptions = function(attrs) {\n    if (attrs == null) {\n      attrs = {};\n    }\n    if (attrs.TaskGroup != null) {\n      this.TaskGroup = attrs.TaskGroup;\n      delete this.attributes.TaskGroup;\n    }\n    if (attrs.detectEncoding != null) {\n      this.rootOutDirPath = attrs.detectEncoding;\n      delete this.attributes.detectEncoding;\n    }\n    if (attrs.rootOutDirPath != null) {\n      this.rootOutDirPath = attrs.rootOutDirPath;\n      delete this.attributes.rootOutDirPath;\n    }\n    if (attrs.locale != null) {\n      this.locale = attrs.locale;\n      delete this.attributes.locale;\n    }\n    if (attrs.stat != null) {\n      this.setStat(attrs.stat);\n      delete this.attributes.stat;\n    }\n    if (attrs.data != null) {\n      this.setBuffer(attrs.data);\n      delete this.attributes.data;\n    }\n    if (attrs.buffer != null) {\n      this.setBuffer(attrs.buffer);\n      delete this.attributes.buffer;\n    }\n    if (attrs.meta != null) {\n      this.setMeta(attrs.meta);\n      delete this.attributes.meta;\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Clone the model and return the newly cloned model.\n  \t * @method clone\n  \t * @return {Object} cloned file model\n   */\n\n  FileModel.prototype.clone = function() {\n    var attrs, clonedModel, opts;\n    attrs = this.getAttributes();\n    opts = this.getOptions();\n    delete attrs.id;\n    delete attrs.meta.id;\n    delete opts.meta.id;\n    delete opts.meta.attributes.id;\n    clonedModel = new this.klass(attrs, opts);\n    this.emit('clone', clonedModel);\n    return clonedModel;\n  };\n\n\n  /**\n  \t * The default attributes for any file model.\n  \t * @private\n  \t * @property {Object}\n   */\n\n  FileModel.prototype.defaults = {\n    id: null,\n    basename: null,\n    outBasename: null,\n    extension: null,\n    outExtension: null,\n    extensions: null,\n    filename: null,\n    fullPath: null,\n    fullDirPath: null,\n    outPath: null,\n    outDirPath: null,\n    outFilename: null,\n    relativePath: null,\n    relativeOutPath: null,\n    relativeDirPath: null,\n    relativeOutDirPath: null,\n    relativeBase: null,\n    relativeOutBase: null,\n    contentType: null,\n    outContentType: null,\n    ctime: null,\n    mtime: null,\n    rtime: null,\n    wtime: null,\n    exists: null,\n    encoding: null,\n    source: null,\n    content: null,\n    tags: null,\n    render: false,\n    write: true,\n    writeSource: false,\n    dynamic: false,\n    title: null,\n    name: null,\n    date: null,\n    slug: null,\n    url: null,\n    urls: null,\n    ignored: false,\n    standalone: false\n  };\n\n\n  /**\n  \t * File encoding helper\n  \t * opts = {path, to, from, content}\n  \t * @private\n  \t * @method encode\n  \t * @param {Object} opts\n  \t * @return {Object} encoded result\n   */\n\n  FileModel.prototype.encode = function(opts) {\n    var err, locale, result;\n    locale = this.getLocale();\n    result = opts.content;\n    if (opts.to == null) {\n      opts.to = 'utf8';\n    }\n    if (opts.from == null) {\n      opts.from = 'utf8';\n    }\n    try {\n      if (encodingUtil == null) {\n        encodingUtil = require('encoding');\n      }\n    } catch (error) {}\n    if (encodingUtil != null) {\n      this.log('info', util.format(locale.fileEncode, opts.to, opts.from, opts.path));\n      try {\n        result = encodingUtil.convert(opts.content, opts.to, opts.from);\n      } catch (error) {\n        err = error;\n        this.log('warn', util.format(locale.fileEncodeConvertError, opts.to, opts.from, opts.path));\n      }\n    } else {\n      this.log('warn', util.format(locale.fileEncodeConvertError, opts.to, opts.from, opts.path));\n    }\n    return result;\n  };\n\n\n  /**\n  \t * Set the file model's buffer.\n  \t * Creates a new node.js buffer\n  \t * object if a buffer object is\n  \t * is not passed as the parameter\n  \t * @method setBuffer\n  \t * @param {Object} [buffer]\n   */\n\n  FileModel.prototype.setBuffer = function(buffer) {\n    if (!Buffer.isBuffer(buffer)) {\n      buffer = new Buffer(buffer);\n    }\n    this.bufferTime = this.get('mtime') || new Date();\n    this.buffer = buffer;\n    return this;\n  };\n\n\n  /**\n  \t * Get the file model's buffer object.\n  \t * Returns a node.js buffer object.\n  \t * @method getBuffer\n  \t * @return {Object} node.js buffer object\n   */\n\n  FileModel.prototype.getBuffer = function() {\n    return this.buffer;\n  };\n\n\n  /**\n  \t * Is Buffer Outdated\n  \t * True if there is no buffer OR the buffer time is outdated\n  \t * @method isBufferOutdated\n  \t * @return {Boolean}\n   */\n\n  FileModel.prototype.isBufferOutdated = function() {\n    return (this.buffer != null) === false || this.bufferTime < (this.get('mtime') || new Date());\n  };\n\n\n  /**\n  \t * Set the node.js file stat.\n  \t * @method setStat\n  \t * @param {Object} stat\n   */\n\n  FileModel.prototype.setStat = function(stat) {\n    this.stat = stat;\n    this.set({\n      ctime: new Date(stat.ctime),\n      mtime: new Date(stat.mtime)\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Get the node.js file stat.\n  \t * @method getStat\n  \t * @return {Object} the file stat\n   */\n\n  FileModel.prototype.getStat = function() {\n    return this.stat;\n  };\n\n\n  /**\n  \t * Get the file model attributes.\n  \t * By default the attributes will be\n  \t * dereferenced from the file model.\n  \t * To maintain a reference, pass false\n  \t * as the parameter. The returned object\n  \t * will NOT contain the file model's ID attribute.\n  \t * @method getAttributes\n  \t * @param {Object} [dereference=true]\n  \t * @return {Object}\n   */\n\n  FileModel.prototype.getAttributes = function(dereference) {\n    var attrs;\n    if (dereference == null) {\n      dereference = true;\n    }\n    attrs = this.toJSON(dereference);\n    delete attrs.id;\n    return attrs;\n  };\n\n\n  /**\n  \t * Get the file model attributes.\n  \t * By default the attributes will\n  \t * maintain a reference to the file model.\n  \t * To return a dereferenced object, pass true\n  \t * as the parameter. The returned object\n  \t * will contain the file model's ID attribute.\n  \t * @method toJSON\n  \t * @param {Object} [dereference=false]\n  \t * @return {Object}\n   */\n\n  FileModel.prototype.toJSON = function(dereference) {\n    var data;\n    if (dereference == null) {\n      dereference = false;\n    }\n    data = FileModel.__super__.toJSON.apply(this, arguments);\n    data.meta = this.getMeta().toJSON();\n    if (dereference === true) {\n      data = extendr.dereference(data);\n    }\n    return data;\n  };\n\n\n  /**\n  \t * Get the file model metadata object.\n  \t * Optionally pass a list of metadata property\n  \t * names corresponding to those properties that\n  \t * you want returned.\n  \t * @method getMeta\n  \t * @param {Object} [args...]\n  \t * @return {Object}\n   */\n\n  FileModel.prototype.getMeta = function() {\n    var args, ref;\n    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    if (this.meta === null) {\n      this.meta = new Model();\n    }\n    if (args.length) {\n      return (ref = this.meta).get.apply(ref, args);\n    } else {\n      return this.meta;\n    }\n  };\n\n\n  /**\n  \t * Assign attributes and options to the file model.\n  \t * @method set\n  \t * @param {Array} attrs the attributes to be applied\n  \t * @param {Object} opts the options to be applied\n   */\n\n  FileModel.prototype.set = function(attrs, opts) {\n    var newAttrs, options, ref;\n    if (typeChecker.isString(attrs)) {\n      newAttrs = {};\n      newAttrs[attrs] = opts;\n      return this.set(newAttrs, opts);\n    }\n    attrs = (ref = typeof attrs.toJSON === \"function\" ? attrs.toJSON() : void 0) != null ? ref : attrs;\n    options = this.extractOptions(attrs);\n    FileModel.__super__.set.call(this, attrs, opts);\n    this.setOptions(options, opts);\n    return this;\n  };\n\n\n  /**\n  \t * Set defaults. Apply default attributes\n  \t * and options to the file model\n  \t * @method setDefaults\n  \t * @param {Object} attrs the attributes to be applied\n  \t * @param {Object} opts the options to be applied\n   */\n\n  FileModel.prototype.setDefaults = function(attrs, opts) {\n    var options, ref;\n    attrs = (ref = typeof attrs.toJSON === \"function\" ? attrs.toJSON() : void 0) != null ? ref : attrs;\n    options = this.extractOptions(attrs);\n    FileModel.__super__.setDefaults.call(this, attrs, opts);\n    this.setOptions(options, opts);\n    return this;\n  };\n\n\n  /**\n  \t * Set the file model meta data,\n  \t * attributes and options in one go.\n  \t * @method setMeta\n  \t * @param {Object} attrs the attributes to be applied\n  \t * @param {Object} opts the options to be applied\n   */\n\n  FileModel.prototype.setMeta = function(attrs, opts) {\n    var options, ref;\n    attrs = (ref = typeof attrs.toJSON === \"function\" ? attrs.toJSON() : void 0) != null ? ref : attrs;\n    options = this.extractOptions(attrs);\n    this.getMeta().set(attrs, opts);\n    this.set(attrs, opts);\n    this.setOptions(options, opts);\n    return this;\n  };\n\n\n  /**\n  \t * Set the file model meta data defaults\n  \t * @method setMetaDefaults\n  \t * @param {Object} attrs the attributes to be applied\n  \t * @param {Object} opts the options to be applied\n   */\n\n  FileModel.prototype.setMetaDefaults = function(attrs, opts) {\n    var options, ref;\n    attrs = (ref = typeof attrs.toJSON === \"function\" ? attrs.toJSON() : void 0) != null ? ref : attrs;\n    options = this.extractOptions(attrs);\n    this.getMeta().setDefaults(attrs, opts);\n    this.setDefaults(attrs, opts);\n    this.setOptions(options, opts);\n    return this;\n  };\n\n\n  /**\n  \t * Get the file name. Depending on the\n  \t * parameters passed this will either be\n  \t * the file model's filename property or,\n  \t * the filename determined from the fullPath\n  \t * or relativePath property. Valid values for\n  \t * the opts parameter are: fullPath, relativePath\n  \t * or filename. Format: {filename}\n  \t * @method getFilename\n  \t * @param {Object} [opts={}]\n  \t * @return {String}\n   */\n\n  FileModel.prototype.getFilename = function(opts) {\n    var filename, fullPath, relativePath, result;\n    if (opts == null) {\n      opts = {};\n    }\n    fullPath = opts.fullPath, relativePath = opts.relativePath, filename = opts.filename;\n    result = filename != null ? filename : this.get('filename');\n    if (!result) {\n      result = (fullPath != null ? fullPath : this.get('fullPath')) || (relativePath != null ? relativePath : this.get('relativePath'));\n      if (result) {\n        result = pathUtil.basename(result);\n      }\n    }\n    result || (result = null);\n    return result;\n  };\n\n\n  /**\n  \t * Get the file path. Depending on the\n  \t * parameters passed this will either be\n  \t * the file model's fullPath property, the\n  \t * relativePath property or the filename property.\n  \t * Valid values for the opts parameter are:\n  \t * fullPath, relativePath\n  \t * or filename. Format: {fullPath}\n  \t * @method getFilePath\n  \t * @param {Object} [opts={}]\n  \t * @return {String}\n   */\n\n  FileModel.prototype.getFilePath = function(opts) {\n    var filename, fullPath, relativePath, result;\n    if (opts == null) {\n      opts = {};\n    }\n    fullPath = opts.fullPath, relativePath = opts.relativePath, filename = opts.filename;\n    result = (fullPath != null ? fullPath : this.get('fullPath')) || (relativePath != null ? relativePath : this.get('relativePath')) || (filename != null ? filename : this.get('filename')) || null;\n    return result;\n  };\n\n\n  /**\n  \t * Get file extensions. Depending on the\n  \t * parameters passed this will either be\n  \t * the file model's extensions property or\n  \t * the extensions extracted from the file model's\n  \t * filename property. The opts parameter is passed\n  \t * in the format: {extensions,filename}.\n  \t * @method getExtensions\n  \t * @param {Object} opts\n  \t * @return {Array} array of extension names\n   */\n\n  FileModel.prototype.getExtensions = function(arg) {\n    var extensions, filename;\n    extensions = arg.extensions, filename = arg.filename;\n    extensions || (extensions = this.get('extensions') || null);\n    if ((extensions || []).length === 0) {\n      filename = this.getFilename({\n        filename: filename\n      });\n      if (filename) {\n        extensions = docpadUtil.getExtensions(filename);\n      }\n    }\n    return extensions || null;\n  };\n\n\n  /**\n  \t * Get the file content. This will be\n  \t * the text content if loaded or the file buffer object.\n  \t * @method getContent\n  \t * @return {String or Object}\n   */\n\n  FileModel.prototype.getContent = function() {\n    return this.get('content') || this.getBuffer();\n  };\n\n\n  /**\n  \t * Get the file content for output.\n  \t * @method getOutContent\n  \t * @return {String or Object}\n   */\n\n  FileModel.prototype.getOutContent = function() {\n    return this.getContent();\n  };\n\n\n  /**\n  \t * Is this a text file? ie - not\n  \t * a binary file.\n  \t * @method isText\n  \t * @return {Boolean}\n   */\n\n  FileModel.prototype.isText = function() {\n    return this.get('encoding') !== 'binary';\n  };\n\n\n  /**\n  \t * Is this a binary file?\n  \t * @method isBinary\n  \t * @return {Boolean}\n   */\n\n  FileModel.prototype.isBinary = function() {\n    return this.get('encoding') === 'binary';\n  };\n\n\n  /**\n  \t * Set the url for the file\n  \t * @method setUrl\n  \t * @param {String} url\n   */\n\n  FileModel.prototype.setUrl = function(url) {\n    this.addUrl(url);\n    this.set({\n      url: url\n    });\n    return this;\n  };\n\n\n  /**\n  \t * A file can have multiple urls.\n  \t * This method adds either a single url\n  \t * or an array of urls to the file model.\n  \t * @method addUrl\n  \t * @param {String or Array} url\n   */\n\n  FileModel.prototype.addUrl = function(url) {\n    var existingUrl, found, i, j, len, len1, newUrl, urls;\n    if (url instanceof Array) {\n      for (i = 0, len = url.length; i < len; i++) {\n        newUrl = url[i];\n        this.addUrl(newUrl);\n      }\n    } else if (url) {\n      found = false;\n      urls = this.get('urls');\n      for (j = 0, len1 = urls.length; j < len1; j++) {\n        existingUrl = urls[j];\n        if (existingUrl === url) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        urls.push(url);\n      }\n      this.trigger('change:urls', this, urls, {});\n      this.trigger('change', this, {});\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Removes a url from the file\n  \t * model (files can have more than one url).\n  \t * @method removeUrl\n  \t * @param {Object} userUrl the url to be removed\n   */\n\n  FileModel.prototype.removeUrl = function(userUrl) {\n    var i, index, len, url, urls;\n    urls = this.get('urls');\n    for (index = i = 0, len = urls.length; i < len; index = ++i) {\n      url = urls[index];\n      if (url === userUrl) {\n        urls.splice(index, 1);\n        break;\n      }\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Get a file path.\n  \t * If the relativePath parameter starts with `.` then we get the\n  \t * path in relation to the document that is calling it.\n  \t * Otherwise we just return it as normal\n  \t * @method getPath\n  \t * @param {String} relativePath\n  \t * @param {String} parentPath\n  \t * @return {String}\n   */\n\n  FileModel.prototype.getPath = function(relativePath, parentPath) {\n    var path, relativeDirPath;\n    if (/^\\./.test(relativePath)) {\n      relativeDirPath = this.get('relativeDirPath');\n      path = pathUtil.join(relativeDirPath, relativePath);\n    } else {\n      if (parentPath) {\n        path = pathUtil.join(parentPath, relativePath);\n      } else {\n        path = relativePath;\n      }\n    }\n    return path;\n  };\n\n\n  /**\n  \t * The action runner instance bound to DocPad\n  \t * @private\n  \t * @property {Object} actionRunnerInstance\n   */\n\n  FileModel.prototype.actionRunnerInstance = null;\n\n\n  /**\n  \t * Get the action runner instance bound to DocPad\n  \t * @method getActionRunner\n  \t * @return {Object}\n   */\n\n  FileModel.prototype.getActionRunner = function() {\n    return this.actionRunnerInstance;\n  };\n\n\n  /**\n  \t * Apply an action with the supplied arguments.\n  \t * @method action\n  \t * @param {Object} args...\n   */\n\n  FileModel.prototype.action = function() {\n    var args;\n    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return docpadUtil.action.apply(this, args);\n  };\n\n\n  /**\n  \t * Initialize the file model with the passed\n  \t * attributes and options. Emits the init event.\n  \t * @method initialize\n  \t * @param {Object} attrs the file model attributes\n  \t * @param {Object} [opts={}] the file model options\n   */\n\n  FileModel.prototype.initialize = function(attrs, opts) {\n    var base, base1, base2, base3, base4, file, now;\n    if (opts == null) {\n      opts = {};\n    }\n    file = this;\n    if (this.attributes == null) {\n      this.attributes = {};\n    }\n    if ((base = this.attributes).extensions == null) {\n      base.extensions = [];\n    }\n    if ((base1 = this.attributes).urls == null) {\n      base1.urls = [];\n    }\n    now = new Date();\n    if ((base2 = this.attributes).ctime == null) {\n      base2.ctime = now;\n    }\n    if ((base3 = this.attributes).mtime == null) {\n      base3.mtime = now;\n    }\n    if (this.id == null) {\n      this.id = (base4 = this.attributes).id != null ? base4.id : base4.id = this.cid;\n    }\n    this.setOptions(opts);\n    if ((this.rootOutDirPath != null) === false || (this.locale != null) === false) {\n      throw new Error(\"Use docpad.createModel to create the file or document model\");\n    }\n    this.actionRunnerInstance = new this.TaskGroup(\"file action runner\").whenDone(function(err) {\n      if (err) {\n        return file.emit('error', err);\n      }\n    });\n    this.emit('init');\n    return this;\n  };\n\n\n  /**\n  \t * Load the file from the file system.\n  \t * If the fullPath exists, load the file.\n  \t * If it doesn't, then parse and normalize the file.\n  \t * Optionally pass file options as a parameter.\n  \t * @method load\n  \t * @param {Object} [opts={}]\n  \t * @param {Function} next callback\n   */\n\n  FileModel.prototype.load = function(opts, next) {\n    var file, filePath, fullPath, ref, tasks;\n    if (opts == null) {\n      opts = {};\n    }\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    file = this;\n    if (opts.exists == null) {\n      opts.exists = null;\n    }\n    fullPath = this.get('fullPath');\n    filePath = this.getFilePath({\n      fullPath: fullPath\n    });\n    if (opts.exists != null) {\n      file.set({\n        exists: opts.exists\n      });\n    }\n    if (opts.stat != null) {\n      file.setStat(opts.stat);\n    }\n    if (opts.buffer != null) {\n      file.setBuffer(opts.buffer);\n    }\n    tasks = new this.TaskGroup(\"load tasks for file: \" + filePath, {\n      next: next\n    }).on('item.run', function(item) {\n      return file.log(\"debug\", (item.getConfig().name) + \": \" + file.type + \": \" + filePath);\n    });\n    tasks.addTask(\"Detect the file\", function(complete) {\n      if (fullPath && opts.exists === null) {\n        return safefs.exists(fullPath, function(exists) {\n          opts.exists = exists;\n          file.set({\n            exists: opts.exists\n          });\n          return complete();\n        });\n      } else {\n        return complete();\n      }\n    });\n    tasks.addTask(\"Stat the file and cache the result\", function(complete) {\n      if (fullPath && opts.exists && (opts.stat != null) === false) {\n        return safefs.stat(fullPath, function(err, fileStat) {\n          if (err) {\n            return complete(err);\n          }\n          file.setStat(fileStat);\n          return complete();\n        });\n      } else {\n        return complete();\n      }\n    });\n    tasks.addTask(\"Read the file and cache the result\", function(complete) {\n      if (fullPath && opts.exists && (opts.buffer != null) === false && file.isBufferOutdated()) {\n        return safefs.readFile(fullPath, function(err, buffer) {\n          if (err) {\n            return complete(err);\n          }\n          file.setBuffer(buffer);\n          return complete();\n        });\n      } else {\n        return complete();\n      }\n    });\n    tasks.addTask(\"Load -> Parse\", function(complete) {\n      return file.parse(complete);\n    });\n    tasks.addTask(\"Parse -> Normalize\", function(complete) {\n      return file.normalize(complete);\n    });\n    tasks.addTask(\"Normalize -> Contextualize\", function(complete) {\n      return file.contextualize(complete);\n    });\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Parse our buffer and extract meaningful data from it.\n  \t * next(err).\n  \t * @method parse\n  \t * @param {Object} [opts={}]\n  \t * @param {Object} next callback\n   */\n\n  FileModel.prototype.parse = function(opts, next) {\n    var buffer, changes, content, encoding, isText, ref, ref1, relativePath, source;\n    if (opts == null) {\n      opts = {};\n    }\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    buffer = this.getBuffer();\n    relativePath = this.get('relativePath');\n    encoding = opts.encoding || this.get('encoding') || null;\n    changes = {};\n    if (buffer && (encoding != null) === false || opts.reencode === true) {\n      isText = isTextOrBinary.isTextSync(relativePath, buffer);\n      if (isText === true) {\n        if (this.detectEncoding) {\n          if (jschardet == null) {\n            jschardet = require('jschardet');\n          }\n          if (encoding == null) {\n            encoding = (ref1 = jschardet.detect(buffer)) != null ? ref1.encoding : void 0;\n          }\n        }\n        encoding || (encoding = 'utf8');\n        if (docpadUtil.isStandardEncoding(encoding) === false) {\n          buffer = this.encode({\n            path: relativePath,\n            to: 'utf8',\n            from: encoding,\n            content: buffer\n          });\n        }\n        changes.encoding = encoding;\n      } else {\n        encoding = changes.encoding = 'binary';\n      }\n    }\n    if (encoding === 'binary') {\n      content = source = '';\n      changes.content = content;\n      changes.source = source;\n    } else {\n      if ((encoding != null) === false) {\n        encoding = changes.encoding = 'utf8';\n      }\n      source = (buffer != null ? buffer.toString('utf8') : void 0) || '';\n      content = source;\n      changes.content = content;\n      changes.source = source;\n    }\n    this.set(changes);\n    next();\n    return this;\n  };\n\n\n  /**\n  \t * Normalize any parsing we have done, because if a value has\n  \t * updates it may have consequences on another value.\n  \t * This will ensure everything is okay.\n  \t * next(err)\n  \t * @method normalize\n  \t * @param {Object} [opts={}]\n  \t * @param {Object} next callback\n   */\n\n  FileModel.prototype.normalize = function(opts, next) {\n    var _defaultUrl, basename, changes, contentType, ctime, date, err, extension, extensions, filename, fullDirPath, fullPath, locale, meta, mtime, name, outBasename, outContentType, outDirPath, outExtension, outFilename, outPath, ref, relativeBase, relativeDirPath, relativeOutBase, relativeOutDirPath, relativeOutPath, relativePath, rtime, slug, tags, url, wtime;\n    if (opts == null) {\n      opts = {};\n    }\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    changes = {};\n    meta = this.getMeta();\n    locale = this.getLocale();\n    filename = opts.filename || this.get('filename') || null;\n    relativePath = opts.relativePath || this.get('relativePath') || null;\n    fullPath = opts.fullPath || this.get('fullPath') || null;\n    mtime = opts.mtime || this.get('mtime') || null;\n    tags = opts.tags || meta.get('tags') || null;\n    date = opts.date || meta.get('date') || null;\n    name = opts.name || meta.get('name') || null;\n    slug = opts.slug || meta.get('slug') || null;\n    url = opts.url || meta.get('url') || null;\n    contentType = opts.contentType || meta.get('contentType') || null;\n    outContentType = opts.outContentType || meta.get('outContentType') || null;\n    outFilename = opts.outFilename || meta.get('outFilename') || null;\n    outExtension = opts.outExtension || meta.get('outExtension') || null;\n    outPath = opts.outPath || meta.get('outPath') || null;\n    extensions = null;\n    extension = null;\n    basename = null;\n    outBasename = null;\n    relativeOutPath = null;\n    relativeDirPath = null;\n    relativeOutDirPath = null;\n    relativeBase = null;\n    relativeOutBase = null;\n    outDirPath = null;\n    fullDirPath = null;\n    changes.filename = filename = this.getFilename({\n      filename: filename,\n      relativePath: relativePath,\n      fullPath: fullPath\n    });\n    if (!filename) {\n      err = new Error(locale.filenameMissingError);\n      return next(err);\n    }\n    if (!relativePath && filename) {\n      changes.relativePath = relativePath = filename;\n    }\n    changes.basename = basename = docpadUtil.getBasename(filename);\n    changes.extensions = extensions = this.getExtensions({\n      filename: filename\n    });\n    changes.extension = extension = docpadUtil.getExtension(extensions);\n    if (fullPath) {\n      changes.fullDirPath = fullDirPath = docpadUtil.getDirPath(fullPath);\n    }\n    changes.relativeDirPath = relativeDirPath = docpadUtil.getDirPath(relativePath);\n    changes.relativeBase = relativeBase = relativeDirPath ? pathUtil.join(relativeDirPath, basename) : basename;\n    if (!contentType) {\n      changes.contentType = contentType = mime.lookup(fullPath || relativePath);\n    }\n    if (tags && typeChecker.isArray(tags) === false) {\n      changes.tags = tags = String(tags).split(/[\\s,]+/);\n    }\n    if (!date) {\n      changes.date = date = mtime || this.get('date') || new Date();\n    }\n    if (!outFilename && !outPath) {\n      changes.outFilename = outFilename = docpadUtil.getOutFilename(basename, outExtension || extensions.join('.'));\n    }\n    if (!outPath) {\n      changes.outPath = outPath = this.rootOutDirPath ? pathUtil.resolve(this.rootOutDirPath, relativeDirPath, outFilename) : null;\n    }\n    if (outPath) {\n      changes.outFilename = outFilename = docpadUtil.getFilename(outPath);\n    }\n    changes.outDirPath = outDirPath = outPath ? docpadUtil.getDirPath(outPath) : null;\n    changes.outBasename = outBasename = docpadUtil.getBasename(outFilename);\n    changes.outExtension = outExtension = docpadUtil.getExtension(outFilename);\n    changes.relativeOutPath = relativeOutPath = outPath ? outPath.replace(this.rootOutDirPath, '').replace(/^[\\/\\\\]/, '') : pathUtil.join(relativeDirPath, outFilename);\n    changes.relativeOutDirPath = relativeOutDirPath = docpadUtil.getDirPath(relativeOutPath);\n    changes.relativeOutBase = relativeOutBase = pathUtil.join(relativeOutDirPath, outBasename);\n    if (!name) {\n      changes.name = name = outFilename;\n    }\n    _defaultUrl = docpadUtil.getUrl(relativeOutPath);\n    if (url) {\n      this.setUrl(url);\n      this.addUrl(_defaultUrl);\n    } else {\n      this.setUrl(_defaultUrl);\n    }\n    if (!outContentType && contentType) {\n      changes.outContentType = outContentType = mime.lookup(outPath || relativeOutPath) || contentType;\n    }\n    if (!slug) {\n      changes.slug = slug = docpadUtil.getSlug(relativeOutBase);\n    }\n    if (typeof wtime === 'string') {\n      changes.wtime = wtime = new Date(wtime);\n    }\n    if (typeof rtime === 'string') {\n      changes.rtime = rtime = new Date(rtime);\n    }\n    if (typeof ctime === 'string') {\n      changes.ctime = ctime = new Date(ctime);\n    }\n    if (typeof mtime === 'string') {\n      changes.mtime = mtime = new Date(mtime);\n    }\n    if (typeof date === 'string') {\n      changes.date = date = new Date(date);\n    }\n    this.set(changes);\n    next();\n    return this;\n  };\n\n\n  /**\n  \t * Contextualize the data. In other words,\n  \t * put our data into the perspective of the bigger picture of the data.\n  \t * For instance, generate the url for it's rendered equivalant.\n  \t * next(err)\n  \t * @method contextualize\n  \t * @param {Object} [opts={}]\n  \t * @param {Object} next callback\n   */\n\n  FileModel.prototype.contextualize = function(opts, next) {\n    var ref;\n    if (opts == null) {\n      opts = {};\n    }\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    next();\n    return this;\n  };\n\n\n  /**\n  \t * Render this file. The file model output content is\n  \t * returned to the passed callback in the\n  \t * result (2nd) parameter. The file model itself is returned\n  \t * in the callback's document (3rd) parameter.\n  \t * next(err,result,document)\n  \t * @method render\n  \t * @param {Object} [opts={}]\n  \t * @param {Object} next callback\n   */\n\n  FileModel.prototype.render = function(opts, next) {\n    var file, ref;\n    if (opts == null) {\n      opts = {};\n    }\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    file = this;\n    file.attributes.rtime = new Date();\n    next(null, file.getOutContent(), file);\n    return this;\n  };\n\n\n  /**\n  \t * Write the out file. The out file\n  \t * may be different from the input file.\n  \t * Often the input file is transformed in some way\n  \t * and saved as another file format. A common example\n  \t * is transforming a markdown input file to a HTML\n  \t * output file.\n  \t * next(err)\n  \t * @method write\n  \t * @param {Object} opts\n  \t * @param {Function} next callback\n   */\n\n  FileModel.prototype.write = function(opts, next) {\n    var file, locale, ref, ref1;\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    file = this;\n    locale = this.getLocale();\n    opts.path || (opts.path = file.get('outPath'));\n    opts.encoding || (opts.encoding = file.get('encoding') || 'utf8');\n    opts.content || (opts.content = file.getOutContent());\n    opts.type || (opts.type = 'out file');\n    if (!opts.path) {\n      next();\n      return this;\n    }\n    if ((ref1 = opts.encoding.toLowerCase()) !== 'ascii' && ref1 !== 'utf8' && ref1 !== 'utf-8' && ref1 !== 'binary') {\n      opts.content = this.encode({\n        path: opts.path,\n        to: opts.encoding,\n        from: 'utf8',\n        content: opts.content\n      });\n    }\n    file.log('debug', util.format(locale.fileWrite, opts.type, opts.path, opts.encoding));\n    safefs.writeFile(opts.path, opts.content, function(err) {\n      if (err) {\n        return next(err);\n      }\n      if (opts.type === 'out file') {\n        file.attributes.wtime = new Date();\n      }\n      file.log('debug', util.format(locale.fileWrote, opts.type, opts.path, opts.encoding));\n      return next();\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Write the source file. Optionally pass\n  \t * the opts parameter to modify or set the file's\n  \t * path, content or type.\n  \t * next(err)\n  \t * @method writeSource\n  \t * @param {Object} [opts]\n  \t * @param {Object} next callback\n   */\n\n  FileModel.prototype.writeSource = function(opts, next) {\n    var file, ref;\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    file = this;\n    opts.path || (opts.path = file.get('fullPath'));\n    opts.content || (opts.content = (file.getContent() || '').toString(''));\n    opts.type || (opts.type = 'source file');\n    this.write(opts, next);\n    return this;\n  };\n\n\n  /**\n  \t * Delete the out file, perhaps ahead of regeneration.\n  \t * Optionally pass the opts parameter to set the file path or type.\n  \t * next(err)\n  \t * @method delete\n  \t * @param {Object} [opts]\n  \t * @param {Object} next callback\n   */\n\n  FileModel.prototype['delete'] = function(opts, next) {\n    var file, locale, ref;\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    file = this;\n    locale = this.getLocale();\n    opts.path || (opts.path = file.get('outPath'));\n    opts.type || (opts.type = 'out file');\n    if (!opts.path) {\n      next();\n      return this;\n    }\n    file.log('debug', util.format(locale.fileDelete, opts.type, opts.path));\n    safefs.exists(opts.path, function(exists) {\n      if (!exists) {\n        return next();\n      }\n      return safefs.unlink(opts.path, function(err) {\n        if (err) {\n          return next(err);\n        }\n        file.log('debug', util.format(locale.fileDeleted, opts.type, opts.path));\n        return next();\n      });\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Delete the source file.\n  \t * Optionally pass the opts parameter to set the file path or type.\n  \t * next(err)\n  \t * @method deleteSource\n  \t * @param {Object} [opts]\n  \t * @param {Object} next callback\n   */\n\n  FileModel.prototype.deleteSource = function(opts, next) {\n    var file, ref;\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    file = this;\n    opts.path || (opts.path = file.get('fullPath'));\n    opts.type || (opts.type = 'source file');\n    this[\"delete\"](opts, next);\n    return this;\n  };\n\n  return FileModel;\n\n})(Model);\n\nmodule.exports = FileModel;\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/lib/models/document.js":"// Generated by CoffeeScript 1.12.4\nvar CSON, DocumentModel, FileModel, TaskGroup, YAML, docpadUtil, eachr, extendr, extractOptsAndCallback, pathUtil, util,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nutil = require('util');\n\npathUtil = require('path');\n\ndocpadUtil = require('../util');\n\nCSON = require('cson');\n\nextendr = require('extendr');\n\neachr = require('eachr');\n\nTaskGroup = require('taskgroup').TaskGroup;\n\nextractOptsAndCallback = require('extract-opts');\n\nFileModel = require('./file');\n\nYAML = null;\n\n\n/**\n * The DocumentModel class is DocPad's representation\n * of a website or project's content files. This can be\n * individual web pages or blog posts etc. Generally, this\n * is not other website files such as css files, images, or scripts -\n * unless there is a requirement to have DocPad do transformation on\n * these files.\n * Extends the DocPad FileModel class\n * https://github.com/docpad/docpad/blob/master/src/lib/models/file.coffee\n * DocumentModel primarily handles the rendering and parsing of document files.\n * This includes merging the document with layouts and managing the rendering\n * from one file extension to another. The class inherits many of the file\n * specific operations and DocPad specific attributes from the FileModel class.\n * However, it also overrides some parsing and file output operations contained\n * in the FileModel class.\n *\n * Typically we do not need to create DocumentModels ourselves as DocPad handles\n * all of that. Most of the time when we encounter DocumentModels is when\n * querying DocPad's document collections either in the docpad.coffee file or\n * from within a template.\n *\n * \tindexDoc = @getCollection('documents').findOne({relativeOutPath: 'index.html'})\n *\n * A plugin, however, may need to create a DocumentModel depending on its requirements.\n * In such a case it is wise to use the built in DocPad methods to do so, in particular\n * docpad.createModel\n *\n * \t#check to see if the document alread exists ie its an update\n * \tdocModel = @docpad.getCollection('posts').findOne({slug: 'some-slug'})\n *\n * \t#if so, load the existing document ready for regeneration\n * \tif docModel\n * \t\tdocModel.load()\n * \telse\n * \t\t#if document doesn't already exist, create it and add to database\n * \t\tdocModel = @docpad.createModel({fullPath:'file/path/to/somewhere'})\n * \t\tdocModel.load()\n * \t\t@docpad.getDatabase().add(docModel)\n *\n * @class DocumentModel\n * @constructor\n * @extends FileModel\n */\n\nDocumentModel = (function(superClass) {\n  extend(DocumentModel, superClass);\n\n  function DocumentModel() {\n    return DocumentModel.__super__.constructor.apply(this, arguments);\n  }\n\n\n  /**\n  \t * The document model class.\n  \t * @private\n  \t * @property {Object} klass\n   */\n\n  DocumentModel.prototype.klass = DocumentModel;\n\n\n  /**\n  \t * String name of the model type.\n  \t * In this case, 'document'.\n  \t * @private\n  \t * @property {String} type\n   */\n\n  DocumentModel.prototype.type = 'document';\n\n\n  /**\n  \t * The default attributes for any document model.\n  \t * @private\n  \t * @property {Object}\n   */\n\n  DocumentModel.prototype.defaults = extendr.extend({}, FileModel.prototype.defaults, {\n    referencesOthers: false,\n    header: null,\n    parser: null,\n    body: null,\n    rendered: false,\n    contentRendered: null,\n    contentRenderedWithoutLayouts: null,\n    render: true,\n    renderSingleExtensions: false\n  });\n\n\n  /**\n  \t * Get the file content for output. This\n  \t * will be the text content AFTER it has\n  \t * been through the rendering process. If\n  \t * this has been called before the rendering\n  \t * process, then the raw text content will be returned,\n  \t * or, if early enough in the process, the file buffer object.\n  \t * @method getOutContent\n  \t * @return {String or Object}\n   */\n\n  DocumentModel.prototype.getOutContent = function() {\n    var content;\n    content = this.get('contentRendered') || this.getContent();\n    return content;\n  };\n\n\n  /**\n  \t * Set flag to indicate if the document\n  \t * contains references to other documents.\n  \t * Used in the rendering process to decide\n  \t * on whether to render this document when\n  \t * another document is updated.\n  \t * @method referencesOthers\n  \t * @param {Boolean} [flag=true]\n   */\n\n  DocumentModel.prototype.referencesOthers = function(flag) {\n    if (flag == null) {\n      flag = true;\n    }\n    this.set({\n      referencesOthers: flag\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Parse our buffer and extract meaningful data from it.\n  \t * next(err).\n  \t * @method parse\n  \t * @param {Object} [opts={}]\n  \t * @param {Object} next callback\n   */\n\n  DocumentModel.prototype.parse = function(opts, next) {\n    var buffer, filePath, locale, ref;\n    if (opts == null) {\n      opts = {};\n    }\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    buffer = this.getBuffer();\n    locale = this.getLocale();\n    filePath = this.getFilePath();\n    DocumentModel.__super__.parse.call(this, opts, (function(_this) {\n      return function() {\n        var body, content, csonOptions, err, header, i, j, key, len, len1, match, meta, metaDataChanges, metaParseResult, parser, ref1, ref2, ref3, ref4, regex, seperator;\n        meta = _this.getMeta();\n        metaDataChanges = {};\n        parser = header = body = content = null;\n        content = _this.get('content').replace(/\\r\\n?/gm, '\\n');\n        regex = /^\\s*[^\\n]*?(([^\\s\\d\\w])\\2{2,})(?:\\x20*([a-z]+))?([\\s\\S]*?)[^\\n]*?\\1[^\\n]*/;\n        match = regex.exec(content);\n        if (match) {\n          seperator = match[1];\n          parser = match[3] || 'yaml';\n          header = match[4].trim();\n          body = content.substring(match[0].length).trim();\n          try {\n            switch (parser) {\n              case 'cson':\n              case 'json':\n              case 'coffee':\n              case 'coffeescript':\n              case 'coffee-script':\n              case 'js':\n              case 'javascript':\n                switch (parser) {\n                  case 'coffee':\n                  case 'coffeescript':\n                  case 'coffee-script':\n                    parser = 'coffeescript';\n                    break;\n                  case 'js':\n                  case 'javascript':\n                    parser = 'javascript';\n                }\n                csonOptions = {\n                  format: parser,\n                  json: true,\n                  cson: true,\n                  coffeescript: true,\n                  javascript: true\n                };\n                metaParseResult = CSON.parseString(header, csonOptions);\n                if (metaParseResult instanceof Error) {\n                  metaParseResult.context = \"Failed to parse \" + parser + \" meta header for the file: \" + filePath;\n                  return next(metaParseResult);\n                }\n                extendr.extend(metaDataChanges, metaParseResult);\n                break;\n              case 'yaml':\n                if (!YAML) {\n                  YAML = require('yamljs');\n                }\n                metaParseResult = YAML.parse(header.replace(/\\t/g, '    '));\n                extendr.extend(metaDataChanges, metaParseResult);\n                break;\n              default:\n                err = new Error(util.format(locale.documentMissingParserError, parser, filePath));\n                return next(err);\n            }\n          } catch (error) {\n            err = error;\n            err.context = util.format(locale.documentParserError, parser, filePath);\n            return next(err);\n          }\n        } else {\n          body = content;\n        }\n        if (metaDataChanges.encoding && metaDataChanges.encoding !== _this.get('encoding')) {\n          _this.set({\n            encoding: metaDataChanges.encoding\n          });\n          opts.reencode = true;\n          return _this.parse(opts, next);\n        }\n        body = body.replace(/^\\n+/, '');\n        _this.set({\n          source: content,\n          content: body,\n          header: header,\n          body: body,\n          parser: parser,\n          name: _this.get('name') || _this.get('title') || _this.get('basename')\n        });\n        if (metaDataChanges.date) {\n          metaDataChanges.date = new Date(metaDataChanges.date);\n        }\n        ref1 = ['ignore', 'skip', 'draft'];\n        for (i = 0, len = ref1.length; i < len; i++) {\n          key = ref1[i];\n          if (metaDataChanges[key] != null) {\n            metaDataChanges.ignored = (ref2 = metaDataChanges[key]) != null ? ref2 : false;\n            delete metaDataChanges[key];\n          }\n        }\n        ref3 = ['published'];\n        for (j = 0, len1 = ref3.length; j < len1; j++) {\n          key = ref3[j];\n          if (metaDataChanges[key] != null) {\n            metaDataChanges.ignored = !((ref4 = metaDataChanges[key]) != null ? ref4 : false);\n            delete metaDataChanges[key];\n          }\n        }\n        if (metaDataChanges.urls) {\n          _this.addUrl(metaDataChanges.urls);\n        }\n        if (metaDataChanges.url) {\n          _this.setUrl(metaDataChanges.url);\n        }\n        if (metaDataChanges.id != null) {\n          _this.log('warn', util.format(locale.documentIdChangeError, filePath));\n          delete metaDataChanges.id;\n        }\n        _this.setMeta(metaDataChanges);\n        return next();\n      };\n    })(this));\n    return this;\n  };\n\n\n  /**\n  \t * Normalize any parsing we have done, because if a value has\n  \t * updates it may have consequences on another value.\n  \t * This will ensure everything is okay.\n  \t * next(err)\n  \t * @method normalize\n  \t * @param {Object} [opts={}]\n  \t * @param {Object} next callback\n   */\n\n  DocumentModel.prototype.normalize = function(opts, next) {\n    var changes, extensions, filename, meta, outExtension, ref;\n    if (opts == null) {\n      opts = {};\n    }\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    changes = {};\n    meta = this.getMeta();\n    outExtension = opts.outExtension || meta.get('outExtension') || null;\n    filename = opts.filename || this.get('filename') || null;\n    extensions = this.getExtensions({\n      filename: filename\n    }) || null;\n    if (!outExtension) {\n      changes.outExtension = outExtension = extensions[0] || null;\n    }\n    DocumentModel.__super__.normalize.call(this, extendr.extend(opts, changes), next);\n    return this;\n  };\n\n\n  /**\n  \t * Contextualize the data. In other words,\n  \t * put our data into the perspective of the bigger picture of the data.\n  \t * For instance, generate the url for it's rendered equivalant.\n  \t * next(err)\n  \t * @method contextualize\n  \t * @param {Object} [opts={}]\n  \t * @param {Object} next callback\n   */\n\n  DocumentModel.prototype.contextualize = function(opts, next) {\n    var ref;\n    if (opts == null) {\n      opts = {};\n    }\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    this.getEve((function(_this) {\n      return function(err, eve) {\n        var changes, extensions, meta, outExtension, outFilename, outPath;\n        if (err) {\n          return next(err);\n        }\n        changes = {};\n        meta = _this.getMeta();\n        outFilename = opts.outFilename || meta.get('outFilename') || null;\n        outPath = opts.outPath || meta.get('outPath') || null;\n        outExtension = opts.outExtension || meta.get('outExtension') || null;\n        extensions = _this.getExtensions({\n          filename: outFilename\n        }) || null;\n        if (!outExtension) {\n          if (!outFilename && !outPath) {\n            if (eve != null) {\n              changes.outExtension = outExtension = eve.get('outExtension') || extensions[0] || null;\n            } else {\n              changes.outExtension = extensions[0] || null;\n            }\n          }\n        }\n        return _this.normalize(extendr.extend(opts, changes), next);\n      };\n    })(this));\n    return this;\n  };\n\n\n  /**\n  \t * Checks if the file has a layout.\n  \t * @method hasLayout\n  \t * @return {Boolean}\n   */\n\n  DocumentModel.prototype.hasLayout = function() {\n    return this.get('layout') != null;\n  };\n\n\n  /**\n  \t * Get the layout object that this file references (if any).\n  \t * We update the layoutRelativePath as it is\n  \t * used for finding what documents are used by a\n  \t * layout for when a layout changes.\n  \t * next(err, layout)\n  \t * @method getLayout\n  \t * @param {Function} next callback\n   */\n\n  DocumentModel.prototype.getLayout = function(next) {\n    var file, layoutSelector;\n    file = this;\n    layoutSelector = this.get('layout');\n    if (!layoutSelector) {\n      return next(null, null);\n    }\n    this.emit('getLayout', {\n      selector: layoutSelector\n    }, function(err, opts) {\n      var layout;\n      layout = opts.layout;\n      if (err) {\n        file.set({\n          'layoutRelativePath': null\n        });\n        return next(err);\n      } else if (!layout) {\n        file.set({\n          'layoutRelativePath': null\n        });\n        return next();\n      } else {\n        file.set({\n          'layoutRelativePath': layout.get('relativePath')\n        });\n        return next(null, layout);\n      }\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Get the most ancestoral (root) layout we\n  \t * have - ie, the very top one. Often this\n  \t * will be the base or default layout for\n  \t * a project. The layout where the head and other\n  \t * html on all pages is defined. In some projects,\n  \t * however, there may be more than one root layout\n  \t * so we can't assume there will always only be one.\n  \t * This is used by the contextualize method to determine\n  \t * the output extension of the document. In other words\n  \t * the document's final output extension is determined by\n  \t * the root layout.\n  \t * next(err,layout)\n  \t * @method getEve\n  \t * @param {Function} next\n   */\n\n  DocumentModel.prototype.getEve = function(next) {\n    if (this.hasLayout()) {\n      this.getLayout(function(err, layout) {\n        if (err) {\n          return next(err, null);\n        } else if (layout) {\n          return layout.getEve(next);\n        } else {\n          return next(null, null);\n        }\n      });\n    } else {\n      next(null, this);\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Renders one extension to another depending\n  \t * on the document model's extensions property.\n  \t * Triggers the render event for each extension conversion.\n  \t * This is the point where the various templating systems listen\n  \t * for their extension and perform their conversions.\n  \t * Common extension conversion is from md to html.\n  \t * So the document source file maybe index.md.html.\n  \t * This will be a markdown file to be converted to HTML.\n  \t * However, documents can be rendered through more than\n  \t * one conversion. Index.html.md.eco will be rendered from\n  \t * eco to md and then from md to html. Two conversions.\n  \t * next(err,result)\n  \t * @private\n  \t * @method renderExtensions\n  \t * @param {Object} opts\n  \t * @param {Function} next callback\n   */\n\n  DocumentModel.prototype.renderExtensions = function(opts, next) {\n    var content, extension, extensions, extensionsReversed, file, filePath, filename, i, len, locale, ref, renderSingleExtensions, result, tasks, templateData;\n    file = this;\n    locale = this.getLocale();\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    content = opts.content, templateData = opts.templateData, renderSingleExtensions = opts.renderSingleExtensions;\n    extensions = this.get('extensions');\n    filename = this.get('filename');\n    filePath = this.getFilePath();\n    if (content == null) {\n      content = this.get('body');\n    }\n    if (templateData == null) {\n      templateData = {};\n    }\n    if (renderSingleExtensions == null) {\n      renderSingleExtensions = this.get('renderSingleExtensions');\n    }\n    result = content;\n    extensionsReversed = [];\n    if (extensions.length === 0 && filename) {\n      extensionsReversed.push(filename);\n    }\n    for (i = 0, len = extensions.length; i < len; i++) {\n      extension = extensions[i];\n      extensionsReversed.unshift(extension);\n    }\n    if (renderSingleExtensions && extensionsReversed.length === 1) {\n      if (renderSingleExtensions !== 'auto' || filename.replace(/^\\./, '') === extensionsReversed[0]) {\n        extensionsReversed.push(null);\n      }\n    }\n    if (extensionsReversed.length <= 1) {\n      return next(null, result);\n    }\n    tasks = new this.TaskGroup(\"renderExtensions: \" + filePath, {\n      next: function(err) {\n        return next(err, result);\n      }\n    });\n    eachr(extensionsReversed.slice(1), function(extension, index) {\n      return tasks.addTask(\"renderExtension: \" + filePath + \" [\" + extensionsReversed[index] + \" => \" + extension + \"]\", function(complete) {\n        var eventData;\n        eventData = {\n          inExtension: extensionsReversed[index],\n          outExtension: extension,\n          templateData: templateData,\n          file: file,\n          content: result\n        };\n        return file.trigger('render', eventData, function(err) {\n          if (err) {\n            return complete(err);\n          }\n          if (result && (result === eventData.content)) {\n            file.log('warn', util.format(locale.documentRenderExtensionNoChange, eventData.inExtension, eventData.outExtension, filePath));\n            return complete();\n          }\n          result = eventData.content;\n          return complete();\n        });\n      });\n    });\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Triggers the renderDocument event after\n  \t * all extensions have been rendered. Listeners\n  \t * can use this event to perform transformations\n  \t * on the already rendered content.\n  \t * @private\n  \t * @method renderDocument\n  \t * @param {Object} opts\n  \t * @param {Function} next callback\n   */\n\n  DocumentModel.prototype.renderDocument = function(opts, next) {\n    var content, eventData, extension, file, ref, templateData;\n    file = this;\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    content = opts.content, templateData = opts.templateData;\n    extension = this.get('extensions')[0];\n    if (content == null) {\n      content = this.get('body');\n    }\n    if (templateData == null) {\n      templateData = {};\n    }\n    eventData = {\n      extension: extension,\n      templateData: templateData,\n      file: file,\n      content: content\n    };\n    file.trigger('renderDocument', eventData, function(err) {\n      return next(err, eventData.content);\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Render and merge layout content. Merge\n  \t * layout metadata with document metadata.\n  \t * Return the resulting merged content to\n  \t * the callback result parameter.\n  \t * next(err,result)\n  \t * @private\n  \t * @method renderLayouts\n  \t * @param {Object} opts\n  \t * @param {Function} next callback\n   */\n\n  DocumentModel.prototype.renderLayouts = function(opts, next) {\n    var content, file, filePath, locale, ref, templateData;\n    file = this;\n    locale = this.getLocale();\n    filePath = this.getFilePath();\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    content = opts.content, templateData = opts.templateData;\n    if (content == null) {\n      content = this.get('body');\n    }\n    if (templateData == null) {\n      templateData = {};\n    }\n    return file.getLayout(function(err, layout) {\n      var layoutSelector;\n      if (err) {\n        return next(err, content);\n      }\n      if (layout) {\n        templateData.content = content;\n        return layout.clone().action('render', {\n          templateData: templateData\n        }, function(err, result) {\n          return next(err, result);\n        });\n      } else if (file.hasLayout()) {\n        layoutSelector = file.get('layout');\n        err = new Error(util.format(locale.documentMissingLayoutError, layoutSelector, filePath));\n        return next(err, content);\n      } else {\n        return next(null, content);\n      }\n    });\n  };\n\n\n  /**\n  \t * Triggers the render process for this document.\n  \t * Calls the renderExtensions, renderDocument and\n  \t * renderLayouts methods in sequence. This is the\n  \t * method you want to call if you want to trigger\n  \t * the rendering of a document manually.\n  \t *\n  \t * The rendered content is returned as the result\n  \t * parameter to the passed callback and the DocumentModel\n  \t * instance is returned in the document parameter.\n  \t * next(err,result,document)\n  \t * @method render\n  \t * @param {Object} [opts={}]\n  \t * @param {Function} next callback\n   */\n\n  DocumentModel.prototype.render = function(opts, next) {\n    var base, base1, contentRenderedWithoutLayouts, err, file, filePath, key, locale, ref, ref1, relativePath, tasks, value;\n    if (opts == null) {\n      opts = {};\n    }\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    file = this;\n    locale = this.getLocale();\n    contentRenderedWithoutLayouts = null;\n    filePath = this.getFilePath();\n    relativePath = file.get('relativePath');\n    opts = extendr.clone(opts || {});\n    if (opts.actions == null) {\n      opts.actions = ['renderExtensions', 'renderDocument', 'renderLayouts'];\n    }\n    if (opts.apply != null) {\n      err = new Error(locale.documentApplyError);\n      return next(err);\n    }\n    if (opts.content == null) {\n      opts.content = file.get('body');\n    }\n    opts.templateData = extendr.clone(opts.templateData || {});\n    if ((base = opts.templateData).document == null) {\n      base.document = file.toJSON();\n    }\n    if ((base1 = opts.templateData).documentModel == null) {\n      base1.documentModel = file;\n    }\n    ref1 = opts.templateData;\n    for (key in ref1) {\n      if (!hasProp.call(ref1, key)) continue;\n      value = ref1[key];\n      if ((value != null ? value.bind : void 0) === Function.prototype.bind) {\n        opts.templateData[key] = value.bind(opts.templateData);\n      }\n    }\n    file.log('debug', util.format(locale.documentRender, filePath));\n    tasks = new this.TaskGroup(\"render tasks for: \" + relativePath, {\n      next: function(err) {\n        var contentRendered, rendered;\n        if (err) {\n          err.context = util.format(locale.documentRenderError, filePath);\n          return next(err, opts.content, file);\n        }\n        contentRendered = opts.content;\n        if (contentRenderedWithoutLayouts == null) {\n          contentRenderedWithoutLayouts = contentRendered;\n        }\n        rendered = true;\n        file.set({\n          contentRendered: contentRendered,\n          contentRenderedWithoutLayouts: contentRenderedWithoutLayouts,\n          rendered: rendered\n        });\n        file.log('debug', util.format(locale.documentRendered, filePath));\n        file.attributes.rtime = new Date();\n        return next(null, opts.content, file);\n      }\n    });\n    if (indexOf.call(opts.actions, 'renderExtensions') >= 0) {\n      tasks.addTask(\"renderExtensions: \" + relativePath, function(complete) {\n        return file.renderExtensions(opts, function(err, result) {\n          if (err) {\n            return complete(err);\n          }\n          opts.content = result;\n          return complete();\n        });\n      });\n    }\n    if (indexOf.call(opts.actions, 'renderDocument') >= 0) {\n      tasks.addTask(\"renderDocument: \" + relativePath, function(complete) {\n        return file.renderDocument(opts, function(err, result) {\n          if (err) {\n            return complete(err);\n          }\n          opts.content = result;\n          contentRenderedWithoutLayouts = result;\n          return complete();\n        });\n      });\n    }\n    if (indexOf.call(opts.actions, 'renderLayouts') >= 0) {\n      tasks.addTask(\"renderLayouts: \" + relativePath, function(complete) {\n        return file.renderLayouts(opts, function(err, result) {\n          if (err) {\n            return complete(err);\n          }\n          opts.content = result;\n          return complete();\n        });\n      });\n    }\n    tasks.run();\n    return this;\n  };\n\n\n  /**\n  \t * Write the source file. Optionally pass\n  \t * the opts parameter to modify or set the file's\n  \t * path, content or type.\n  \t * next(err)\n  \t * @method writeSource\n  \t * @param {Object} [opts]\n  \t * @param {Object} next callback\n   */\n\n  DocumentModel.prototype.writeSource = function(opts, next) {\n    var body, content, file, filePath, header, metaData, parser, ref, seperator, source;\n    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];\n    file = this;\n    filePath = this.getFilePath();\n    if (opts.content == null) {\n      opts.content = (this.getContent() || '').toString('');\n    }\n    metaData = this.getMeta().toJSON(true);\n    delete metaData.writeSource;\n    content = body = opts.content.replace(/^\\s+/, '');\n    header = CSON.stringify(metaData);\n    if (header instanceof Error) {\n      header.context = \"Failed to write CSON meta header for the file: \" + filePath;\n      return next(header);\n    }\n    if (!header || header === '{}') {\n      source = body;\n    } else {\n      parser = 'cson';\n      seperator = '###';\n      source = seperator + \" \" + parser + \"\\n\" + header + \"\\n\" + seperator + \"\\n\\n\" + body;\n    }\n    opts.content = source;\n    DocumentModel.__super__.writeSource.call(this, opts, next);\n    return this;\n  };\n\n  return DocumentModel;\n\n})(FileModel);\n\nmodule.exports = DocumentModel;\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/lib/collections/files.js":"// Generated by CoffeeScript 1.12.4\nvar FileModel, FilesCollection, Model, QueryCollection, pathUtil, ref,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\npathUtil = require('path');\n\nref = require('../base'), QueryCollection = ref.QueryCollection, Model = ref.Model;\n\nFileModel = require('../models/file');\n\n\n/**\n * The DocPad files and documents query collection class\n * Extends the DocPad QueryCollection class\n * https://github.com/docpad/docpad/blob/master/src/lib/base.coffee#L91\n * Used as the query collection class for DocPad files and documents.\n * This differs from standard collections in that it provides backbone.js,\n * noSQL style methods for querying the file system. In DocPad this\n * is the various files that make up a web project. Typically this is the documents,\n * css, script and image files.\n *\n * Most often a developer will use this class to find (and possibly sort) documents,\n * such as blog posts, by some criteria.\n * \tposts: ->\n * \t\t@getCollection('documents').findAllLive({relativeOutDirPath: 'posts'},[{date:-1}])\n * @class FilesCollection\n * @constructor\n * @extends QueryCollection\n */\n\nFilesCollection = (function(superClass) {\n  extend(FilesCollection, superClass);\n\n  function FilesCollection() {\n    return FilesCollection.__super__.constructor.apply(this, arguments);\n  }\n\n\n  /**\n  \t * Base Model for all items in this collection\n  \t * @private\n  \t * @property {Object} model\n   */\n\n  FilesCollection.prototype.model = FileModel;\n\n\n  /**\n  \t * Base Collection for all child collections\n  \t * @private\n  \t * @property {Object} collection\n   */\n\n  FilesCollection.prototype.collection = FilesCollection;\n\n\n  /**\n  \t * Initialize the collection\n  \t * @private\n  \t * @method initialize\n  \t * @param {Object} attrs\n  \t * @param {Object} [opts={}]\n   */\n\n  FilesCollection.prototype.initialize = function(attrs, opts) {\n    var base;\n    if (opts == null) {\n      opts = {};\n    }\n    if (this.options == null) {\n      this.options = {};\n    }\n    if ((base = this.options).name == null) {\n      base.name = opts.name || null;\n    }\n    return FilesCollection.__super__.initialize.apply(this, arguments);\n  };\n\n\n  /**\n  \t * Fuzzy find one\n  \t * Useful for layout searching\n  \t * @method fuzzyFindOne\n  \t * @param {Object} data\n  \t * @param {Object} sorting\n  \t * @param {Object} paging\n  \t * @return {Object} the file, if found\n   */\n\n  FilesCollection.prototype.fuzzyFindOne = function(data, sorting, paging) {\n    var escapedData, file, i, len, queries, query;\n    escapedData = data != null ? data.replace(/[\\/]/g, pathUtil.sep) : void 0;\n    queries = [\n      {\n        relativePath: escapedData\n      }, {\n        relativeBase: escapedData\n      }, {\n        url: data\n      }, {\n        relativePath: {\n          $startsWith: escapedData\n        }\n      }, {\n        fullPath: {\n          $startsWith: escapedData\n        }\n      }, {\n        url: {\n          $startsWith: data\n        }\n      }\n    ];\n    for (i = 0, len = queries.length; i < len; i++) {\n      query = queries[i];\n      file = this.findOne(query, sorting, paging);\n      if (file) {\n        return file;\n      }\n    }\n    return null;\n  };\n\n  return FilesCollection;\n\n})(QueryCollection);\n\nmodule.exports = FilesCollection;\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/lib/collections/elements.js":"// Generated by CoffeeScript 1.12.4\nvar Collection, ElementsCollection, Model, ref, typeChecker,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\ntypeChecker = require('typechecker');\n\nref = require('../base'), Collection = ref.Collection, Model = ref.Model;\n\n\n/**\n * Base class for the DocPad Elements Collection object\n * Extends the DocPad collection class\n * https://github.com/docpad/docpad/blob/master/src/lib/base.coffee#L72\n * Used as the base collection class for specific collection of file types.\n * In particular metadata, scripts and styles.\n * @class ElementsCollection\n * @constructor\n * @extends Collection\n */\n\nElementsCollection = (function(superClass) {\n  extend(ElementsCollection, superClass);\n\n  function ElementsCollection() {\n    return ElementsCollection.__super__.constructor.apply(this, arguments);\n  }\n\n\n  /**\n  \t * Base Model for all items in this collection\n  \t * @property {Object} model\n   */\n\n  ElementsCollection.prototype.model = Model;\n\n\n  /**\n  \t * Add an element to the collection.\n  \t * Right now we just support strings.\n  \t * @method add\n  \t * @param {Array} values string array of values\n  \t * @param {Object} opts\n   */\n\n  ElementsCollection.prototype.add = function(values, opts) {\n    var i, key, len, value;\n    if (typeChecker.isArray(values)) {\n      values = values.slice();\n    } else if (values) {\n      values = [values];\n    } else {\n      values = [];\n    }\n    for (key = i = 0, len = values.length; i < len; key = ++i) {\n      value = values[key];\n      if (typeChecker.isString(value)) {\n        values[key] = new Model({\n          html: value\n        });\n      }\n    }\n    ElementsCollection.__super__.add.call(this, values, opts);\n    return this;\n  };\n\n  ElementsCollection.prototype.set = function() {\n    ElementsCollection.__super__.set.apply(this, arguments);\n    return this;\n  };\n\n  ElementsCollection.prototype.remove = function() {\n    ElementsCollection.__super__.remove.apply(this, arguments);\n    return this;\n  };\n\n  ElementsCollection.prototype.reset = function() {\n    ElementsCollection.__super__.reset.apply(this, arguments);\n    return this;\n  };\n\n\n  /**\n  \t * Create a way to output our elements to HTML\n  \t * @method toHTML\n  \t * @return {String}\n   */\n\n  ElementsCollection.prototype.toHTML = function() {\n    var html;\n    html = '';\n    this.forEach(function(item) {\n      return html += item.get('html') || '';\n    });\n    return html;\n  };\n\n  ElementsCollection.prototype.join = function() {\n    return this.toHTML();\n  };\n\n  return ElementsCollection;\n\n})(Collection);\n\nmodule.exports = ElementsCollection;\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/lib/collections/meta.js":"// Generated by CoffeeScript 1.12.4\nvar ElementsCollection, MetaCollection,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nElementsCollection = require('./elements');\n\n\n/**\n * Meta collection class. Collection of\n * document meta data strings\n * @class MetaCollection\n * @constructor\n * @extends ElementsCollection\n */\n\nMetaCollection = (function(superClass) {\n  extend(MetaCollection, superClass);\n\n  function MetaCollection() {\n    return MetaCollection.__super__.constructor.apply(this, arguments);\n  }\n\n  return MetaCollection;\n\n})(ElementsCollection);\n\nmodule.exports = MetaCollection;\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/lib/collections/scripts.js":"// Generated by CoffeeScript 1.12.4\nvar ElementsCollection, ScriptsCollection, typeChecker,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\ntypeChecker = require('typechecker');\n\nElementsCollection = require('./elements');\n\n\n/**\n * Scripts collection class. A DocPad\n * project's script file paths\n * @class ScriptCollection\n * @constructor\n * @extends ElementsCollection\n */\n\nScriptsCollection = (function(superClass) {\n  extend(ScriptsCollection, superClass);\n\n  function ScriptsCollection() {\n    return ScriptsCollection.__super__.constructor.apply(this, arguments);\n  }\n\n\n  /**\n  \t * Add an element to the collection\n  \t * Right now we just support strings\n  \t * @method add\n  \t * @param {Array} values string array of file paths\n  \t * @param {Object} opts\n   */\n\n  ScriptsCollection.prototype.add = function(values, opts) {\n    var i, key, len, value;\n    opts || (opts = {});\n    if (opts.defer == null) {\n      opts.defer = true;\n    }\n    if (opts.async == null) {\n      opts.async = false;\n    }\n    opts.attrs || (opts.attrs = '');\n    if (typeChecker.isArray(values)) {\n      values = values.slice();\n    } else if (values) {\n      values = [values];\n    } else {\n      values = [];\n    }\n    if (opts.defer) {\n      opts.attrs += \"defer=\\\"defer\\\" \";\n    }\n    if (opts.async) {\n      opts.attrs += \"async=\\\"async\\\" \";\n    }\n    for (key = i = 0, len = values.length; i < len; key = ++i) {\n      value = values[key];\n      if (typeChecker.isString(value)) {\n        if (value[0] === '<') {\n          continue;\n        } else if (value.indexOf(' ') === -1) {\n          values[key] = \"<script \" + opts.attrs + \" src=\\\"\" + value + \"\\\"></script>\";\n        } else {\n          values[key] = \"<script \" + opts.attrs + \">\" + value + \"</script>\";\n        }\n      }\n    }\n    return ScriptsCollection.__super__.add.call(this, values, opts);\n  };\n\n  return ScriptsCollection;\n\n})(ElementsCollection);\n\nmodule.exports = ScriptsCollection;\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/lib/collections/styles.js":"// Generated by CoffeeScript 1.12.4\nvar ElementsCollection, StylesCollection, typeChecker,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\ntypeChecker = require('typechecker');\n\nElementsCollection = require('./elements');\n\n\n/**\n * Styles collection class. A DocPad\n * project's style (css) file paths\n * @class StylesCollection\n * @constructor\n * @extends ElementsCollection\n */\n\nStylesCollection = (function(superClass) {\n  extend(StylesCollection, superClass);\n\n  function StylesCollection() {\n    return StylesCollection.__super__.constructor.apply(this, arguments);\n  }\n\n\n  /**\n  \t * Add an element to the collection\n  \t * Right now we just support strings\n  \t * @method add\n  \t * @param {Array} values string array of file paths\n  \t * @param {Object} opts\n   */\n\n  StylesCollection.prototype.add = function(values, opts) {\n    var i, key, len, value;\n    opts || (opts = {});\n    opts.attrs || (opts.attrs = '');\n    if (typeChecker.isArray(values)) {\n      values = values.slice();\n    } else if (values) {\n      values = [values];\n    } else {\n      values = [];\n    }\n    for (key = i = 0, len = values.length; i < len; key = ++i) {\n      value = values[key];\n      if (typeChecker.isString(value)) {\n        if (value[0] === '<') {\n          continue;\n        } else if (value.indexOf(' ') === -1) {\n          values[key] = \"<link \" + opts.attrs + \" rel=\\\"stylesheet\\\" href=\\\"\" + value + \"\\\" />\";\n        } else {\n          values[key] = \"<style \" + opts.attrs + \">\" + value + \"</style>\";\n        }\n      }\n    }\n    return StylesCollection.__super__.add.call(this, values, opts);\n  };\n\n  return StylesCollection;\n\n})(ElementsCollection);\n\nmodule.exports = StylesCollection;\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/lib/plugin-loader.js":"// Generated by CoffeeScript 1.12.4\nvar PluginLoader, pathUtil, safefs, semver, util,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\npathUtil = require('path');\n\nutil = require('util');\n\nsemver = require('semver');\n\nsafefs = require('safefs');\n\n\n/**\n * The Plugin Loader class\n * @class PluginLoader\n * @constructor\n */\n\nPluginLoader = (function() {\n\n  /**\n  \t * The DocPad Instance\n  \t * @private\n  \t * @property {Object} docpad\n   */\n  PluginLoader.prototype.docpad = null;\n\n\n  /**\n  \t * The BasePlugin Class\n  \t * @private\n  \t * @property {Object}\n   */\n\n  PluginLoader.prototype.BasePlugin = null;\n\n\n  /**\n  \t * The full path of the plugin's directory\n  \t * @private\n  \t * @property {String}\n   */\n\n  PluginLoader.prototype.dirPath = null;\n\n\n  /**\n  \t * The full path of the plugin's package.json file\n  \t * @private\n  \t * @property {String}\n   */\n\n  PluginLoader.prototype.packagePath = null;\n\n\n  /**\n  \t * The parsed contents of the plugin's package.json file\n  \t * @private\n  \t * @property {Object}\n   */\n\n  PluginLoader.prototype.packageData = {};\n\n\n  /**\n  \t * The full path of the plugin's main file\n  \t * @private\n  \t * @property {String}\n   */\n\n  PluginLoader.prototype.pluginPath = null;\n\n\n  /**\n  \t * The parsed content of the plugin's main file\n  \t * @private\n  \t * @property {Object}\n   */\n\n  PluginLoader.prototype.pluginClass = {};\n\n\n  /**\n  \t * The plugin name\n  \t * @private\n  \t * @property {String}\n   */\n\n  PluginLoader.prototype.pluginName = null;\n\n\n  /**\n  \t * The plugin version\n  \t * @private\n  \t * @property {String}\n   */\n\n  PluginLoader.prototype.pluginVersion = null;\n\n\n  /**\n  \t * Node modules path\n  \t * @private\n  \t * @property {String}\n   */\n\n  PluginLoader.prototype.nodeModulesPath = null;\n\n\n  /**\n  \t * Constructor method\n  \t * @method constructor\n  \t * @param {Object} opts\n  \t * @param {Object} opts.docpad The docpad instance that we are loading plugins for\n  \t * @param {String} opts.dirPath The directory path of the plugin\n  \t * @param {Object} opts.BasePlugin The base plugin class\n   */\n\n  function PluginLoader(arg) {\n    var docpad;\n    this.docpad = arg.docpad, this.dirPath = arg.dirPath, this.BasePlugin = arg.BasePlugin;\n    docpad = this.docpad;\n    this.pluginName = pathUtil.basename(this.dirPath).replace(/^docpad-plugin-/, '');\n    this.pluginClass = {};\n    this.packageData = {};\n    this.nodeModulesPath = pathUtil.resolve(this.dirPath, 'node_modules');\n  }\n\n\n  /**\n  \t * Loads the package.json file and extracts the main path\n  \t * next(err,exists)\n  \t * @method exists\n  \t * @param {Function} next\n   */\n\n  PluginLoader.prototype.exists = function(next) {\n    var failure, packagePath, success;\n    packagePath = this.packagePath || pathUtil.resolve(this.dirPath, \"package.json\");\n    failure = function(err) {\n      if (err == null) {\n        err = null;\n      }\n      return next(err, false);\n    };\n    success = function() {\n      return next(null, true);\n    };\n    safefs.exists(packagePath, (function(_this) {\n      return function(exists) {\n        if (!exists) {\n          return failure();\n        }\n        _this.packagePath = packagePath;\n        return safefs.readFile(packagePath, function(err, data) {\n          var pluginPath, pluginVersion;\n          if (err) {\n            return failure(err);\n          }\n          try {\n            _this.packageData = JSON.parse(data.toString());\n          } catch (error) {\n            err = error;\n            return failure(err);\n          } finally {\n            if (!_this.packageData) {\n              return failure();\n            }\n          }\n          pluginVersion = _this.packageData.version;\n          pluginPath = _this.packageData.main && pathUtil.join(_this.dirPath, _this.packageData.main);\n          if (!pluginVersion) {\n            return failure();\n          }\n          if (!pluginPath) {\n            return failure();\n          }\n          _this.pluginVersion = pluginVersion;\n          _this.pluginPath = pluginPath;\n          return success();\n        });\n      };\n    })(this));\n    return this;\n  };\n\n\n  /**\n  \t * Check if this plugin is unsupported\n  \t * Boolean value returned as a parameter\n  \t * in the passed callback\n  \t * next(err,supported)\n  \t * @method unsupported\n  \t * @param {Function} next\n   */\n\n  PluginLoader.prototype.unsupported = function(next) {\n    var docpad, engines, keywords, peerDependencies, platforms, ref, unsupported, version;\n    docpad = this.docpad;\n    version = this.packageData.version;\n    keywords = this.packageData.keywords || [];\n    platforms = this.packageData.platforms || [];\n    engines = this.packageData.engines || {};\n    peerDependencies = this.packageData.peerDependencies || {};\n    unsupported = indexOf.call(keywords, 'docpad-plugin') < 0 ? 'type' : version && !semver.satisfies(version, docpad.pluginVersion) ? 'version-plugin' : platforms.length && (ref = process.platform, indexOf.call(platforms, ref) < 0) ? 'platform' : (engines.node != null) && !semver.satisfies(process.version, engines.node) ? 'engine-node' : (engines.docpad != null) && !semver.satisfies(docpad.getVersion(), engines.docpad) ? 'version-docpad' : (peerDependencies.docpad != null) && !semver.satisfies(docpad.getVersion(), peerDependencies.docpad) ? 'version-docpad' : false;\n    next(null, unsupported);\n    return this;\n  };\n\n\n  /**\n  \t * Installs the plugins node modules.\n  \t * next(err)\n  \t * @private\n  \t * @method install\n  \t * @param {Function} next\n   */\n\n  PluginLoader.prototype.install = function(next) {\n    var docpad;\n    docpad = this.docpad;\n    if (this.packagePath) {\n      docpad.initNodeModules({\n        path: this.dirPath,\n        next: function(err, results) {\n          return next(err);\n        }\n      });\n    } else {\n      next();\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Load in the pluginClass from the plugin file.\n  \t * The plugin class that has been loaded is returned\n  \t * in the passed callback\n  \t * next(err,pluginClass)\n  \t * @method load\n  \t * @param {Function} next\n   */\n\n  PluginLoader.prototype.load = function(next) {\n    var base, docpad, err, locale, pluginPrototypeName, ref, ref1, ref2, validPluginName;\n    docpad = this.docpad;\n    locale = docpad.getLocale();\n    if (pathUtil.extname(this.pluginPath) === '.coffee') {\n      if (!(this.packageData[\"private\"] === true && docpad.getConfig().warnUncompiledPrivatePlugins === false)) {\n        docpad.warn(util.format(locale.pluginUncompiled, this.pluginName, ((ref = this.packageData.bugs) != null ? ref.url : void 0) || locale.pluginIssueTracker));\n      }\n      try {\n        require('coffee-script/register');\n      } catch (error) {\n        err = error;\n        err.context = util.format(locale.pluginUncompiledFailed, this.pluginName, ((ref1 = this.packageData.bugs) != null ? ref1.url : void 0) || locale.pluginIssueTracker);\n        return next(err);\n        this;\n      }\n    }\n    try {\n      this.pluginClass = require(this.pluginPath)(this.BasePlugin);\n    } catch (error) {\n      err = error;\n      err.context = util.format(locale.pluginLoadFailed, this.pluginName, ((ref2 = this.packageData.bugs) != null ? ref2.url : void 0) || locale.pluginIssueTracker);\n      return next(err);\n      this;\n    }\n    if ((base = this.pluginClass.prototype).version == null) {\n      base.version = this.pluginVersion;\n    }\n    pluginPrototypeName = this.pluginClass.prototype.name;\n    if (/^[a-z0-9]+$/.test(this.pluginName) === false) {\n      validPluginName = this.pluginName.replace(/[^a-z0-9]/, '');\n      docpad.warn(util.format(locale.pluginNamingConventionInvalid, this.pluginName, validPluginName));\n    }\n    if (pluginPrototypeName === null) {\n      this.pluginClass.prototype.name = this.pluginName;\n      docpad.warn(util.format(locale.pluginPrototypeNameUndefined, this.pluginName));\n    } else if (pluginPrototypeName !== this.pluginName) {\n      docpad.warn(util.format(locale.pluginPrototypeNameDifferent, this.pluginName, pluginPrototypeName));\n    }\n    next(null, this.pluginClass);\n    return this;\n  };\n\n\n  /**\n  \t * Create an instance of a plugin\n  \t * defined by the passed config.\n  \t * The plugin instance is returned in\n  \t * the passed callback.\n  \t * next(err,pluginInstance)\n  \t * @method create\n  \t * @param {Object} config\n  \t * @param {Function} next\n   */\n\n  PluginLoader.prototype.create = function(config, next) {\n    var docpad, err, pluginInstance;\n    try {\n      docpad = this.docpad;\n      pluginInstance = new this.pluginClass({\n        docpad: docpad,\n        config: config\n      });\n    } catch (error) {\n      err = error;\n      return next(err, null);\n    }\n    return next(null, pluginInstance);\n    return this;\n  };\n\n  return PluginLoader;\n\n})();\n\nmodule.exports = PluginLoader;\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/lib/plugin.js":"// Generated by CoffeeScript 1.12.4\nvar BasePlugin, ambi, eachr, extendr, typeChecker,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nextendr = require('extendr');\n\ntypeChecker = require('typechecker');\n\nambi = require('ambi');\n\neachr = require('eachr');\n\n\n/**\n * The base class for all DocPad plugins\n * @class BasePlugin\n * @constructor\n */\n\nBasePlugin = (function() {\n\n  /**\n  \t * Add support for BasePlugin.extend(proto)\n  \t * @private\n  \t * @property {Object} @extend\n   */\n  BasePlugin.extend = require('csextends');\n\n\n  /**\n  \t * The DocPad Instance\n  \t * @private\n  \t * @property {Object} docpad\n   */\n\n  BasePlugin.prototype.docpad = null;\n\n\n  /**\n  \t * The plugin name\n  \t * @property {String}\n   */\n\n  BasePlugin.prototype.name = null;\n\n\n  /**\n  \t * The plugin config\n  \t * @property {Object}\n   */\n\n  BasePlugin.prototype.config = {};\n\n\n  /**\n  \t * The instance config.\n  \t * @property {Object}\n   */\n\n  BasePlugin.prototype.instanceConfig = {};\n\n\n  /**\n  \t * Plugin priority\n  \t * @private\n  \t * @property {Number}\n   */\n\n  BasePlugin.prototype.priority = 500;\n\n\n  /**\n  \t * Constructor method for the plugin\n  \t * @method constructor\n  \t * @param {Object} opts\n   */\n\n  function BasePlugin(opts) {\n    this.getConfig = bind(this.getConfig, this);\n    this.setConfig = bind(this.setConfig, this);\n    var config, docpad, me;\n    me = this;\n    docpad = opts.docpad, config = opts.config;\n    this.docpad = docpad;\n    this.bindListeners();\n    this.config = extendr.deepClone(this.config);\n    this.instanceConfig = extendr.deepClone(this.instanceConfig);\n    this.initialConfig = this.config;\n    this.setConfig(config);\n    if (this.isEnabled() === false) {\n      return this;\n    }\n    this.addListeners();\n    this;\n  }\n\n\n  /**\n  \t * Set Instance Configuration\n  \t * @private\n  \t * @method setInstanceConfig\n  \t * @param {Object} instanceConfig\n   */\n\n  BasePlugin.prototype.setInstanceConfig = function(instanceConfig) {\n    if (instanceConfig) {\n      extendr.safeDeepExtendPlainObjects(this.instanceConfig, instanceConfig);\n      if (this.config) {\n        extendr.safeDeepExtendPlainObjects(this.config, instanceConfig);\n      }\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Set Configuration\n  \t * @private\n  \t * @method {Object} setConfig\n  \t * @param {Object} [instanceConfig=null]\n   */\n\n  BasePlugin.prototype.setConfig = function(instanceConfig) {\n    var configPackages, configsToMerge, docpad, userConfig;\n    if (instanceConfig == null) {\n      instanceConfig = null;\n    }\n    docpad = this.docpad;\n    userConfig = this.docpad.config.plugins[this.name];\n    this.config = this.docpad.config.plugins[this.name] = {};\n    if (instanceConfig) {\n      this.setInstanceConfig(instanceConfig);\n    }\n    configPackages = [this.initialConfig, userConfig, this.instanceConfig];\n    configsToMerge = [this.config];\n    docpad.mergeConfigurations(configPackages, configsToMerge);\n    if (!this.isEnabled()) {\n      this.removeListeners();\n    }\n    return this;\n  };\n\n\n  /**\n  \t * Get the Configuration\n  \t * @private\n  \t * @method {Object}\n   */\n\n  BasePlugin.prototype.getConfig = function() {\n    return this.config;\n  };\n\n\n  /**\n  \t * Alias for b/c\n  \t * @private\n  \t * @method bindEvents\n   */\n\n  BasePlugin.prototype.bindEvents = function() {\n    return this.addListeners();\n  };\n\n\n  /**\n  \t * Bind Listeners\n  \t * @private\n  \t * @method bindListeners\n   */\n\n  BasePlugin.prototype.bindListeners = function() {\n    var docpad, events, pluginInstance;\n    pluginInstance = this;\n    docpad = this.docpad;\n    events = docpad.getEvents();\n    eachr(events, function(eventName) {\n      var eventHandler;\n      eventHandler = pluginInstance[eventName];\n      if (typeChecker.isFunction(eventHandler)) {\n        return pluginInstance[eventName] = eventHandler.bind(pluginInstance);\n      }\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Add Listeners\n  \t * @private\n  \t * @method addListeners\n   */\n\n  BasePlugin.prototype.addListeners = function() {\n    var docpad, events, pluginInstance;\n    pluginInstance = this;\n    docpad = this.docpad;\n    events = docpad.getEvents();\n    eachr(events, function(eventName) {\n      var eventHandler, eventHandlerPriority;\n      eventHandler = pluginInstance[eventName];\n      if (typeChecker.isFunction(eventHandler)) {\n        eventHandlerPriority = pluginInstance[eventName + 'Priority'] || pluginInstance.priority || null;\n        if (eventHandler.priority == null) {\n          eventHandler.priority = eventHandlerPriority;\n        }\n        eventHandler.name = pluginInstance.name + \": {eventName}\";\n        if (eventHandler.priority != null) {\n          eventHandler.name += \"(priority eventHandler.priority})\";\n        }\n        return docpad.off(eventName, eventHandler).on(eventName, eventHandler);\n      }\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Remove Listeners\n  \t * @private\n  \t * @method removeListeners\n   */\n\n  BasePlugin.prototype.removeListeners = function() {\n    var docpad, events, pluginInstance;\n    pluginInstance = this;\n    docpad = this.docpad;\n    events = docpad.getEvents();\n    eachr(events, function(eventName) {\n      var eventHandler;\n      eventHandler = pluginInstance[eventName];\n      if (typeChecker.isFunction(eventHandler)) {\n        return docpad.off(eventName, eventHandler);\n      }\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Destructor. Calls removeListeners\n  \t * @private\n  \t * @method destroy\n   */\n\n  BasePlugin.prototype.destroy = function() {\n    this.removeListeners();\n    return this;\n  };\n\n\n  /**\n  \t * Is Enabled?\n  \t * @method isEnabled\n  \t * @return {Boolean}\n   */\n\n  BasePlugin.prototype.isEnabled = function() {\n    return this.config.enabled !== false;\n  };\n\n  return BasePlugin;\n\n})();\n\nmodule.exports = BasePlugin;\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/bin/docpad-compile.js":"// Generated by CoffeeScript 1.12.4\nvar DocPad, action, docpadConfig, docpadUtil, getArgument;\n\nDocPad = require('../lib/docpad');\n\ndocpadUtil = require('../lib/util');\n\ngetArgument = function(name, value, defaultValue) {\n  var argumentIndex, result;\n  if (value == null) {\n    value = null;\n  }\n  if (defaultValue == null) {\n    defaultValue = null;\n  }\n  result = defaultValue;\n  argumentIndex = process.argv.indexOf(\"--\" + name);\n  if (argumentIndex !== -1) {\n    result = value != null ? value : process.argv[argumentIndex + 1];\n  }\n  return result;\n};\n\naction = (getArgument('action', null, 'generate') + ' ' + getArgument('watch', 'watch', '')).trim();\n\ndocpadConfig = {};\n\ndocpadConfig.rootPath = getArgument('rootPath', null, process.cwd());\n\ndocpadConfig.outPath = getArgument('outPath', null, docpadConfig.rootPath + '/out');\n\ndocpadConfig.srcPath = getArgument('srcPath', null, docpadConfig.rootPath + '/src');\n\ndocpadConfig.documentsPaths = (function() {\n  var documentsPath;\n  documentsPath = getArgument('documentsPath');\n  if (documentsPath != null) {\n    if (documentsPath === 'auto') {\n      documentsPath = docpadConfig.srcPath;\n    }\n  } else {\n    documentsPath = docpadConfig.srcPath + '/documents';\n  }\n  return [documentsPath];\n})();\n\ndocpadConfig.port = (function() {\n  var port;\n  port = getArgument('port');\n  if (port && isNaN(port) === false) {\n    port = parseInt(port, 10);\n  }\n  return port;\n})();\n\ndocpadConfig.renderSingleExtensions = (function() {\n  var renderSingleExtensions;\n  renderSingleExtensions = getArgument('renderSingleExtensions', null, 'auto');\n  if (renderSingleExtensions === 'true' || renderSingleExtensions === 'yes') {\n    renderSingleExtensions = true;\n  } else if (renderSingleExtensions === 'false' || renderSingleExtensions === 'no') {\n    renderSingleExtensions = false;\n  }\n  return renderSingleExtensions;\n})();\n\nnew DocPad(docpadConfig, function(err, docpad) {\n  if (err) {\n    return docpadUtil.writeError(err);\n  }\n  return docpad.action(action, function(err) {\n    if (err) {\n      return docpadUtil.writeError(err);\n    }\n    return console.log('OK');\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/bin/docpad.js":"// Generated by CoffeeScript 1.12.4\nvar checkDocPad, docpadUtil, startDocPad,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nif (process.versions.node.indexOf('0') === 0 && process.versions.node.split('.')[1] % 2 !== 0) {\n  console.log(require('util').format(\"== WARNING ==\\n   DocPad is running against an unstable version of Node.js (v%s to be precise).\\n   Unstable versions of Node.js WILL break things! Do not use them with DocPad!\\n   Run DocPad with a stable version of Node.js (e.g. v%s) for a stable experience.\\n   For more information, visit: %s\\n== WARNING ===\", process.versions.node, \"0.\" + (process.versions.node.split('.')[1] - 1), \"http://docpad.org/unstable-node\"));\n}\n\ndocpadUtil = require('../lib/util');\n\ncheckDocPad = function() {\n  if (indexOf.call(process.argv, '--global') >= 0 || indexOf.call(process.argv, '--g') >= 0) {\n    return startDocPad();\n  }\n  if (docpadUtil.isLocalDocPadExecutable()) {\n    return startDocPad();\n  }\n  if (docpadUtil.getLocalDocPadExecutableExistance() === false) {\n    return startDocPad();\n  }\n  return docpadUtil.startLocalDocPadExecutable();\n};\n\nstartDocPad = function() {\n  var ConsoleInterface, DocPad, action;\n  DocPad = require('../lib/docpad');\n  ConsoleInterface = require('../lib/interfaces/console');\n  action = process.argv.slice(1).join(' ').indexOf('deploy') !== -1 ? 'load' : false;\n  return new DocPad({\n    action: action\n  }, function(err, docpad) {\n    if (err) {\n      return docpadUtil.writeError(err);\n    }\n    return new ConsoleInterface({\n      docpad: docpad\n    }, function(err, consoleInterface) {\n      if (err) {\n        return docpadUtil.writeError(err);\n      }\n      return consoleInterface.start();\n    });\n  });\n};\n\ncheckDocPad();\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/bin/docpad-server.js":"// Generated by CoffeeScript 1.12.4\nvar DocPad, action, docpadConfig, docpadUtil, getArgument;\n\nDocPad = require('../lib/docpad');\n\ndocpadUtil = require('../lib/util');\n\ngetArgument = function(name, value, defaultValue) {\n  var argumentIndex, result;\n  if (value == null) {\n    value = null;\n  }\n  if (defaultValue == null) {\n    defaultValue = null;\n  }\n  result = defaultValue;\n  argumentIndex = process.argv.indexOf(\"--\" + name);\n  if (argumentIndex !== -1) {\n    result = value != null ? value : process.argv[argumentIndex + 1];\n  }\n  return result;\n};\n\naction = getArgument('action', null, 'server generate');\n\ndocpadConfig = {};\n\ndocpadConfig.port = (function() {\n  var port;\n  port = getArgument('port');\n  if (port && isNaN(port) === false) {\n    port = parseInt(port, 10);\n  }\n  return port;\n})();\n\nnew DocPad(docpadConfig, function(err, docpad) {\n  if (err) {\n    return docpadUtil.writeError(err);\n  }\n  return docpad.action(action, function(err) {\n    if (err) {\n      return docpadUtil.writeError(err);\n    }\n    return console.log('OK');\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-docpad/node_modules/docpad/out/lib/testers.js":"// Generated by CoffeeScript 1.12.4\nvar CSON, DocPad, PluginTester, RendererTester, ServerTester, assert, balUtil, deepEqual, difference, docpadUtil, equal, errorEqual, extendr, joe, pathUtil, pluginPort, ref, safefs, test, testers,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\npathUtil = require('path');\n\nsafefs = require('safefs');\n\nbalUtil = require('bal-util');\n\nextendr = require('extendr');\n\njoe = require('joe');\n\nassert = require('assert');\n\nref = require('assert-helpers'), equal = ref.equal, deepEqual = ref.deepEqual, errorEqual = ref.errorEqual;\n\nCSON = require('cson');\n\ndifference = require('underscore').difference;\n\nDocPad = require('./docpad');\n\ndocpadUtil = require('./util');\n\npluginPort = 2000 + parseInt(String(Date.now()).substr(-6, 4));\n\ntesters = {\n  CSON: CSON,\n  DocPad: DocPad\n};\n\n\n/**\n * The Plugin Tester class\n * @class PluginTester\n * @constructor\n */\n\ntesters.PluginTester = PluginTester = (function() {\n  PluginTester.extend = require('csextends');\n\n\n  /**\n  \t * Default plugin config\n  \t * @property {Object}\n   */\n\n  PluginTester.prototype.config = {\n    testerName: null,\n    pluginName: null,\n    pluginPath: null,\n    testPath: null,\n    outExpectedPath: null,\n    removeWhitespace: false,\n    contentRemoveRegex: null,\n    autoExit: 'safe'\n  };\n\n\n  /**\n  \t * Default DocPad config\n  \t * @property {Object}\n   */\n\n  PluginTester.prototype.docpadConfig = {\n    global: true,\n    port: null,\n    logLevel: ((indexOf.call(process.argv, '-d') >= 0) ? 7 : 5),\n    rootPath: null,\n    outPath: null,\n    srcPath: null,\n    pluginPaths: null,\n    enableUnlistedPlugins: true,\n    enabledPlugins: null,\n    skipUnsupportedPlugins: false,\n    catchExceptions: false,\n    environment: null\n  };\n\n\n  /**\n  \t * The DocPad instance\n  \t * @private\n  \t * @property {Object}\n   */\n\n  PluginTester.prototype.docpad = null;\n\n\n  /**\n  \t * Constructor method\n  \t * @method constructor\n  \t * @param {Object} [config={}]\n  \t * @param {Object} [docpadConfig={}]\n  \t * @param {Function} next\n   */\n\n  function PluginTester(config, docpadConfig, next) {\n    var base, base1, base2, base3, base4, base5, base6, base7, base8, defaultEnabledPlugins, tester;\n    if (config == null) {\n      config = {};\n    }\n    if (docpadConfig == null) {\n      docpadConfig = {};\n    }\n    this.testEverything = bind(this.testEverything, this);\n    this.testGenerate = bind(this.testGenerate, this);\n    this.testServer = bind(this.testServer, this);\n    this.testLoad = bind(this.testLoad, this);\n    this.testCreate = bind(this.testCreate, this);\n    tester = this;\n    this.config = extendr.deepExtendPlainObjects({}, PluginTester.prototype.config, this.config, config);\n    this.docpadConfig = extendr.deepExtendPlainObjects({}, PluginTester.prototype.docpadConfig, this.docpadConfig, docpadConfig);\n    if ((base = this.docpadConfig).port == null) {\n      base.port = ++pluginPort;\n    }\n    if ((base1 = this.config).testerName == null) {\n      base1.testerName = this.config.pluginName + \" plugin\";\n    }\n    (base2 = this.config).testPath || (base2.testPath = pathUtil.join(this.config.pluginPath, 'test'));\n    (base3 = this.config).outExpectedPath || (base3.outExpectedPath = pathUtil.join(this.config.testPath, 'out-expected'));\n    (base4 = this.docpadConfig).rootPath || (base4.rootPath = this.config.testPath);\n    (base5 = this.docpadConfig).outPath || (base5.outPath = pathUtil.join(this.docpadConfig.rootPath, 'out'));\n    (base6 = this.docpadConfig).srcPath || (base6.srcPath = pathUtil.join(this.docpadConfig.rootPath, 'src'));\n    if ((base7 = this.docpadConfig).pluginPaths == null) {\n      base7.pluginPaths = [this.config.pluginPath];\n    }\n    defaultEnabledPlugins = {};\n    defaultEnabledPlugins[this.config.pluginName] = true;\n    (base8 = this.docpadConfig).enabledPlugins || (base8.enabledPlugins = defaultEnabledPlugins);\n    joe.describe(this.config.testerName, function(suite, task) {\n      tester.describe = tester.suite = suite;\n      tester.it = tester.test = task;\n      tester.done = tester.exit = function(next) {\n        var ref1;\n        return (ref1 = tester.docpad) != null ? ref1.action('destroy', next) : void 0;\n      };\n      return typeof next === \"function\" ? next(null, tester) : void 0;\n    });\n    this;\n  }\n\n\n  /**\n  \t * Get tester Configuration\n  \t * @method getConfig\n  \t * @return {Object}\n   */\n\n  PluginTester.prototype.getConfig = function() {\n    return this.config;\n  };\n\n\n  /**\n  \t * Get the plugin instance\n  \t * @method getPlugin\n  \t * @return {Object} the plugin\n   */\n\n  PluginTester.prototype.getPlugin = function() {\n    return this.docpad.getPlugin(this.getConfig().pluginName);\n  };\n\n\n  /**\n  \t * Create the DocPad instance\n  \t * @method testCreate\n   */\n\n  PluginTester.prototype.testCreate = function() {\n    var docpadConfig, tester;\n    tester = this;\n    docpadConfig = this.docpadConfig;\n    this.test(\"create\", function(done) {\n      return new DocPad(docpadConfig, function(err, docpad) {\n        if (err) {\n          return done(err);\n        }\n        tester.docpad = docpad;\n        return tester.docpad.action('init', function(err) {\n          if (err && err.message !== tester.docpad.getLocale().skeletonExists) {\n            return done(err);\n          }\n          return tester.docpad.action('clean', function(err) {\n            if (err) {\n              return done(err);\n            }\n            return tester.docpad.action('install', done);\n          });\n        });\n      });\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Test Loaded\n  \t * @method\n   */\n\n  PluginTester.prototype.testLoad = function() {\n    var tester;\n    tester = this;\n    this.test(\"load plugin \" + tester.config.pluginName, function(done) {\n      return tester.docpad.loadedPlugin(tester.config.pluginName, function(err, loaded) {\n        if (err) {\n          return done(err);\n        }\n        assert.ok(loaded);\n        return done();\n      });\n    });\n    return this;\n  };\n\n  PluginTester.prototype.testServer = function(next) {\n    var tester;\n    tester = this;\n    this.test(\"server\", function(done) {\n      return tester.docpad.action('server', function(err) {\n        return done(err);\n      });\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Test generate\n  \t * @method\n   */\n\n  PluginTester.prototype.testGenerate = function() {\n    var tester;\n    tester = this;\n    this.test(\"generate\", function(done) {\n      return tester.docpad.action('generate', function(err) {\n        return done(err);\n      });\n    });\n    return this;\n  };\n\n\n  /**\n  \t * Test everything\n  \t * @method {Object}\n   */\n\n  PluginTester.prototype.testEverything = function() {\n    var tester;\n    tester = this;\n    this.testCreate();\n    this.testLoad();\n    this.testGenerate();\n    this.testServer();\n    if (typeof this.testCustom === \"function\") {\n      this.testCustom();\n    }\n    this.finish();\n    return this;\n  };\n\n\n  /**\n  \t * Finish\n  \t * @method finish\n   */\n\n  PluginTester.prototype.finish = function() {\n    var tester;\n    tester = this;\n    if (tester.config.autoExit) {\n      this.test('finish up', function(next) {\n        return tester.exit(next);\n      });\n    }\n    return this;\n  };\n\n  return PluginTester;\n\n})();\n\n\n/**\n * Server tester\n * @class ServerTester\n * @extends PluginTester\n * @constructor\n */\n\ntesters.ServerTester = ServerTester = (function(superClass) {\n  extend(ServerTester, superClass);\n\n  function ServerTester() {\n    return ServerTester.__super__.constructor.apply(this, arguments);\n  }\n\n  return ServerTester;\n\n})(PluginTester);\n\n\n/**\n * Rednderer tester\n * @class ServerTester\n * @extends PluginTester\n * @constructor\n */\n\ntesters.RendererTester = RendererTester = (function(superClass) {\n  extend(RendererTester, superClass);\n\n  function RendererTester() {\n    return RendererTester.__super__.constructor.apply(this, arguments);\n  }\n\n  RendererTester.prototype.testGenerate = function() {\n    var tester;\n    tester = this;\n    this.suite(\"generate\", function(suite, test) {\n      test('action', function(done) {\n        return tester.docpad.action('generate', function(err) {\n          return done(err);\n        });\n      });\n      return suite('results', function(suite, test, done) {\n        return balUtil.scanlist(tester.docpadConfig.outPath, function(err, outResults) {\n          if (err) {\n            return done(err);\n          }\n          return balUtil.scanlist(tester.config.outExpectedPath, function(err, outExpectedResults) {\n            var outExpectedResultsKeys, outResultsKeys;\n            if (err) {\n              return done(err);\n            }\n            outResultsKeys = Object.keys(outResults);\n            outExpectedResultsKeys = Object.keys(outExpectedResults);\n            test('same files', function() {\n              var outDifferenceKeys;\n              outDifferenceKeys = difference(outExpectedResultsKeys, outResultsKeys);\n              deepEqual(outDifferenceKeys, [], 'The following file(s) should have been generated');\n              outDifferenceKeys = difference(outResultsKeys, outExpectedResultsKeys);\n              return deepEqual(outDifferenceKeys, [], 'The following file(s) should not have been generated');\n            });\n            outResultsKeys.forEach(function(key) {\n              return test(\"same file content for: \" + key, function() {\n                var actual, expected, replaceLinesRegex;\n                actual = outResults[key];\n                expected = outExpectedResults[key];\n                if (tester.config.removeWhitespace === true) {\n                  replaceLinesRegex = /\\s+/g;\n                  actual = actual.replace(replaceLinesRegex, '');\n                  expected = expected.replace(replaceLinesRegex, '');\n                }\n                if (tester.config.contentRemoveRegex) {\n                  actual = actual.replace(tester.config.contentRemoveRegex, '');\n                  expected = expected.replace(tester.config.contentRemoveRegex, '');\n                }\n                return equal(actual, expected);\n              });\n            });\n            return done();\n          });\n        });\n      });\n    });\n    return this;\n  };\n\n  return RendererTester;\n\n})(PluginTester);\n\n\n/**\n * Test a plugin\n * test({pluginPath: String})\n * @property test\n */\n\ntesters.test = test = function(testerConfig, docpadConfig) {\n  var complete;\n  if (testerConfig.testerClass == null) {\n    testerConfig.testerClass = PluginTester;\n  }\n  testerConfig.pluginPath = pathUtil.resolve(testerConfig.pluginPath);\n  if (testerConfig.pluginName == null) {\n    testerConfig.pluginName = pathUtil.basename(testerConfig.pluginPath).replace('docpad-plugin-', '');\n  }\n  if (testerConfig.testerPath == null) {\n    testerConfig.testerPath = pathUtil.join('out', testerConfig.pluginName + \".tester.js\");\n  }\n  if (testerConfig.testerPath) {\n    testerConfig.testerPath = pathUtil.resolve(testerConfig.pluginPath, testerConfig.testerPath);\n  }\n  complete = function() {\n    if (typeof testerConfig.testerClass === 'string') {\n      testerConfig.testerClass = testers[testerConfig.testerClass];\n    }\n    return new testerConfig.testerClass(testerConfig, docpadConfig, function(err, testerInstance) {\n      if (err) {\n        throw err;\n      }\n      return testerInstance.testEverything();\n    });\n  };\n  if (testerConfig.testerPath) {\n    safefs.exists(testerConfig.testerPath, function(exists) {\n      if (exists) {\n        testerConfig.testerClass = require(testerConfig.testerPath)(testers);\n      }\n      return complete();\n    });\n  } else {\n    complete();\n  }\n  return testers;\n};\n\nmodule.exports = testers;\n"}